# Code snapshot (2025-10-14T23:50:35)



---

## `backend/manage.py`

```py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```


---

## `backend/sales_portal/settings.py`

```py
"""
Django settings for sales_portal project.
"""

import os
from pathlib import Path
BASE_DIR = Path(__file__).resolve().parent.parent

# безопасная загрузка .env
try:
    from dotenv import load_dotenv
    load_dotenv(BASE_DIR / ".env")
except Exception:
    pass

CSI_API_MODE = os.getenv("CSI_API_MODE", "prod")
CSI_API_BASE = os.getenv("CSI_API_BASE_PROD") if CSI_API_MODE == "prod" else os.getenv("CSI_API_BASE_LOCAL")
CSI_HTTP_TIMEOUT = float(os.getenv("CSI_HTTP_TIMEOUT", "6"))
CSI_CACHE_SECONDS = int(os.getenv("CSI_CACHE_SECONDS", "60"))

CSI = {
    "MODE": CSI_API_MODE,
    "BASE": CSI_API_BASE,
    "HTTP_TIMEOUT": CSI_HTTP_TIMEOUT,
    "CACHE_SECONDS": CSI_CACHE_SECONDS,
    "TOKEN": os.getenv("CSI_API_TOKEN", ""),
}

# Простой локальный кэш (на проде можно поменять на Redis)
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "salesportal-cache",
        "TIMEOUT": CSI_CACHE_SECONDS,
        "KEY_FUNCTION": "sales.cache.make_key",
    }
}

REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
        "rest_framework.parsers.FormParser",
        "rest_framework.parsers.MultiPartParser",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
    ],
}

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "console": {"class": "logging.StreamHandler"},
    },
    "loggers": {
        "django": {"handlers": ["console"], "level": "INFO"},
        "sales": {"handlers": ["console"], "level": "DEBUG"},
        "requests": {"handlers": ["console"], "level": "WARNING"},
    },
}

# Quick-start development settings - unsuitable for production
SECRET_KEY = os.getenv(
    "SECRET_KEY",
    "django-insecure-#zl=j@4t*mj1s^hy*o5nb@+jbg_od^=+bq25)jd%a)_jb6z@1y"
)

DEBUG = os.getenv("DEBUG", "1") == "1"
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "").split(",") if not DEBUG else []

# ── Куки: политика для локальной разработки и прод ────────────────────────────
# SameSite=Lax нужен для работы сессии между localhost:3000 и localhost:8001
CSRF_COOKIE_NAME = "csrftoken"
CSRF_COOKIE_HTTPONLY = False  # фронту нужно читать cookie
CSRF_COOKIE_SAMESITE = "Lax"  # оставим Lax для localhost
# если у вас dev без https:
CSRF_COOKIE_SECURE = False

SESSION_COOKIE_SAMESITE = "Lax"
SESSION_COOKIE_SECURE = False

# Безопасные флаги: в dev — False, на проде — True
if DEBUG:
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
    # SECURE_SSL_REDIRECT = False
else:
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
    # SECURE_SSL_REDIRECT = True

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    "rest_framework",
    "corsheaders",
    'sales.apps.SalesConfig',   # <- не просто 'sales'
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# CORS
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
]

CORS_ALLOW_HEADERS = [
    "accept",
    "accept-language",
    "content-type",
    "x-csrftoken",
    "x-requested-with",
    "authorization",
]

CSRF_TRUSTED_ORIGINS = [
    "http://127.0.0.1:3000",
    "http://localhost:3000",
]

ROOT_URLCONF = 'sales_portal.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# TEMPLATES
TEMPLATES[0]["DIRS"] = [BASE_DIR / "templates"]

WSGI_APPLICATION = 'sales_portal.wsgi.application'

# Database
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "sales_portal.sqlite3",
    },
    # "legacy": {...}
}

DATA_UPLOAD_MAX_MEMORY_SIZE = 20 * 1024 * 1024  # 20 MB
FILE_UPLOAD_MAX_MEMORY_SIZE = 20 * 1024 * 1024

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Internationalization
LANGUAGE_CODE = 'ru'
TIME_ZONE = 'Europe/Madrid'
USE_I18N = True
USE_TZ = True

# Static / Media
STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

load_dotenv(os.path.join(BASE_DIR, '..', '.env'))

def _clean(s):
    if s is None:
        return None
    return s.replace('\u00a0','').strip()

EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = _clean(os.environ.get("EMAIL_HOST", "smtp.gmail.com"))
EMAIL_PORT = int(os.environ.get("EMAIL_PORT", 587))
EMAIL_USE_TLS = os.environ.get("EMAIL_USE_TLS","true").lower() == "true"

EMAIL_HOST_USER = _clean(os.environ.get("EMAIL_HOST_USER"))
EMAIL_HOST_PASSWORD = _clean(os.environ.get("EMAIL_HOST_PASSWORD"))

DEFAULT_FROM_EMAIL = f'{os.environ.get("EMAIL_FROM_NAME","SalesPortal")} <{EMAIL_HOST_USER}>'
SERVER_EMAIL = DEFAULT_FROM_EMAIL
EMAIL_SUBJECT_PREFIX = "[SalesPortal] "

```


---

## `backend/sales_portal/urls.py`

```py
# backend/sales_portal/urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

# используем health из sales.views_api
from sales import views_api as api

urlpatterns = [
    path('admin/', admin.site.urls),
    path("api/health/", api.health),        # /api/health/ → один источник
    path("api/sales/", include("sales.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

```


---

## `backend/sales_portal/wsgi.py`

```py
"""
WSGI config for sales_portal project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')

application = get_wsgi_application()

```


---

## `backend/sales_portal/asgi.py`

```py
"""
ASGI config for sales_portal project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')

application = get_asgi_application()

```


---

## `backend/sales/apps.py`

```py
# sales/apps.py
from django.apps import AppConfig

class SalesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'sales'

    def ready(self):
        # подключаем сигналы при старте Django
        from . import signals  # noqa

```


---

## `backend/sales/models.py`

```py
# backend/sales/models.py
from django.db import models
from django.contrib.auth.models import User
from django.conf import settings
import re
import logging
from functools import lru_cache
from decimal import Decimal

log = logging.getLogger(__name__)

# ───── Справочники ────────────────────────────────────────────────────────────
LANG_CHOICES = (
    ("ru", "Русский"),
    ("en", "English"),
    ("es", "Español"),
    ("fr", "Français"),
    ("de", "Deutsch"),
)

PRICE_SOURCE = (
    ("PICKUP", "По данным pickup/v2"),
    ("REGION", "По региональным ценам"),
    ("MANUAL", "Указано вручную"),
)

# ───── Utils ──────────────────────────────────────────────────────────────────
def _norm_name(s: str) -> str:
    s = (s or "").strip()
    s = re.sub(r"\s+", " ", s)
    return s.title()

# ───── Базовые цены НЕТТО ─────-───────────────────────────────────────────────
# кэшируем вызовы к CSI, чтобы в админке не дёргать API по сто раз
@lru_cache(maxsize=512)
def _exc_title_cached(excursion_id: int, lang: str = "ru") -> str:
    try:
        from .services import costasolinfo as csi
        return csi.excursion_title(int(excursion_id), lang=lang) or ""
    except Exception:
        return ""

class ExcursionNetPrice(models.Model):
    # строковая ссылка, чтобы избежать NameError
    company = models.ForeignKey(
        'sales.Company',  # или просто 'Company', если модель в этом же app
        null=True, blank=True,
        on_delete=models.SET_NULL,
        related_name='net_prices',
        help_text="Если пусто — цена действует для всех компаний",
    )

    excursion_id = models.IntegerField(db_index=True)
    region_slug   = models.SlugField(max_length=32, blank=True, db_index=True,
                                     help_text="Например: malaga, cds, marbella, estepona")
    currency      = models.CharField(max_length=3, default="EUR")

    net_per_adult = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    net_per_child = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    child_discount_pct = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('25'))

    valid_from = models.DateField(null=True, blank=True)
    valid_to   = models.DateField(null=True, blank=True)
    is_active  = models.BooleanField(default=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = (('company', 'excursion_id', 'region_slug'),)
        ordering = ['excursion_id', 'region_slug']

    def __str__(self):
        return f"net ex#{self.excursion_id} [{self.region_slug or 'all'}]"

    def effective_child_net(self):
        """Если нет явной детской цены — применяем скидку от взрослой."""
        if self.net_per_child is not None:
            return self.net_per_child
        if self.net_per_adult is None:
            return None
        pct = self.child_discount_pct or Decimal('25')
        return (self.net_per_adult * (Decimal('100') - pct) / Decimal('100')).quantize(Decimal('0.01'))


# ───── Базовые справочники ────────────────────────────────────────────────────
class Company(models.Model):
    name = models.CharField(max_length=120)
    slug = models.SlugField(unique=True)
    email_for_orders = models.EmailField(blank=True, null=True)
    is_active = models.BooleanField(default=True)
    def __str__(self): return self.name

class GuideProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    companies = models.ManyToManyField(Company, blank=True)
    def __str__(self): return self.user.get_username()

# ───── Семейные брони / туристы ───────────────────────────────────────────────
class FamilyBooking(models.Model):
    ref_code = models.CharField("Номер брони/заявки", max_length=64, db_index=True, blank=True)
    hotel_id = models.IntegerField()
    hotel_name = models.CharField(max_length=255, blank=True)
    region_name = models.CharField(max_length=120, blank=True)

    arrival_date = models.DateField(null=True, blank=True)
    departure_date = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=64, blank=True)
    email = models.EmailField(blank=True)
    comment = models.TextField(blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=["hotel_id", "arrival_date"]),
            models.Index(fields=["ref_code"]),
        ]
        ordering = ["-arrival_date", "hotel_name"]

    def __str__(self):
        return f"{self.ref_code or '—'} @ {self.hotel_name}"

class Traveler(models.Model):
    family = models.ForeignKey(FamilyBooking, on_delete=models.CASCADE, related_name="travelers")
    first_name = models.CharField(max_length=64)
    last_name  = models.CharField(max_length=64)
    middle_name = models.CharField(max_length=64, blank=True)
    dob = models.DateField("Дата рождения", null=True, blank=True)
    nationality = models.CharField(max_length=64, blank=True)
    passport = models.CharField(max_length=64, blank=True)
    passport_expiry = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=64, blank=True)
    email = models.EmailField(blank=True)
    note = models.CharField(max_length=255, blank=True)
    gender = models.CharField(max_length=1, choices=[('M','Male'),('F','Female')], null=True, blank=True)
    doc_type = models.CharField(max_length=16, choices=[('passport','Passport'),('dni','DNI')], null=True, blank=True)
    doc_expiry = models.DateField(null=True, blank=True)

    class Meta:
        unique_together = [("family", "last_name", "first_name", "dob")]
        indexes = [
            models.Index(fields=["family", "last_name", "first_name", "dob"]),
            models.Index(fields=["last_name", "first_name", "dob"]),
        ]

    def save(self, *args, **kwargs):
        self.last_name = _norm_name(self.last_name)
        self.first_name = _norm_name(self.first_name)
        self.middle_name = _norm_name(self.middle_name)
        super().save(*args, **kwargs)

    def __str__(self): return f"{self.last_name} {self.first_name}"

# ───── Проданные экскурсии ────────────────────────────────────────────────────
class BookingSale(models.Model):
    STATUS = [
        ("DRAFT","DRAFT"),
        ("PENDING","PENDING"),
        ("HOLD","HOLD"),
        ("PAID","PAID"),
        ("CANCELLED","CANCELLED"),
        ("EXPIRED","EXPIRED"),
    ]

    company = models.ForeignKey(Company, on_delete=models.PROTECT)
    guide = models.ForeignKey(User, on_delete=models.PROTECT)

    family = models.ForeignKey(
        'FamilyBooking', on_delete=models.SET_NULL,
        null=True, blank=True, related_name="bookings"
    )

    # внешние справочники (снэпшоты)
    excursion_id = models.IntegerField()
    excursion_title = models.CharField(max_length=255, blank=True)

    hotel_id = models.IntegerField(null=True, blank=True)
    hotel_name = models.CharField(max_length=255, blank=True)
    region_name = models.CharField(max_length=120, blank=True)  # заполним автоматически в save()

    pickup_point_id = models.IntegerField(null=True, blank=True)
    pickup_point_name = models.CharField(max_length=255, blank=True)
    pickup_time_str = models.CharField(max_length=16, blank=True)

    # география точки сбора (снапшот)
    pickup_lat = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
    pickup_lng = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
    pickup_address = models.CharField(max_length=255, blank=True)

    # состав группы (CSV-idшники под SQLite)
    travelers_csv = models.TextField(blank=True)  # "12,15,33"
    travelers_names = models.TextField(blank=True, null=True, help_text="Снапшот ФИО через \\n")

    # статус
    status = models.CharField(max_length=10, choices=STATUS, default="DRAFT", db_index=True)

    # батч-отправка
    batch_code = models.CharField(max_length=20, blank=True)
    sent_at = models.DateTimeField(null=True, blank=True)
    sent_to_email = models.EmailField(blank=True)

    # язык экскурсии, выбранный туристом
    excursion_language = models.CharField(max_length=5, choices=LANG_CHOICES, blank=True)

    # номер комнаты
    room_number = models.CharField(max_length=20, blank=True)

    # источник цены + пер-голова
    price_source = models.CharField(max_length=10, choices=PRICE_SOURCE, default="PICKUP")
    price_per_adult = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    price_per_child = models.DecimalField(max_digits=10, decimal_places=2, default=0)

    # состав и суммы
    date = models.DateField()
    adults = models.PositiveIntegerField(default=1)
    children = models.PositiveIntegerField(default=0)
    infants = models.PositiveIntegerField(default=0)

    gross_total = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    net_total = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    commission = models.DecimalField(max_digits=10, decimal_places=2, default=0)

    # аннуляции
    cancelled_at = models.DateTimeField(null=True, blank=True)
    cancel_reason = models.TextField(null=True, blank=True, default='')

    # прочее
    payment_method = models.CharField(max_length=30, blank=True)
    booking_code = models.CharField(max_length=20, unique=True)

    created_at = models.DateTimeField(auto_now_add=True)

    def set_travelers_names_from_ids(self):
        ids_raw = (self.travelers_csv or "").strip()
        if not ids_raw:
            self.travelers_names = None
            return
        from .models import Traveler
        ids = [int(x) for x in ids_raw.replace(";", ",").split(",") if x.strip().isdigit()]
        names = []
        for t in Traveler.objects.filter(id__in=ids).order_by("id"):
            names.append(f"{t.first_name} {t.last_name}".strip())
        self.travelers_names = "\n".join(filter(None, names))

    @property
    def travelers_names_list(self):
        if not self.travelers_names:
            return []
        return [x.strip() for x in self.travelers_names.splitlines() if x.strip()]
    
    # ---------- УТИЛИТЫ -------------------------------------------------------
    def maps_url(self):
        if self.pickup_lat and self.pickup_lng:
            return f"https://maps.google.com/?q={self.pickup_lat},{self.pickup_lng}"
        if self.pickup_point_name:
            from urllib.parse import quote_plus
            return "https://maps.google.com/?q=" + quote_plus(self.pickup_point_name)
        return ""

    # ---------- ИСТОЧНИКИ РЕГИОНА ---------------------------------------------
    def _resolve_region_from_family(self):
        fam = getattr(self, "family", None)
        reg = (getattr(fam, "region_name", "") or "").strip() if fam else ""
        return reg or None

    def _resolve_region_from_service(self):
        """Пробуем локальную обёртку sales.services.costasolinfo (без прямого HTTP)."""
        try:
            from sales.services import costasolinfo as csi
        except Exception:
            return None

        hotel_id = getattr(self, "hotel_id", None)
        hotel_name = (getattr(self, "hotel_name", "") or "").strip()

        # по id
        if hotel_id:
            try:
                if hasattr(csi, "hotel_by_id"):
                    data = csi.hotel_by_id(int(hotel_id)) or {}
                    reg = (data.get("region") or data.get("region_slug") or "").strip()
                    if reg:
                        return reg
                if hasattr(csi, "region_for_hotel_id"):
                    reg = (csi.region_for_hotel_id(int(hotel_id)) or "").strip()
                    if reg:
                        return reg
            except Exception as e:
                log.debug("CSI service by id failed: %s", e)

        # по имени
        if hotel_name and hasattr(csi, "region_for_hotel"):
            try:
                reg = (csi.region_for_hotel(hotel_name) or "").strip()
                if reg:
                    return reg
            except Exception as e:
                log.debug("CSI service by name failed: %s", e)

        return None

    def _resolve_region_from_api(self):
        """Прямой HTTP к CostaSolinfo по hotel_id (если CSI_API_BASE задан)."""
        hotel_id = getattr(self, "hotel_id", None)
        if not hotel_id:
            return None
        try:
            from django.conf import settings
            import requests
        except Exception:
            return None

        base = getattr(settings, "CSI_API_BASE", None) or getattr(settings, "CSI", {}).get("BASE")
        if not base:
            return None

        timeout = getattr(settings, "CSI_HTTP_TIMEOUT", 6.0)
        token = getattr(settings, "CSI", {}).get("TOKEN", "") if hasattr(settings, "CSI") else ""
        try:
            r = requests.get(
                f"{str(base).rstrip('/')}/api/hotels/{int(hotel_id)}/",
                headers={"Authorization": f"Bearer {token}"} if token else {},
                timeout=timeout,
            )
            if r.status_code != 200:
                return None
            data = r.json() or {}
            reg = (data.get("region") or data.get("region_slug") or "").strip()
            return reg or None
        except Exception:
            return None

    def _resolve_region_from_text(self):
        """
        Безвебовый фолбэк: пробуем распознать регион по тексту
        pickup_point_name/hotel_name. Работает офлайн.
        """
        raw = " ".join([
            (self.pickup_point_name or ""),
            (self.hotel_name or "")
        ]).lower()

        # быстрые метки
        if " cds" in " " + raw or raw.startswith("cds") or "costa del sol" in raw:
            return "CDS"
        if "marbella" in raw:
            return "Marbella"
        if "estepona" in raw:
            return "Estepona"
        if "malaga" in raw or "málaga" in raw:
            return "Malaga"

        # часто в названии pickup-а уже есть суффикс типа "Riu CDS"
        if " cds" in raw or "cds " in raw:
            return "CDS"

        return None

    def ensure_region_name(self):
        """
        Цепочка: Family → локальный сервис → прямой API → текстовый фолбэк.
        """
        current = (self.region_name or "").strip()
        if current:
            return current

        reg = (
            self._resolve_region_from_family()
            or self._resolve_region_from_service()
            or self._resolve_region_from_api()
            or self._resolve_region_from_text()
        )
        if reg:
            self.region_name = reg
            return reg

        log.warning(
            "Region unresolved for booking %s (family_id=%s, hotel_id=%s, hotel_name=%r, pickup=%r)",
            getattr(self, "booking_code", "?"),
            getattr(self, "family_id", None),
            getattr(self, "hotel_id", None),
            self.hotel_name, self.pickup_point_name
        )
        return None

    # ---------- СИСТЕМНАЯ ЛОГИКА ---------------------------------------------
    def save(self, *args, **kwargs):
        self.ensure_region_name()  # гарантируем автозаполнение
        super().save(*args, **kwargs)

    class Meta:
        indexes = [
            models.Index(fields=["company", "date"]),
            models.Index(fields=["excursion_id", "date"]),
            models.Index(fields=["excursion_language"]),
            models.Index(fields=["status"]),
        ]

    def __str__(self): 
        return f"{self.booking_code} / {self.company}"


# ───── Входящие письма (опционально, остаётся) ───────────────────────────────
class InboundEmail(models.Model):
    uid = models.CharField(max_length=64, unique=True)  # IMAP UID сообщения
    message_id = models.CharField(max_length=255, blank=True, null=True)
    subject = models.CharField(max_length=512, blank=True, null=True)
    from_email = models.CharField(max_length=255, blank=True, null=True)
    to_email = models.CharField(max_length=255, blank=True, null=True)
    date = models.DateTimeField(blank=True, null=True)

    snippet = models.TextField(blank=True, null=True)
    body_text = models.TextField(blank=True, null=True)
    body_html = models.TextField(blank=True, null=True)

    raw_headers = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    booking = models.ForeignKey("BookingSale", null=True, blank=True, on_delete=models.SET_NULL)

    class Meta:
        ordering = ["-date", "-id"]

    def __str__(self):
        return f"{self.subject or '(без темы)'} — {self.from_email}"

# ───── ПРОКСИ-модель для админки «Аннулированные брони» ──────────────────────
class CancelledBookingSale(BookingSale):
    class Meta:
        proxy = True
        verbose_name = "Cancelled booking"
        verbose_name_plural = "Cancelled bookings"

```


---

## `backend/sales/admin.py`

```py
# backend/sales/admin.py
import io
from datetime import date, datetime, date as date_cls, time as time_cls
from django.db import transaction, models
from django.db.models import Q
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation
from django.contrib import admin, messages
from django.template.response import TemplateResponse
from django.urls import path
from django.shortcuts import redirect
from django.utils import timezone
from django.utils.html import format_html
from django.utils.text import Truncator
from django.core.management import call_command
from django.http import HttpResponse
import xlsxwriter
import logging
import openpyxl
from openpyxl import Workbook
from openpyxl.utils import get_column_letter

from .models import (
    Company, GuideProfile, BookingSale, FamilyBooking, Traveler,
    InboundEmail, CancelledBookingSale, ExcursionNetPrice
)
from .services.netto import resolve_net_prices
from .services import costasolinfo as csi
from .forms import TouristsImportForm
from .importers import tourists_excel

log = logging.getLogger(__name__)



# ── общий рендер бейджа статуса ───────────────────────────────────────────────
def render_status_badge(status: str):
    s = (status or "").lower()
    label = {
        "draft": "DRAFT",
        "pending": "Отправлено",
        "hold": "HOLD",
        "paid": "PAID",
        "cancelled": "Отменено",
        "expired": "EXPIRED",
    }.get(s, status)
    return format_html('<span class="sp-badge sp-{}">{}</span>', s, label)

# ------- фильтр «Скрыть отменённые» ------------------------------------------
class HideCancelledFilter(admin.SimpleListFilter):
    title = "Скрыть отменённые"
    parameter_name = "hide_cancelled"

    def lookups(self, request, model_admin):
        # По умолчанию скрываем, поэтому две опции:
        return (
            ("1", "Скрыть отменённые"),   # дефолт
            ("0", "Показывать все"),
        )

    def queryset(self, request, queryset):
        val = self.value()
        if val in (None, "", "1"):
            return queryset.exclude(status="CANCELLED")
        return queryset


# ───────────────────────────────────────────────────────────────────────────────
# InboundEmail
@admin.action(description="Проверить входящие Gmail сейчас")
def fetch_gmail_now(modeladmin, request, queryset):
    call_command("fetch_gmail")
    modeladmin.message_user(request, "Готово: входящие обновлены.")

@admin.register(InboundEmail)
class InboundEmailAdmin(admin.ModelAdmin):
    list_display = ("subject", "from_email", "date", "created_at")
    search_fields = ("subject", "from_email", "to_email", "snippet", "body_text")
    readonly_fields = ("uid", "message_id", "raw_headers", "created_at", "html_preview")
    actions = [fetch_gmail_now]

    def html_preview(self, obj):
        return format_html('<div style="border:1px solid #eee;padding:8px;">{}</div>', obj.body_html or "—")
    html_preview.short_description = "HTML"


# ------- вспомогалки ---------------------------------------------------------
def _status_badge(status: str) -> str:
    s = (status or "").upper()
    cls = {
        "DRAFT":     "badge badge-info",
        "PENDING":   "badge badge-warning",
        "HOLD":      "badge",
        "PAID":      "badge badge-success",
        "CONFIRMED": "badge badge-success",
        "CANCELLED": "badge badge-muted",
        "EXPIRED":   "badge badge-muted",
    }.get(s, "badge")
    return format_html('<span class="{}">{}</span>', cls, s)


def _resolve_net_for_booking(b: BookingSale):
    """
    Возвращает (currency, net_adult:Decimal, net_child:Decimal).
    Пытается использовать sales.services.netto.resolve_net_prices,
    иначе — безопасный фолбэк EUR/0/0.
    """
    try:
        if resolve_net_prices:
            reg = (getattr(b, "region_name", "") or "").strip().lower() or None
            res = resolve_net_prices(
                company_id=getattr(b.company, "id", None),
                excursion_id=int(getattr(b, "excursion_id", 0) or 0),
                region_slug=reg,
                date=getattr(b, "date", None),
            )
            if res:
                from decimal import Decimal
                return (
                    res.get("currency") or "EUR",
                    Decimal(res.get("net_adult") or 0),
                    Decimal(res.get("net_child") or 0),
                )
    except Exception:
        pass
    from decimal import Decimal
    return "EUR", Decimal("0"), Decimal("0")

@admin.action(description="Backfill region_name для выбранных продаж")
def backfill_region_name(modeladmin, request, queryset):
    fixed = 0
    for obj in queryset:
        before = (obj.region_name or "").strip()
        obj.ensure_region_name()  # метод модели
        after = (obj.region_name or "").strip()
        if after and after != before:
            obj.save(update_fields=["region_name"])
            fixed += 1
    modeladmin.message_user(request, f"Обновлено записей: {fixed}")

# ------- BookingSale (основной список продаж) --------------------------------
@admin.register(BookingSale)
class BookingSaleAdmin(admin.ModelAdmin):
    list_display = (
        "booking_code", "company", "excursion_title", "date",
        "hotel_name", "pickup_point_name", "pickup_time_str",
        "excursion_language", "room_number",
        "adults", "children", "gross_total", "status_badge",
        "travelers_csv", "travelers_names_readonly",
    )
    list_filter = (HideCancelledFilter, "company", "status", "excursion_language", "date")
    search_fields = (
        "booking_code", "excursion_title", "hotel_name",
        "pickup_point_name", "room_number"
    )
    readonly_fields = ("created_at",)
    actions = ["export_bookings_xlsx", backfill_region_name]

    def travelers_names_readonly(self, obj):
        if not obj or not obj.travelers_names:
            return "-"
        return format_html("<br>".join(obj.travelers_names.splitlines()))
    travelers_names_readonly.short_description = "Travelers"

    # цветной статус
    def status_badge(self, obj):
        return _status_badge(getattr(obj, "status", ""))
    status_badge.short_description = "Status"

    class Media:
        css = {"all": ("sales/admin-status-badges.css",)}

    # Поддержка старого параметра (?cancelled=show) — если он есть, не прячем ничего.
    def get_queryset(self, request):
        qs = super().get_queryset(request)
        if request.GET.get("cancelled") == "show":
            return qs
        return qs  # остальное делает HideCancelledFilter

    # Гарантируем автозаполнение region_name при сохранении из админки
    def save_model(self, request, obj, form, change):
        before = (obj.region_name or "").strip()
        # ensure_region_name() — метод модели BookingSale, который мы добавили
        obj.ensure_region_name()
        super().save_model(request, obj, form, change)
        after = (obj.region_name or "").strip()
        if not after:
            # нужен импорт наверху файла: from django.contrib import messages
            self.message_user(
                request,
                "Регион автоматически определить не удалось. Проверьте Family, настройки CSI или текст пикапа.",
                level=messages.WARNING
            )
        elif after != before:
            self.message_user(request, f"Регион определён: {after}", level=messages.INFO)

    # -------- Excel экспорт ---------------------------------------------------
    def export_bookings_xlsx(self, request, queryset):
        from datetime import datetime, date as date_cls, time as time_cls
        from decimal import Decimal
        from django.utils import timezone
        from django.http import HttpResponse  # локально, чтобы не зависеть от верхних импортов
        import openpyxl
        from openpyxl.utils import get_column_letter
        from sales.models import ExcursionNetPrice

        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Bookings"

        # ----- helpers -----
        REGION_ALIASES = {
            "cds": {"cds", "costa del sol", "costa-del-sol", "costa_del_sol", "costa del-sol", "costa-del sol"},
            "malaga": {"malaga", "mlg", "má­laga", "málaga"},
            "marbella": {"marbella", "mrb"},
            "estepona": {"estepona", "est"},
        }

        def slugify_region(raw: str) -> str:
            """
            Нормализует строку региона в известный slug.
            Никаких "родителей"/догадок — только буквальная нормализация.
            """
            s = (raw or "").strip().lower()
            if not s:
                return ""
            # упрощённая очистка
            s = s.replace("_", " ").replace("-", " ").replace(",", " ")
            s = " ".join(s.split())
            # точное попадание по словарю вариантов
            for slug, variants in REGION_ALIASES.items():
                if s in variants:
                    return slug
            # простые эвристики (в пределах буквального текста)
            if "marbella" in s: return "marbella"
            if "estepona" in s: return "estepona"
            if "malaga"   in s or "málaga" in s: return "malaga"
            if "cds" in s or "costa del sol" in s: return "cds"
            return ""

        def pick_net_row_strict(booking):
            """
            Строгий выбор строки нетто:
            1) exact: company_id + region_slug
            2) fallback: company IS NULL + region_slug
            Больше НИЧЕГО. Если region_slug пуст — цены не подставляем.
            """
            ex_id = int(getattr(booking, "excursion_id", 0) or 0)
            region_slug = slugify_region(getattr(booking, "region_name", ""))
            if not ex_id or not region_slug:
                return None, region_slug  # пустой регион => нет подстановки

            base = ExcursionNetPrice.objects.filter(
                excursion_id=ex_id,
                is_active=True,
                region_slug__iexact=region_slug,
            )

            company_id = getattr(booking, "company_id", None)

            # 1) company override
            if company_id:
                row = base.filter(company_id=company_id).order_by("-updated_at", "-id").first()
                if row:
                    return row, region_slug

            # 2) general (company is NULL)
            row = base.filter(company__isnull=True).order_by("-updated_at", "-id").first()
            return row, region_slug

        def net_child(row) -> Decimal:
            if not row:
                return Decimal("0")
            # если задана детская — берём её, иначе считаем скидкой от взрослой
            try:
                if row.net_per_child not in (None, ""):
                    return Decimal(str(row.net_per_child))
                disc = Decimal(str(row.child_discount_pct or 0)) / Decimal("100")
                base = Decimal(str(row.net_per_adult or 0))
                return (base * (Decimal("1") - disc)).quantize(Decimal("0.01"))
            except Exception:
                return Decimal("0")

        def _cell(v):
            # Excel не любит tz-aware
            if isinstance(v, datetime):
                if timezone.is_aware(v):
                    v = timezone.make_naive(timezone.localtime(v))
                return v
            if isinstance(v, (date_cls, time_cls)):
                return v
            if isinstance(v, Decimal):
                return float(v)
            return v

        # ----- columns -----
        cols = [
            ("Booking code", "booking_code"),
            ("Company",     lambda o: o.company.name if o.company_id else ""),
            ("Date",        "date"),
            ("Excursion",   "excursion_title"),
            ("Hotel",       "hotel_name"),
            ("Pickup name", "pickup_point_name"),
            ("Pickup time", "pickup_time_str"),
            ("Adults",      "adults"),
            ("Children",    "children"),
            ("Gross",       "gross_total"),
            ("Language",    "excursion_language"),
            ("Room",        "room_number"),
            ("Created at",  "created_at"),
            # ↓ нетто-колонки добавим позже по месту
        ]

        # заголовки
        for i, (title, _) in enumerate(cols + [
            ("Net (adult)", None),
            ("Net (child)", None),
            ("Net total",   None),
            ("Commission",  None),
            ("Matched region", None),  # диагностика: какой slug реально применили
        ], start=1):
            ws.cell(row=1, column=i, value=title)

        # строки
        r = 2
        for obj in queryset:
            c = 1
            for _, getter in cols:
                val = getter(obj) if callable(getter) else getattr(obj, getter, "")
                ws.cell(row=r, column=c, value=_cell(val))
                c += 1

            # расчёт нетто/комиссии — строго по (excursion, company, region)
            row, used_region = pick_net_row_strict(obj)
            if row:
                try:
                    net_ad = Decimal(str(row.net_per_adult or 0))
                except Exception:
                    net_ad = Decimal("0")
                net_ch = net_child(row)
                ad = int(obj.adults or 0)
                ch = int(obj.children or 0)
                net_total = (net_ad * Decimal(ad)) + (net_ch * Decimal(ch))
                commission = (Decimal(str(obj.gross_total or 0)) - net_total)
                matched_region = used_region or "(none)"
            else:
                net_ad = net_ch = net_total = commission = Decimal("0")
                matched_region = (used_region or "(none)") + " (strict-miss)"

            ws.cell(row=r, column=c,   value=_cell(net_ad));       c += 1
            ws.cell(row=r, column=c,   value=_cell(net_ch));       c += 1
            ws.cell(row=r, column=c,   value=_cell(net_total));    c += 1
            ws.cell(row=r, column=c,   value=_cell(commission));   c += 1
            ws.cell(row=r, column=c,   value=matched_region);      c += 1  # диагностика

            r += 1

        # ширины
        for i in range(1, 1 +  len(cols) + 5):
            ws.column_dimensions[get_column_letter(i)].width = 18

        resp = HttpResponse(
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        resp["Content-Disposition"] = 'attachment; filename="bookings_with_net.xlsx"'
        wb.save(resp)
        return resp


# ───────────────────────────────────────────────────────────────────────────────
# Прокси-админ: только отменённые
@admin.register(CancelledBookingSale)
class CancelledBookingSaleAdmin(BookingSaleAdmin):
    # свой набор фильтров — БЕЗ HideCancelledFilter и, по желанию, без status
    list_filter = ("company", "excursion_language", "date")

    def get_queryset(self, request):
        # НЕ зовём super(), чтобы не сработала логика «скрывать CANCELLED»
        return self.model.objects.filter(status="CANCELLED")

    def changelist_view(self, request, extra_context=None):
        extra_context = (extra_context or {}) | {"title": "Cancelled bookings"}
        return super().changelist_view(request, extra_context=extra_context)


# ── Inlines для семьи ─────────────────────────────────────────────────────────
class TravelerInline(admin.TabularInline):
    model = Traveler
    extra = 0
    fields = ("last_name", "first_name", "dob", "nationality", "passport", "passport_expiry")
    show_change_link = True

class BookingSaleInline(admin.TabularInline):
    model = BookingSale
    extra = 0
    can_delete = False
    show_change_link = True

    fields = (
    "booking_code", "date",
    "excursion_title", "excursion_language",
    "adults", "children", "infants",
    "pickup_point_name", "pickup_time_str",
    "gross_total", "status_badge",
    )
    readonly_fields = fields  # показываем как read-only, редактирование в самой брони

    def status_badge(self, obj):
        return render_status_badge(getattr(obj, "status", ""))
    status_badge.short_description = "Status"

    class Media:
        css = {"all": ("sales/admin-status-badges.css",)}

# ── FamilyBooking ──────────────────────────────────────────────────────────────
@admin.register(FamilyBooking)
class FamilyBookingAdmin(admin.ModelAdmin):
    list_display = ("ref_code", "hotel_name", "arrival_date", "departure_date", "people", "created_at")
    search_fields = ("ref_code", "hotel_name", "region_name", "phone", "email",
                     "travelers__last_name", "travelers__first_name")
    list_filter = ("arrival_date", "region_name")
    inlines = [TravelerInline, BookingSaleInline]

    change_list_template = "admin/sales/familybooking/change_list.html"

    # чтобы список работал без N+1
    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.prefetch_related("travelers", "bookings")

    def people(self, obj):
        # короткий список имён для списка семей
        names = ["{} {}".format(t.last_name or "", t.first_name or "").strip()
                 for t in obj.travelers.all()]
        text = ", ".join(filter(None, names)) or "—"
        return Truncator(text).chars(60)
    people.short_description = "Состав семьи"

    # импорт как у вас было
    def get_urls(self):
        urls = super().get_urls()
        custom = [
            path(
                "import/",
                self.admin_site.admin_view(self.import_view),
                name="sales_familybooking_import",
            ),
        ]
        return custom + urls

    def import_view(self, request):
        if not self.has_add_permission(request):
            messages.error(request, "Недостаточно прав для импорта.")
            return redirect("admin:sales_familybooking_changelist")

        context = dict(self.admin_site.each_context(request), title="Импорт туристов")

        if request.method == "POST":
            form = TouristsImportForm(request.POST, request.FILES)
            if form.is_valid():
                up_file = form.cleaned_data.get("file")
                dry = bool(form.cleaned_data.get("dry_run", False))
                try:
                    result = tourists_excel.import_file(up_file, dry_run=dry)
                    families = result.get("families_created", 0)
                    travelers = result.get("travelers_created", 0)
                    skipped = result.get("skipped", 0)
                    msg = f"Семей: {families}, туристов: {travelers}, пропущено: {skipped}."
                    messages.success(
                        request,
                        ("Проверка прошла успешно. " if dry else "Импорт завершён. ") + msg
                    )
                    return redirect("admin:sales_familybooking_changelist")
                except Exception as e:
                    log.exception("Ошибка при импорте туристов")
                    messages.error(request, f"Ошибка импорта: {e}")
            else:
                messages.error(request, f"Проверьте форму: {form.errors.as_text()}")
        else:
            form = TouristsImportForm()

        context["form"] = form
        return TemplateResponse(request, "admin/sales/familybooking/import_form.html", context)


# ───────────────────────────────────────────────────────────────────────────────
# Traveler
@admin.register(Traveler)
class TravelerAdmin(admin.ModelAdmin):
    list_display = (
        "last_name", "first_name", "dob", "nationality", "passport",
        "passport_expiry", "gender", "doc_type", "doc_expiry", "family"
    )
    list_filter = ("gender", "doc_type", "nationality", "family")
    search_fields = ("last_name", "first_name", "passport", "email", "phone")


# ───────────────────────────────────────────────────────────────────────────────
# Прочие справочники
@admin.register(Company)
class CompanyAdmin(admin.ModelAdmin):
    list_display = ("name", "slug", "email_for_orders", "is_active")
    search_fields = ("name", "slug", "email_for_orders")
    list_filter = ("is_active",)

@admin.register(GuideProfile)
class GuideProfileAdmin(admin.ModelAdmin):
    list_display = ("user",)
    search_fields = ("user__username", "user__email")


# ───────────────────────────────────────────────────────────────────────────────
# Цены НЕТТО по экскурсиям
@admin.register(ExcursionNetPrice)
class ExcursionNetPriceAdmin(admin.ModelAdmin):
    change_list_template = "admin/sales/excursionnetprice/change_list.html"
    list_display = ("excursion_with_title", "company", "region_slug",
                    "currency", "net_per_adult", "net_per_child",
                    "child_discount_pct", "is_active", "updated_at")
    list_filter = ("company", "region_slug", "is_active", "currency")
    search_fields = ("region_slug",)

    def excursion_with_title(self, obj):
        title = csi.excursion_title(int(obj.excursion_id or 0), lang="ru") or ""
        return f"ex#{obj.excursion_id} — {title}"
    excursion_with_title.short_description = "Excursion"

    # добавим ссылку на «Матрицу»
    def get_urls(self):
        urls = super().get_urls()
        custom = [
            path("matrix/", self.admin_site.admin_view(self.matrix_view), name="sales_netprice_matrix"),
        ]
        return custom + urls

    def matrix_view(self, request):
        """
        Страница матрицы: все экскурсии × регионы.
        GET — рендер формы, POST — сохранение.
        """
        # 1) тянем все активные экскурсии из основной базы
        data = csi.list_excursions(lang="ru") or {}
        items = data.get("items") if isinstance(data, dict) else data
        excursions = []
        for it in (items or []):
            excursions.append({
                "id": int(it.get("id")),
                "title": it.get("title") or it.get("localized_title") or "",
                # Если из core у экскурсии есть «цены по регионам», берём список слагов
                "region_slugs": self._regions_for_excursion(int(it.get("id")))
            })

        # 2) справочник уже сохранённых нетто
        rows = ExcursionNetPrice.objects.all()
        saved = {}
        for r in rows:
            saved[(r.excursion_id, (r.region_slug or "").lower(), r.company_id or 0)] = r

        # 3) компании (фильтр по шапке, по желанию)
        companies = list(Company.objects.filter(is_active=True).order_by("name"))
        company_id = request.GET.get("company")
        try:
            company_id = int(company_id) if company_id else None
        except ValueError:
            company_id = None

        if request.method == "POST":
            # ожидаем поля: price-<exc_id>-<region>-adult|child
            # пример name: price-2-cds-adult
            objects_by_key: dict[tuple[int, str, int], ExcursionNetPrice] = {}

            def _parse_decimal(v: str) -> Decimal | None:
                v = (v or "").strip().replace(",", ".")
                if v == "":
                    return None
                try:
                    return Decimal(v)
                except (InvalidOperation, ValueError):
                    return None

            for k, v in request.POST.items():
                if not k.startswith("price-"):
                    continue
                try:
                    _, ex_str, reg, kind = k.split("-", 3)
                    ex_id = int(ex_str)
                except Exception:
                    continue
                reg = (reg or "").lower().strip()
                if kind not in ("adult", "child"):
                    continue

                # ключ уникальности
                comp_id = company_id or 0
                key = (ex_id, reg, comp_id)

                # берём существующую запись либо создаём новую (в памяти)
                obj = objects_by_key.get(key)
                if not obj:
                    obj = saved.get(key)
                    if not obj:
                        obj = ExcursionNetPrice(
                            excursion_id=ex_id,
                            region_slug=reg,
                            company_id=company_id,   # может быть None
                            currency="EUR",
                            is_active=True,
                        )
                    objects_by_key[key] = obj

                val = _parse_decimal(v)
                if kind == "adult":
                    obj.net_per_adult = val
                else:
                    obj.net_per_child = val

            # сохраняем всё одним проходом
            with transaction.atomic():
                for obj in objects_by_key.values():
                    obj.save()

            self.message_user(request, "Нетто-цены сохранены.")
            return redirect("admin:sales_netprice_matrix")


        context = dict(
            self.admin_site.each_context(request),
            title="Матрица нетто-цен",
            excursions=excursions,
            companies=companies,
            sel_company=company_id,
            saved=saved,
        )
        return TemplateResponse(request, "admin/sales/net_prices_matrix.html", context)

    def _regions_for_excursion(self, excursion_id: int) -> list[str]:
        """Пробуем вытащить список регионов из детальной инфы экскурсии.
        Если нет — вернём базовый набор."""
        detail = csi.excursion_detail(excursion_id) or {}
        regions = set()
        for key in ("prices_by_region", "pricesByRegion", "region_prices", "prices", "tariffs"):
            arr = detail.get(key) or []
            if isinstance(arr, list):
                for row in arr:
                    r = (row.get("region") or {})
                    slug = (r.get("slug") or r.get("code") or "").lower()
                    if slug:
                        regions.add(slug)
        # бэкап-набор, если источник молчит:
        if not regions:
            regions = {"cds", "malaga", "marbella", "estepona"}
        return sorted(regions)
```


---

## `backend/sales/urls.py`

```py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views_api as v
from .views_pages import tourists_import_page
from .views_api import (
    CompanyViewSet,
    FamilyBookingDraftsView,
    BookingBatchPreviewView,
    BookingBatchSendView,
    BookingCreateView,
    FamilyDetailView,
    TravelerPartialUpdateView,
)

router = DefaultRouter()
router.register(r"companies", v.CompanyViewSet, basename="company")

app_name = "sales"

urlpatterns = [
    # Health
    path("health/", v.health, name="health"),

    # CSRF + Login (оба нужны фронту)
    path("csrf/", v.csrf_view, name="csrf"),           # GET → csrftoken
    path("login/", v.login_view, name="login"),        # POST → sessionid

    # HTML-страницы
    path("import/tourists/", tourists_import_page, name="tourists_import_page"),

    # Публичные API
    path("hotels/", v.hotels, name="hotels"),
    path("tourists/", v.tourists, name="tourists"),
    path("families/<int:fam_id>/", v.family_detail, name="family_detail"),
    path("families/<int:pk>/", FamilyDetailView.as_view(), name="family-detail"),
    path("excursions/", v.excursions, name="excursions"),
    path("travelers/<int:pk>/", TravelerPartialUpdateView.as_view(), name="traveler-partial"),

    # Пикапы
    path("pickups/v2/", v.SalesExcursionPickupsView.as_view(), name="pickups_v2"),
    path("pickups/", v.pickups, name="pickups"),

    # Калькуляция цены
    path("pricing/quote/", v.pricing_quote_view, name="pricing_quote"),

    # Отладка
    path("debug/csi-base/", v.debug_csi_base, name="debug_csi_base"),
    path("debug/pricing-sig/", v.debug_pricing_signature, name="debug_pricing_sig") if False else
    path("debug/pricing-sig/", v.pricing_debug_signature, name="debug_pricing_sig"),
    path("debug/hotel-region/", v.debug_hotel_region, name="debug_hotel_region"),
    path("debug/excursion-prices/", v.debug_excursion_prices, name="debug_excursion_prices"),
    path("debug/raw/hotel/", v.debug_raw_hotel, name="debug_raw_hotel"),
    path("debug/raw/excursion/", v.debug_raw_excursion, name="debug_raw_excursion"),

    # DRF router (companies)
    path("", include(router.urls)),

    # Бронирования (боевые)
    path("bookings/create/", v.BookingCreateView.as_view(), name="booking-create"),
    path("bookings/", v.BookingListView.as_view(), name="booking-list"),
    path("bookings/family/<int:fam_id>/drafts/", v.FamilyBookingDraftsView.as_view(), name="family-drafts"),
    path("bookings/batch/preview/", v.BookingBatchPreviewView.as_view(), name="bookings-batch-preview"),
    path("bookings/batch/send/", v.BookingBatchSendView.as_view(), name="bookings-batch-send"),
    path("bookings/<int:pk>/ticket.pdf", v.booking_ticket_pdf, name="booking-ticket-pdf"),

    # Бронирования — работа с отдельной бронью
    path("bookings/<int:pk>/", v.BookingDetailView.as_view(), name="booking-detail"),
    path("bookings/<int:pk>/cancel/", v.BookingCancelView.as_view(), name="booking-cancel"),
    path("bookings/batch/cancel/", v.BookingBatchCancelView.as_view(), name="bookings-batch-cancel"),
]

```


---

## `backend/sales/views_api.py`

```py
# backend/sales/views_api.py
# --- TEMP PATCH: pydyf PDF ctor mismatch (WeasyPrint 61.x expects args) ---
import re, html

def pick_title_en(title: str, max_words: int = 3) -> str:
    if not title:
        return ""
    # 1) сперва ищем английский сегмент после разделителей
    parts = re.split(r"\s*[\/\|\-–—]\s*", title)
    for part in parts:
        words = re.findall(r"[A-Za-z][A-Za-z'’\-]*", part)
        if words:
            return " ".join(words[:max_words])
    # 2) иначе любые английские слова из всей строки
    words = re.findall(r"[A-Za-z][A-Za-z'’\-]*", title)
    if words:
        return " ".join(words[:max_words])
    # 3) фолбэк — первое слово исходного названия
    return (title.strip().split() or [""])[0]

import inspect
import pydyf

if len(inspect.signature(pydyf.PDF.__init__).parameters) == 1:  # только (self)
    _orig_init = pydyf.PDF.__init__

    def _patched_init(self, version='1.7', identifier=None, *args, **kwargs):
        # старый pydyf не ждет аргументы -> просто вызываем оригинал
        _orig_init(self)
        # WeasyPrint ожидает, что у PDF есть .version (bytes) и .identifier
        try:
            self.version = (
                version if isinstance(version, (bytes, bytearray))
                else str(version).encode('ascii')
            )
        except Exception:
            self.version = b'1.7'
        self.identifier = identifier

    pydyf.PDF.__init__ = _patched_init
# --- END TEMP PATCH ---

from urllib.parse import quote_plus
from PIL import Image
from pathlib import Path
from collections import defaultdict
from datetime import date
from decimal import Decimal
from weasyprint import HTML
from io import BytesIO
import io
import base64, os
import qrcode
import datetime as dt
from django.utils import timezone
from django.db import transaction
from rest_framework.parsers import JSONParser
from sales.services.emails import send_booking_email

from sales.services.emails import send_cancellation_email
from sales.services.titles import spanish_excursion_name, compose_bilingual_title

from django.db.models import Q
from django.core.exceptions import FieldError   # ← ДОБАВИТЬ
from django.conf import settings
from django.contrib.auth import get_user_model, authenticate, login as auth_login
from django.shortcuts import render, get_object_or_404
from django.template.loader import render_to_string
from django.templatetags.static import static
from django.http import JsonResponse, HttpResponse
from django.views.decorators.http import require_GET, require_POST
from django.views.decorators.csrf import csrf_exempt, ensure_csrf_cookie, csrf_protect
from django.middleware.csrf import get_token
from django.utils.dateparse import parse_date
from django.utils.decorators import method_decorator
from django.views.decorators.cache import never_cache
from sales.services.costasolinfo import NotFoundError
from .services import costasolinfo as csi
from .services.costasolinfo import get_client, pricing_quote
from rest_framework.authentication import SessionAuthentication

from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.decorators import api_view, permission_classes, authentication_classes
from rest_framework.generics import RetrieveAPIView
from rest_framework.views import APIView
from rest_framework import status, viewsets
from .models import FamilyBooking, Traveler, Company, BookingSale
from django.apps import apps
from .serializers import (
    CompanySerializer,
    BookingSaleCreateSerializer,
    BookingSaleListSerializer,
    TravelerMiniSerializer,      # понадобится, если решишь оставить FBV
    FamilyDetailSerializer,
    BookingSaleDetailSerializer,      # для CBV
)

import requests
import logging
import inspect
import json

WEEKDAYS = ["mon","tue","wed","thu","fri","sat","sun"]

FamilyBooking = apps.get_model('sales', 'FamilyBooking')

logo_path = os.path.join(settings.BASE_DIR, "sales", "static", "sales", "logo.png")
logo_b64 = ""
if os.path.exists(logo_path):
    with open(logo_path, "rb") as f:
        logo_b64 = base64.b64encode(f.read()).decode("utf-8")



@api_view(["GET"])
@permission_classes([AllowAny])
def booking_ticket_pdf(request, pk: int):
    from .models import BookingSale, Traveler

    # --- утилита для английского короткого названия ---
    def pick_title_en(title: str, max_words: int = 3) -> str:
        if not title:
            return ""
        # сначала пытаемся вытащить англ. сегмент после разделителей
        parts = re.split(r"\s*[\/\|\-–—]\s*", title)
        for part in parts:
            words = re.findall(r"[A-Za-z][A-Za-z'’\-]*", part)
            if words:
                return " ".join(words[:max_words])
        # затем любые англ. слова из всей строки
        words = re.findall(r"[A-Za-z][A-Za-z'’\-]*", title)
        if words:
            return " ".join(words[:max_words])
        # фолбэк — первое слово целиком
        return (title.strip().split() or [""])[0]

    b = get_object_or_404(BookingSale, pk=pk)

    # 1) Дата EN
    d = getattr(b, "date", None) or localdate()
    try:
        date_en = d.strftime("%-d %B %Y")   # macOS/Linux
    except Exception:
        date_en = d.strftime("%d %B %Y")    # Windows fallback

    # 2) Гости
    travelers = []
    if getattr(b, "travelers_names", None):
        travelers = [x.strip() for x in b.travelers_names.splitlines() if x.strip()]
    if not travelers:
        ids_raw = (getattr(b, "travelers_csv", "") or "").strip()
        if ids_raw:
            try:
                ids = [int(x) for x in ids_raw.replace(";", ",").split(",") if x.strip().isdigit()]
                qs = Traveler.objects.filter(id__in=ids).order_by("id")
                travelers = [f"{t.first_name} {t.last_name}".strip() for t in qs]
            except Exception:
                travelers = []

    # 3) Два QR
    # 3a) сайт
    qr_site_url = f"https://www.costasolinfo.com/?ref={b.booking_code}"
    # 3b) карта точки (координаты приоритетны)
    lat = getattr(b, "pickup_lat", None)
    lng = getattr(b, "pickup_lng", None)
    if lat and lng:
        maps_query = f"{lat},{lng}"
    else:
        parts = [getattr(b, "pickup_point_name", ""), getattr(b, "hotel_name", ""), "Costa del Sol"]
        maps_query = " ".join(p for p in parts if p)
    qr_maps_url = f"https://www.google.com/maps/search/?api=1&query={quote_plus(maps_query)}"

    def make_qr_data_uri(url: str, size=(100, 100)) -> str:
        img = qrcode.make(url)              # PIL.Image
        if size:
            img = img.resize(size, Image.NEAREST)
        buf = io.BytesIO()
        img.save(buf, format="PNG")
        return "data:image/png;base64," + base64.b64encode(buf.getvalue()).decode("utf-8")

    qr_site = make_qr_data_uri(qr_site_url)
    qr_maps = make_qr_data_uri(qr_maps_url)

    # 4) Логотип через static (WeasyPrint подтянет благодаря base_url)
    logo_url = request.build_absolute_uri(static("sales/logo.png"))

    # 5) Английское короткое название (ВАЖНО: посчитать ДО ctx)
    title_en = pick_title_en(getattr(b, "excursion_title", ""), max_words=3)

    # 6) Рендер
    ctx = {
        "b": b,
        "date_en": date_en,
        "travelers": travelers,
        "logo_url": logo_url,
        "qr_site": qr_site,
        "qr_maps": qr_maps,
        "qr_site_url": qr_site_url,
        "qr_maps_url": qr_maps_url,
        "title_en": title_en,
    }
    html = render_to_string("sales/ticket.html", ctx)
    pdf = HTML(string=html, base_url=request.build_absolute_uri("/")).write_pdf()

    resp = HttpResponse(pdf, content_type="application/pdf")
    resp["Content-Disposition"] = f'inline; filename="ticket_{b.booking_code}.pdf"'
    return resp

def encode_logo_b64(max_w=400, max_h=120):
    path = Path(settings.BASE_DIR) / "sales" / "static" / "sales" / "logo.png"
    if not path.exists():
        return ""
    with Image.open(path) as im:
        im = im.convert("RGBA")
        im.thumbnail((max_w, max_h))  # мягкое масштабирование, сохранит пропорции
        buf = io.BytesIO()
        im.save(buf, format="PNG")
        return base64.b64encode(buf.getvalue()).decode("utf-8")

logo_b64 = encode_logo_b64()

@ensure_csrf_cookie
def csrf_view(request):
    """
    GET /api/sales/csrf/
    Отдаёт токен в JSON и ставит csrftoken cookie.
    Работает даже когда CSRF cookie HttpOnly.
    """
    return JsonResponse({'csrftoken': get_token(request), 'detail': 'CSRF cookie set'})

@require_POST
@csrf_protect
@ensure_csrf_cookie
def login_view(request):
    """
    POST /api/sales/login/
    Body: {"username": "...", "password": "..."}
    Успех: ставим sessionid (Set-Cookie) и возвращаем 200 JSON.
    Ошибка: 400/401 с detail.
    """
    try:
        data = json.loads(request.body.decode('utf-8') or "{}")
    except Exception:
        data = {}
    username = (data.get('username') or '').strip()
    password = data.get('password') or ''

    if not username or not password:
        return JsonResponse({'detail': 'Username/password required'}, status=400)

    user = authenticate(request, username=username, password=password)
    if user is None:
        return JsonResponse({'detail': 'Invalid credentials'}, status=401)

    # ВАЖНО: именно это создаёт сессию и даёт Set-Cookie: sessionid=...
    auth_login(request, user)

    # опционально: срок жизни сессии (например, 12 часов)
    request.session.set_expiry(12 * 60 * 60)

    return JsonResponse({
        'detail': 'ok',
        'username': user.get_username(),
        'ts': timezone.now().isoformat(),
    }, status=200)

class BookingSaleViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = BookingSale.objects.all()

    def get_serializer_class(self):
        # список -> краткий; деталка -> детальный
        if self.action == "retrieve":
            return BookingSaleDetailSerializer
        return BookingSaleListSerializer

class FamilyDetailView(RetrieveAPIView):
    queryset = FamilyBooking.objects.all()   # без prefetch_related('party')
    serializer_class = FamilyDetailSerializer
    permission_classes = [AllowAny]


def _booking_to_json(b: BookingSale) -> dict:
    return {
        "id": b.id,
        "booking_code": b.booking_code,
        "status": b.status,
        "family_id": getattr(b, "family_id", None),   # ← ДОБАВИЛИ
        "date": b.date.isoformat() if b.date else None,
        "excursion_id": b.excursion_id,
        "excursion_title": b.excursion_title,
        "hotel_id": b.hotel_id,
        "hotel_name": b.hotel_name,
        "region_name": getattr(b, "region_name", "") or "",
        "pickup_point_id": b.pickup_point_id,
        "pickup_point_name": b.pickup_point_name,
        "pickup_time_str": b.pickup_time_str,
        "pickup_lat": getattr(b, "pickup_lat", None),
        "pickup_lng": getattr(b, "pickup_lng", None),
        "pickup_address": getattr(b, "pickup_address", ""),
        "excursion_language": getattr(b, "excursion_language", None),
        "room_number": getattr(b, "room_number", ""),
        "adults": b.adults,
        "children": b.children,
        "infants": b.infants,
        "price_source": getattr(b, "price_source", "PICKUP"),
        "price_per_adult": str(getattr(b, "price_per_adult", 0) or 0),
        "price_per_child": str(getattr(b, "price_per_child", 0) or 0),
        "gross_total": str(b.gross_total or 0),
        "net_total": str(getattr(b, "net_total", 0) or 0),
        "commission": str(getattr(b, "commission", 0) or 0),
        "created_at": b.created_at.isoformat() if b.created_at else None,
        "is_sendable": b.status in ("DRAFT",),
        "is_sent": b.status in ("PENDING", "HOLD", "PAID", "CANCELLED", "EXPIRED"),
    }


def _resolve_user(request):
    """ Dev-fallback: если нет аутентификации — берём первого активного. """
    u = getattr(request, "user", None)
    if u and getattr(u, "is_authenticated", False):
        return u
    User = get_user_model()
    return (
        User.objects.filter(is_active=True)
        .order_by("-is_superuser", "-is_staff", "id")
        .first()
    )

def _normalize_name(s: str) -> str:
    """Убираем лишнее и приводим к нижнему регистру для сравнения."""
    s = (s or "").strip().lower()
    s = re.sub(r"\s+", " ", s)
    return s

def _resolve_hotel_id_by_name(hotel_name: str) -> int | None:
    """
    Ищет hotel_id в CSI по названию отеля.
    Приоритет: точное совпадение → начинается с → первый результат.
    """
    if not hotel_name:
        return None

    try:
        res = csi.search_hotels(hotel_name, limit=10)
        items = res if isinstance(res, list) else (res.get("items") or [])
        if not items:
            return None

        target = _normalize_name(hotel_name)
        # 1) точное совпадение
        for it in items:
            name = _normalize_name(it.get("name") or it.get("title") or "")
            if name == target:
                return int(it.get("id"))

        # 2) начинается с
        for it in items:
            name = _normalize_name(it.get("name") or it.get("title") or "")
            if name.startswith(target) or target.startswith(name):
                return int(it.get("id"))

        # 3) первый адекватный
        for it in items:
            if it.get("id"):
                return int(it["id"])
    except Exception:
        pass
    return None

def _weekday_slug(date_str: str) -> str | None:
    # Делает парсер терпимым: обрезаем мусор, берём только YYYY-MM-DD
    try:
        s = (date_str or "").strip()[:10]
        d = dt.date.fromisoformat(s)
        return WEEKDAYS[d.weekday()]  # 0=mon ... 6=sun
    except Exception:
        return None


@api_view(["GET"])
@permission_classes([AllowAny])
def debug_hotel_region(request):
    """Показывает, какой регион видит CSI для данного hotel_id."""
    hotel_id_raw = request.GET.get("hotel_id")
    try:
        hotel_id = int(hotel_id_raw) if hotel_id_raw else None
    except ValueError:
        return JsonResponse({"detail": "hotel_id must be int"}, status=400)
    if not hotel_id:
        return JsonResponse({"detail": "hotel_id required"}, status=400)

    # импортируем только внутри функции, чтобы не ломать загрузку модуля
    try:
        from .services.costasolinfo import _hotel_region as svc_hotel_region
    except ImportError:
        return JsonResponse({"detail": "helper _hotel_region is not defined in costasolinfo.py"}, status=500)

    region = svc_hotel_region(hotel_id)
    return JsonResponse({"hotel_id": hotel_id, "region": region}, json_dumps_params={"ensure_ascii": False})


@api_view(["GET"])
@permission_classes([AllowAny])
def debug_excursion_prices(request):
    """Возвращает цены экскурсии по региону (adult/child/currency) для пары (excursion_id, region)."""
    try:
        excursion_id = int(request.GET.get("excursion_id"))
    except (TypeError, ValueError):
        return JsonResponse({"detail": "excursion_id required (int)"}, status=400)

    region_id = request.GET.get("region_id")
    region_slug = request.GET.get("region_slug")
    region = None
    if region_id or region_slug:
        try:
            region = {"id": int(region_id)} if region_id else {"id": None}
        except ValueError:
            return JsonResponse({"detail": "region_id must be int"}, status=400)
        if region_slug:
            region["slug"] = region_slug

    try:
        from .services.costasolinfo import _excursion_price_for_region as svc_ex_price_region
    except ImportError:
        return JsonResponse({"detail": "helper _excursion_price_for_region is not defined in costasolinfo.py"}, status=500)

    prices = svc_ex_price_region(excursion_id, region)
    return JsonResponse(
        {"excursion_id": excursion_id, "region": region, "prices": prices},
        json_dumps_params={"ensure_ascii": False},
    )

log = logging.getLogger(__name__)

_TAG_RE = re.compile(r"<[^>]+>")

# def login_view(request): return JsonResponse({"ok": True})

def _csi_url(path: str) -> str:
    """Надёжно склеивает CSI_API_BASE и относительный путь."""
    base = getattr(settings, "CSI_API_BASE", "http://127.0.0.1:8000").rstrip("/")
    if base.endswith("/api"):
        return f"{base}/{path.lstrip('/')}"           # base уже с /api
    return f"{base}/api/{path.lstrip('/')}"           # добавим /api

@csrf_exempt
@api_view(["POST"])
@authentication_classes([])          # отключаем SessionAuthentication => не требует CSRF
@permission_classes([AllowAny])      # в деве позволим всем
def create_booking(request):
    # На этом шаге просто эхо-заглушка, чтобы проверить POST
    data = request.data or {}
    return Response({
        "status": "PENDING",
        "booking_code": "S-000001",
        "echo": data,                # вернём то, что прислали, для наглядности
    })

@api_view(["GET"])
def debug_csi_base(request):
    from django.conf import settings
    return Response({
        "CSI_API_MODE": settings.CSI_API_MODE,
        "CSI_API_BASE": settings.CSI_API_BASE,
        "timeout": settings.CSI_HTTP_TIMEOUT,
        "cache_sec": settings.CSI_CACHE_SECONDS,
    })

@api_view(["GET"])
@permission_classes([AllowAny])
def health(request):
    return Response({"status": "ok"})

def _via_client(query: str, limit: int) -> list:
    from .services import costasolinfo as csi
    data = csi.search_hotels(query, limit=limit)
    return data if isinstance(data, list) else (data.get("items") if isinstance(data, dict) else [])

def _via_proxy(query: str, limit: int) -> list:
    """
    Пробуем REST-эндпоинты источника:
    1) /api/hotels/?search=
    2) /api/available-hotels/?search=
    Возвращаем первый непустой результат.
    """
    for path in ("hotels/", "available-hotels/"):
        r = requests.get(_csi_url(path), params={"search": query, "limit": limit}, timeout=6)
        if r.ok:
            data = r.json()
            items = data if isinstance(data, list) else (data.get("items") if isinstance(data, dict) else [])
            if items:
                return items
    return []

@api_view(["GET"])
@permission_classes([AllowAny])
def hotels(request):
    """
    /api/sales/hotels/?q=best benalmadena   или   ?search=best benalmadena
    Возвращает {items:[...]}.
    Алгоритм: полная строка → последнее слово → первое слово;
    для каждой попытки: сначала через csi-клиент, затем прямой прокси.
    """
    q = (request.query_params.get("q") or request.query_params.get("search") or "").strip()
    if not q:
        return Response({"items": []})

    try:
        limit = int(request.query_params.get("limit", "10"))
    except ValueError:
        limit = 10

    attempts = [q]
    parts = [p for p in re.split(r"[\s,.;-]+", q) if p]
    if len(parts) > 1:
        attempts += [parts[-1], parts[0]]  # сначала «benalmadena», затем «best»

    for query in attempts:
        items = []
        # 1) через клиент
        try:
            items = _via_client(query, limit)
        except Exception:
            items = []
        # 2) фолбэк — прямые REST эндпоинты источника
        if not items:
            try:
                items = _via_proxy(query, limit)
            except Exception:
                items = []

        if items:
            _enrich_hotels(items)       # ← ДОБАВЛЕНО: подмешиваем счётчик
            return Response({"items": items})

    return Response({"items": []})


@api_view(["GET"])
@permission_classes([AllowAny])
def tourists(request):
    """
    /api/sales/tourists/?hotel_name=RIU%20COSTA%20DEL%20SOL&search=ivan
    Также понимает: ?hotel_id=... (зарезервировано), ?q=...
    Возвращает {items:[{ id, last_name, first_name, checkin, checkout, room, party:[...] }]}
    где party — все путешественники (Traveler) в рамках одной FamilyBooking.
    """
    # 1) входные параметры
    hotel_name = (request.query_params.get("hotel_name")
                  or request.query_params.get("hotel")
                  or "").strip()
    _ = request.query_params.get("hotel_id")  # пока не используем
    q = (request.query_params.get("search")
         or request.query_params.get("q")
         or "").strip()

    if not hotel_name:
        return Response({"items": []})

    # 2) модели
    from .models import FamilyBooking, Traveler

    # 3) семейные брони по отелю (без регистрозависимости).
    #    По умолчанию скрываем тех, у кого выезд уже прошёл.
    #    Чтобы показать всех, передай ?include_past=1
    today = timezone.localdate()
    include_past = request.query_params.get("include_past") in ("1", "true", "True")

    fam_qs = FamilyBooking.objects.filter(hotel_name__icontains=hotel_name)
    if not include_past:
        fam_qs = fam_qs.filter(
            Q(departure_date__isnull=True) | Q(departure_date__gte=today)
        )

    fam_ids = list(fam_qs.values_list("id", flat=True))
    if not fam_ids:
        return Response({"items": []})


    # 4) выбираем путешественников этих семей
    trav_qs = Traveler.objects.filter(family_id__in=fam_ids)
    if q:
        trav_qs = trav_qs.filter(Q(last_name__icontains=q) | Q(first_name__icontains=q))

    # Берём только нужные поля и убираем дубликаты на уровне БД
    trav_rows = (
        trav_qs
        .values("id", "last_name", "first_name", "dob", "family_id")
        .order_by("family_id", "last_name", "first_name", "id")
        .distinct()
    )

    if not trav_rows:
        return Response({"items": []})

    # 5) группируем по family_id
    groups = defaultdict(list)
    for r in trav_rows:
        groups[r["family_id"]].append(r)

    fam_map = {
        f.id: f for f in FamilyBooking.objects.filter(id__in=groups.keys())
    }

    def is_child(dob):
        if not dob:
            return False
        try:
            today = date.today()
            age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))
            return age < 12
        except Exception:
            return False

    items = []
    for fam_id, members in groups.items():
        fam = fam_map.get(fam_id)
        head = members[0]  # первый по алфавиту
        party = [{
            "id": m["id"],
            "full_name": f'{m["last_name"]} {m["first_name"]}'.strip(),
            "is_child": is_child(m.get("dob")),
        } for m in members]

        items.append({
            "id": fam_id,  # id семейной брони — ключ карточки
            "last_name": head["last_name"],
            "first_name": head["first_name"],
            "checkin": (fam.arrival_date.isoformat() if getattr(fam, "arrival_date", None) else None),
            "checkout": (fam.departure_date.isoformat() if getattr(fam, "departure_date", None) else None),
            "room": "",  # комнат в модели нет — оставляем пусто
            "party": party,
        })

    # свежие заезды выше
    items.sort(key=lambda x: (x["checkin"] or ""), reverse=True)
    return Response({"items": items})

def _tourists_count_by_hotel_name(name: str) -> int:
    today = timezone.localdate()
    fam_ids = list(
        FamilyBooking.objects
        .filter(hotel_name__icontains=name)
        .filter(Q(departure_date__isnull=True) | Q(departure_date__gte=today))
        .values_list("id", flat=True)
    )
    if not fam_ids:
        return 0
    return (
        Traveler.objects.filter(family_id__in=fam_ids)
        .distinct()
        .count()
    )

def _enrich_hotels(items: list[dict]) -> list[dict]:
    # безопасно добавляем поле tourists_count к каждому отелю
    for it in items:
        name = (it.get("name") or it.get("title") or "").strip()
        it["tourists_count"] = _tourists_count_by_hotel_name(name) if name else 0
    return items


def _strip_html(s: str) -> str:
    if not s:
        return ""
    # 1) раскодировать HTML сущности (&mdash; и т.д.)
    s = html.unescape(s)
    # 2) убрать теги
    s = _TAG_RE.sub("", s)
    # 3) нормализовать пробелы
    return re.sub(r"\s+", " ", s).strip()

WEEKDAY_NUM_TO_CODE = {0:"mon",1:"tue",2:"wed",3:"thu",4:"fri",5:"sat",6:"sun"}
WEEKDAY_CODE_TO_NUM = {v:k for k,v in WEEKDAY_NUM_TO_CODE.items()}

def _is_child(birth_date):
    if not birth_date:
        return False
    today = date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
    return age < 12

@api_view(["GET"])
@permission_classes([AllowAny])
def family_detail(request, fam_id: int):
    from .models import FamilyBooking, Traveler
    fam = get_object_or_404(FamilyBooking, pk=fam_id)

    def _iso(d):
        try:
            return d.isoformat() if d else None
        except Exception:
            return None

    party = []
    for t in Traveler.objects.filter(family=fam).order_by("last_name", "first_name"):
        party.append({
            "id": t.id,
            "first_name": t.first_name or "",
            "last_name":  t.last_name or "",
            "full_name":  f"{t.last_name or ''} {t.first_name or ''}".strip(),
            "is_child":   _is_child(t.dob),

            # ↓↓↓ ЭТИ ПОЛЯ НУЖНЫ ФРОНТУ ДЛЯ АВТО-ЗАПОЛНЕНИЯ ↓↓↓
            "dob":              _iso(getattr(t, "dob", None)),
            "nationality":      getattr(t, "nationality", "") or "",
            "passport":         getattr(t, "passport", "") or "",
            "passport_expiry":  _iso(getattr(t, "passport_expiry", None)),
            "gender":           getattr(t, "gender", "") or "",      # "M" / "F" / ""
            "doc_type":         getattr(t, "doc_type", "") or "",     # "passport" / "dni" / ""
            "doc_expiry":       _iso(getattr(t, "doc_expiry", None)),
            "email":            getattr(t, "email", "") or "",
            "phone":            getattr(t, "phone", "") or "",
        })

    return Response({
        "id": fam.id,
        "hotel_id": fam.hotel_id,
        "hotel_name": fam.hotel_name,
        "checkin": fam.arrival_date.isoformat() if fam.arrival_date else None,
        "checkout": fam.departure_date.isoformat() if fam.departure_date else None,
        "room": "",
        "party": party,
    })

class TravelerPartialUpdateView(APIView):
    permission_classes = [AllowAny]  # можно ужесточить позже

    @transaction.atomic
    def patch(self, request, pk: int):
        t = get_object_or_404(Traveler, pk=pk)
        data = request.data or {}

        allowed = {"gender","doc_type","doc_expiry","passport","nationality","dob","passport_expiry"}
        payload = {k: v for k, v in data.items() if k in allowed and v is not None}

        # аккуратно парсим даты
        for k in ("dob","doc_expiry","passport_expiry"):
            if k in payload and payload[k]:
                try:
                    payload[k] = dt.date.fromisoformat(str(payload[k])[:10])
                except Exception:
                    return Response({"detail": f"Bad date for {k}, use YYYY-MM-DD"}, status=400)

        for k, v in payload.items():
            setattr(t, k, v)
        t.save(update_fields=list(payload.keys()))

        # вернём актуальный срез для фронта
        return Response({
            "id": t.id,
            "gender": t.gender or "",
            "doc_type": t.doc_type or "",
            "doc_expiry": t.doc_expiry.isoformat() if t.doc_expiry else None,
            "passport": t.passport or "",
            "nationality": t.nationality or "",
            "dob": t.dob.isoformat() if t.dob else None,
            "passport_expiry": t.passport_expiry.isoformat() if t.passport_expiry else None,
        })

# --- Черновики броней по семье (лента на странице семьи) ---------------------
class FamilyBookingDraftsView(APIView):
    permission_classes = [AllowAny]

    def get(self, request, fam_id: int):
        qs = (
            BookingSale.objects
            .filter(family_id=fam_id)
            .select_related("company")
            .order_by("-created_at")
        )

        rows = []
        for b in qs:
            # Испанское имя и «двуязычный» заголовок
            es = spanish_excursion_name(int(b.excursion_id or 0), b.excursion_title or "")
            title_bi = (
                f"{b.excursion_title} ({es})"
                if (b.excursion_title and es)
                else (b.excursion_title or es or "")
            )

            rows.append({
                "id": b.id,
                "booking_code": b.booking_code,
                "status": b.status,
                "date": b.date.isoformat() if b.date else None,

                "excursion_id": b.excursion_id,
                "excursion_title": b.excursion_title,
                "excursion_title_es": es,       # чистый ES
                "excursion_title_bi": title_bi, # RU + (ES), plain text

                "hotel_id": b.hotel_id,
                "hotel_name": b.hotel_name,
                "region_name": getattr(b, "region_name", "") or "",

                "pickup_point_id": b.pickup_point_id,
                "pickup_point_name": b.pickup_point_name,
                "pickup_time_str": b.pickup_time_str,
                "pickup_lat": getattr(b, "pickup_lat", None),
                "pickup_lng": getattr(b, "pickup_lng", None),
                "pickup_address": getattr(b, "pickup_address", ""),

                "excursion_language": getattr(b, "excursion_language", None),
                "room_number": getattr(b, "room_number", ""),

                "adults": b.adults,
                "children": b.children,
                "infants": b.infants,

                "price_source": getattr(b, "price_source", "PICKUP"),
                "price_per_adult": str(getattr(b, "price_per_adult", 0) or 0),
                "price_per_child": str(getattr(b, "price_per_child", 0) or 0),
                "gross_total": str(b.gross_total or 0),
                "net_total": str(getattr(b, "net_total", 0) or 0),
                "commission": str(getattr(b, "commission", 0) or 0),

                "company": (
                    CompanySerializer(getattr(b, "company", None)).data
                    if getattr(b, "company_id", None) else None
                ),
                "created_at": b.created_at.isoformat() if b.created_at else None,

                # удобные поля для фронта
                "maps_url": (
                    f"https://maps.google.com/?q={b.pickup_lat},{b.pickup_lng}"
                    if (getattr(b, "pickup_lat", None) is not None and
                        getattr(b, "pickup_lng", None) is not None)
                    else (
                        f"https://maps.google.com/?q={b.pickup_point_name or b.hotel_name}"
                        if (b.pickup_point_name or b.hotel_name) else None
                    )
                ),
                "travelers_csv": getattr(b, "travelers_csv", "") or "",

                # флаги UI
                "is_sendable": b.status in ("DRAFT",),
                "is_sent": b.status in ("PENDING", "HOLD", "PAID", "CANCELLED", "EXPIRED"),
            })

        return Response(rows)


SPECIAL_MAP = {
    # требования «на каждого участника»
    "granada":   {"all": ["first_name", "last_name", "passport", "nationality"]},
    "gibraltar": {"all": ["nationality"]},
    "tangier":   {"all": ["first_name", "last_name", "passport", "nationality", "gender", "dob", "doc_type", "doc_expiry"]},
    "seville":   {"all": ["first_name", "last_name", "passport", "nationality", "dob"]},  # возраст считаем из dob
}

SPECIAL_TITLES = {
    "granada":  ("granada", "гранада"),
    "gibraltar":("gibraltar", "гибралтар"),
    "tangier":  ("tanger", "tangier", "танжер"),
    "seville":  ("seville", "севилья"),
}

def _guess_special_key(title: str | None) -> str | None:
    s = (title or "").lower()
    for key, needles in SPECIAL_TITLES.items():
        if any(n in s for n in needles):
            return key
    return None

def _parse_travelers_csv(csv: str) -> list[int]:
    return [int(x) for x in str(csv or "").split(",") if x.strip().isdigit()]

def _validate_booking_requirements(b) -> list[dict]:
    """
    Проверяет бронь b на спец-требования.
    Возвращает список проблем:
      {"booking_id": int, "traveler_id": int|None, "missing": [field,...]}
    Пустой список = всё ок.
    """
    key = _guess_special_key(getattr(b, "excursion_title", ""))
    if not key:
        return []  # не спецэкскурсия

    need = SPECIAL_MAP.get(key, {}).get("all", [])
    trav_ids = _parse_travelers_csv(getattr(b, "travelers_csv", ""))

    problems = []
    if not trav_ids:
        problems.append({"booking_id": b.id, "traveler_id": None, "missing": ["participants"]})
        return problems

    # Разом тянем нужные поля
    fields = ["id", "first_name", "last_name", "passport", "nationality", "dob", "gender", "doc_type", "doc_expiry", "passport_expiry"]
    travelers = {t.id: t for t in Traveler.objects.filter(id__in=trav_ids).only(*fields)}

    for tid in trav_ids:
        t = travelers.get(tid)
        if not t:
            problems.append({"booking_id": b.id, "traveler_id": tid, "missing": ["not_found"]})
            continue
        miss = []
        for f in need:
            val = getattr(t, f, None)
            if not val:
                # допускаем подмену doc_expiry на паспортный срок, если он есть
                if f == "doc_expiry" and getattr(t, "passport_expiry", None):
                    continue
                miss.append(f)
        if miss:
            problems.append({"booking_id": b.id, "traveler_id": tid, "missing": miss})

    return problems


@method_decorator(csrf_exempt, name="dispatch")
class BookingBatchPreviewView(APIView):
    """
    POST /api/sales/bookings/batch/preview/
    Body JSON: { "family_id": 123 } ИЛИ { "booking_ids": [1,2,3] }
    Возвращает сводку черновиков текущего "гида" (status='DRAFT').
    """
    authentication_classes = []
    permission_classes = [AllowAny]

    def post(self, request):
        booking_ids = request.data.get("booking_ids") or []
        family_id = request.data.get("family_id")

        user = _resolve_user(request)

        qs = BookingSale.objects.filter(status="DRAFT").select_related("company")
        if user:
            qs = qs.filter(guide=user)

        try:
            if family_id:
                qs = qs.filter(family_id=family_id)
            elif booking_ids:
                qs = qs.filter(id__in=booking_ids)
        except FieldError:
            return Response({"detail": "В модели BookingSale нет поля family."}, status=400)

        items = []
        total = 0.0
        blocked = 0

        # Валидация спец-экскурсий на лету
        problems_all = {}  # booking_id -> [problem,...]

        for b in qs.order_by("-created_at"):
            gross = float(b.gross_total or 0)
            total += gross

            probs = _validate_booking_requirements(b)
            if probs:
                blocked += 1
                problems_all[b.id] = probs

            items.append({
                "id": b.id,
                "booking_code": b.booking_code,
                "company": getattr(b.company, "name", None),
                "date": b.date.isoformat() if b.date else None,
                "excursion_id": b.excursion_id,
                "excursion_title": b.excursion_title,
                "hotel_name": b.hotel_name,
                "pickup_point_name": b.pickup_point_name,
                "pickup_time_str": b.pickup_time_str,
                "excursion_language": getattr(b, "excursion_language", None),
                "room_number": getattr(b, "room_number", ""),
                "adults": b.adults, "children": b.children, "infants": b.infants,
                "gross_total": f"{gross:.2f}",
                "price_per_adult": str(getattr(b, "price_per_adult", 0) or 0),
                "price_per_child": str(getattr(b, "price_per_child", 0) or 0),
                "pickup_lat": getattr(b, "pickup_lat", None),
                "pickup_lng": getattr(b, "pickup_lng", None),
                "pickup_address": getattr(b, "pickup_address", ""),
                "status": b.status,
                # можно отправить, только если DRAFT и нет проблем по требованиям
                "is_sendable": (b.status == "DRAFT" and not probs),
                # чтобы фронт красиво подсветил недостающие поля рядом с участниками
                "problems": problems_all.get(b.id, []),
            })

        return Response({
            "count": len(items),
            "total": f"{total:.2f}",
            "blocked": blocked,             # сколько броней нельзя отправить
            "items": items,
        }, status=200)




@method_decorator(csrf_exempt, name="dispatch")
class BookingBatchSendView(APIView):
    """
    POST /api/sales/bookings/batch/send/
    Body JSON: { "family_id": 123 } ИЛИ { "booking_ids": [1,2,3] }
    Переводит выбранные черновики из DRAFT -> PENDING и (опционально) запускает отправку.
    """
    authentication_classes = []
    permission_classes = [AllowAny]

    def post(self, request):
        booking_ids = request.data.get("booking_ids") or []
        family_id = request.data.get("family_id")

        user = _resolve_user(request)

        qs = BookingSale.objects.filter(status="DRAFT").select_related("company")
        if user:
            qs = qs.filter(guide=user)

        try:
            if family_id:
                qs = qs.filter(family_id=family_id)
            elif booking_ids:
                qs = qs.filter(id__in=booking_ids)
        except FieldError:
            return Response({"detail": "В модели BookingSale нет поля family."}, status=400)

        # Валидация перед отправкой: если есть «дыры» — 422 и список проблем
        problems = []
        for b in qs:
            problems += _validate_booking_requirements(b)

        if problems:
            return Response(
                {"detail": "Requirements missing", "problems": problems},
                status=422  # Unprocessable Entity
            )

        # --- отправка писем + перевод статусов ---------------------------------------
        bookings = list(qs)           # материализуем queryset, чтобы переиспользовать
        sent_ids = []
        failed_ids = []

        for b in bookings:
            try:
                ok = send_booking_email(b, subject_prefix="[SalesPortal]")
            except Exception:
                ok = False
            if ok:
                sent_ids.append(b.id)
            else:
                failed_ids.append(b.id)

        # Переводим в PENDING только те, что реально ушли
        if sent_ids:
            upd = {"status": "PENDING"}
            if hasattr(BookingSale, "sent_at"):
                upd["sent_at"] = timezone.now()
            BookingSale.objects.filter(id__in=sent_ids).update(**upd)

        return Response(
            {
                "sent": len(sent_ids),
                "failed_ids": failed_ids,
                "updated_to_pending": len(sent_ids),
            },
            status=200 if sent_ids and not failed_ids else 207  # 207 = частичный успех
        )



@method_decorator(csrf_exempt, name="dispatch")
class BookingBatchCancelView(APIView):
    """
    POST /api/sales/bookings/batch/cancel/
    Body JSON: { "booking_ids": [1,2,3] } ИЛИ { "family_id": 123, "reason": "..." }
    Правила:
      - DRAFT удалять/не трогать (не аннулируем)
      - CANCELLED — идемпотентно (пропускаем)
      - Остальные (PENDING/HOLD/PAID/CONFIRMED/EXPIRED) → CANCELLED
    """
    authentication_classes = []
    permission_classes = [AllowAny]

    @transaction.atomic
    def post(self, request):
        booking_ids = request.data.get("booking_ids") or []
        family_id = request.data.get("family_id")
        reason = (request.data.get("reason") or "").strip()

        user = _resolve_user(request)

        # Базовый queryset: все НЕ DRAFT (DRAFT не аннулируем)
        qs = BookingSale.objects.exclude(status="DRAFT")
        if user:
            qs = qs.filter(guide=user)

        try:
            if family_id:
                qs = qs.filter(family_id=family_id)
            elif booking_ids:
                qs = qs.filter(id__in=booking_ids)
        except FieldError:
            return Response({"detail": "В модели BookingSale нет поля family."}, status=400)

        # Разделим на уже отменённые и подлежащие отмене
        to_cancel = list(qs.exclude(status="CANCELLED").values_list("id", flat=True))
        already = list(qs.filter(status="CANCELLED").values_list("id", flat=True))

        if not to_cancel and not already:
            return Response({"updated": 0, "cancelled_ids": [], "already_cancelled": []}, status=200)

        # 1) Письма об аннуляции (не прерывают процесс, просто считаем успех/ошибки)
        emailed_ok, emailed_fail = [], []
        for b in BookingSale.objects.filter(id__in=to_cancel):
            try:
                ok = send_cancellation_email(b, reason)
            except Exception:
                ok = False
            (emailed_ok if ok else emailed_fail).append(b.id)

        # 2) Обновляем статус/время/причину для всех к аннуляции
        now = timezone.now()
        upd = {"status": "CANCELLED"}
        if hasattr(BookingSale, "cancelled_at"):
            upd["cancelled_at"] = now
        BookingSale.objects.filter(id__in=to_cancel).update(**upd)

        # причину пишем отдельным апдейтом, только если она передана и поле есть
        if reason and hasattr(BookingSale, "cancel_reason"):
            BookingSale.objects.filter(id__in=to_cancel).update(cancel_reason=reason)

        return Response({
            "updated": len(to_cancel),
            "cancelled_ids": to_cancel,      # все, кому сменили статус
            "already_cancelled": already,    # были отменены раньше
            "email_sent_ok": emailed_ok,     # для логов/индикаторов на фронте
            "email_failed_ids": emailed_fail
        }, status=200)



def _normalize_excursions(raw, compact: bool = True, limit: int | None = None, offset: int = 0):
    items = raw.get("items") if isinstance(raw, dict) else raw
    if not isinstance(items, list):
        items = []

    total = len(items)
    if limit is not None:
        items = items[offset: offset + limit]

    norm = []
    for it in items:
        _id = it.get("id")
        title = it.get("localized_title") or it.get("title") or ""
        description_html = it.get("localized_description") or it.get("description") or ""
        image = it.get("image")
        duration = it.get("duration")
        direction = it.get("direction")

        days_code = it.get("days") or []
        days_num = it.get("available_days") or []
        if not days_code and days_num:
            days_code = [WEEKDAY_NUM_TO_CODE.get(n) for n in days_num if n in WEEKDAY_NUM_TO_CODE]
        if not days_num and days_code:
            days_num = [WEEKDAY_CODE_TO_NUM.get(c) for c in days_code if c in WEEKDAY_CODE_TO_NUM]

        languages = it.get("tour_languages") or it.get("languages") or []

        if compact:
            short = _strip_html(description_html)[:220].rstrip()
            norm.append({
                "id": _id,
                "title": title,
                "short_description": short,
                "duration": duration,
                "direction": direction,
                "days": days_code,          # ["thu", ...]
                "available_days": days_num, # [3, ...]
                "languages": languages,     # <= ВАЖНО для выпадающего списка языков
                "image": image,
            })
        else:
            norm.append({
                "id": _id,
                "title": title,
                "description_html": description_html,
                "duration": duration,
                "direction": direction,
                "days": days_code,
                "available_days": days_num,
                "languages": languages,
                "image": image,
            })
    return {"items": norm, "total": total}

def _es_title_overrides() -> dict[int, str]:
    """
    Необязательная мапа {excursion_id: 'Sevilla', ...} из вашей админки core,
    чтобы (если нужно) добавить поле title_es к ответу — не затрагивая title.
    """
    try:
        CoreExcursion = apps.get_model('core', 'Excursion')
    except Exception:
        return {}
    rows = (
        CoreExcursion.objects
        .filter(is_active=True)
        .exclude(csi_id__isnull=True)
        .values("csi_id", "name")
    )
    out = {}
    for r in rows:
        try:
            out[int(r["csi_id"])] = r["name"] or ""
        except Exception:
            pass
    return out

@api_view(["GET"])
def excursions(request):
    lang = request.query_params.get("lang", "ru")
    date = request.query_params.get("date")
    region = request.query_params.get("region")
    compact = request.query_params.get("compact", "1") not in ("0", "false", "False")
    try:
        limit = int(request.query_params.get("limit", "20"))
    except ValueError:
        limit = 20
    try:
        offset = int(request.query_params.get("offset", "0"))
    except ValueError:
        offset = 0

    # <-- ВАЖНО: всегда используем CSI как источник, чтобы не потерять languages
    raw = csi.list_excursions(lang=lang, date=date, region=region)
    data = _normalize_excursions(raw, compact=compact, limit=limit, offset=offset)

    # Необязательное: добавим title_es, если есть в админке core (не ломает фронт)
    es_map = _es_title_overrides()
    if es_map:
        for it in data["items"]:
            es = es_map.get(int(it["id"] or 0))
            if es:
                it["title_es"] = es

    return Response(data)


class SalesExcursionPickupsView(APIView):
    """GET /api/sales/pickups/v2/?excursion_id=&hotel_id=&hotel_name=&date=YYYY-MM-DD
    Returns: {excursion_id, excursion_title, hotel_id, date, count, results:[{...}]}
    """

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        # 1) excursion_id обязателен и целый
        try:
            excursion_id = int(request.GET.get("excursion_id", ""))
        except (TypeError, ValueError):
            return Response({"detail": "excursion_id must be integer"}, status=status.HTTP_400_BAD_REQUEST)

        # 2) date обязателен и в формате YYYY-MM-DD
        date_str = request.GET.get("date")
        if not date_str or not parse_date(date_str):
            return Response({"detail": "Invalid or missing 'date' (YYYY-MM-DD)"}, status=status.HTTP_400_BAD_REQUEST)

        # 3) hotel_id ИЛИ hotel_name (fallback)
        hotel_name = (request.GET.get("hotel_name") or request.GET.get("hotel") or "").strip()
        hotel_id = None
        hotel_id_raw = request.GET.get("hotel_id")
        try:
            hotel_id = int(hotel_id_raw) if hotel_id_raw not in (None, "",) else None
        except ValueError:
            hotel_id = None

        if not hotel_id and hotel_name:
            hid = _resolve_hotel_id_by_name(hotel_name)
            if hid:
                hotel_id = hid

        if not hotel_id:
            # мягкий ответ, как и раньше: просто пустой список без ошибки
            title = csi.excursion_title(excursion_id, lang=(request.GET.get("lang") or "ru")[:5])
            return Response({
                "excursion_id": excursion_id,
                "excursion_title": title,
                "hotel_id": None,
                "date": date_str,
                "count": 0,
                "results": [],
            })

        # 4) тянем пикапы у клиента
        client = get_client()
        pickups = client.excursion_pickups(excursion_id=excursion_id, hotel_id=hotel_id, date=date_str)

        # 5) добавим заголовок экскурсии
        lang = (request.GET.get("lang") or request.headers.get("Accept-Language") or "ru")[:5]
        title = csi.excursion_title(excursion_id, lang=lang)

        results = []
        for it in pickups:
            results.append({
                "id": it.get("id"),
                "point": it.get("name") or it.get("point"),
                "time": it.get("time"),
                "lat": it.get("lat"),
                "lng": it.get("lng"),
                "address": it.get("address") or "",
            })

        return Response({
            "excursion_id": excursion_id,
            "excursion_title": title,
            "hotel_id": hotel_id,
            "date": date_str,
            "count": len(results),
            "results": results,     # ← ТАК, а не pickups
        })



@api_view(["GET"])
def pickups(request):
    ex_id = request.GET.get("excursion_id")
    hotel_id = request.GET.get("hotel_id")
    date = request.GET.get("date")  # пока не используем

    if not ex_id or not hotel_id:
        return Response({"error": "excursion_id and hotel_id are required", "items": []}, status=400)

    try:
        ex_id = int(ex_id)
        hotel_id = int(hotel_id)
    except ValueError:
        return Response({"error": "excursion_id and hotel_id must be integers", "items": []}, status=400)

    item = csi.get_client().excursion_pickup(ex_id, hotel_id)
    if not item:
        # совместимо с фронтом: пустой список — просто нет точки
        return Response({"items": []}, status=200)

    # язык для заголовка экскурсии
    lang = (request.GET.get("lang") or request.headers.get("Accept-Language") or "ru")[:5]
    title = csi.excursion_title(ex_id, lang=lang)

    # Нормализуем к единому виду
    norm = {
        "id": item.get("id"),
        "point": item.get("name"),
        "time": item.get("time"),       # "HH:MM" или None
        "lat": item.get("lat"),
        "lng": item.get("lng"),
        "price_adult": item.get("price_adult"),
        "price_child": item.get("price_child"),
    }
    return Response({
        "excursion_id": ex_id,
        "excursion_title": title,
        "hotel_id": hotel_id,
        "items": [norm]
    }, status=200)


@api_view(["GET"])
def quote(request):
    try:
        ex_id = int(request.query_params["excursion_id"])
        adults = int(request.query_params.get("adults", "1"))
        children = int(request.query_params.get("children", "0"))
        infants = int(request.query_params.get("infants", "0"))
    except (KeyError, ValueError):
        return Response({"detail": "invalid params"}, status=400)

    lang = request.query_params.get("lang", "ru")
    hotel_id_raw = request.query_params.get("hotel_id")
    hotel_id = int(hotel_id_raw) if (hotel_id_raw and hotel_id_raw.isdigit()) else None
    date = request.query_params.get("date")
    hotel_name = request.query_params.get("hotel_name") or request.query_params.get("hotel")

    if not hotel_id and hotel_name:
        hid = _resolve_hotel_id_by_name(hotel_name)
        if hid:
            hotel_id = hid

    if not hotel_id:
        return Response({"detail": "hotel_id is required (could not resolve by hotel_name)"}, status=400)

    try:
        data = pricing_quote(
            excursion_id=ex_id,
            adults=adults,
            children=children,
            infants=infants,
            lang=lang,
            hotel_id=hotel_id,
            date=date,
        )
        return Response(data)
    except Exception as e:
        logging.getLogger(__name__).exception("quote() failed")
        return Response({"detail": str(e)}, status=500)



@api_view(["GET"])
@permission_classes([AllowAny])
def pricing_debug_signature(request):
    try:
        import sales.services.costasolinfo as mod
        sig = str(inspect.signature(mod.pricing_quote))
        path = getattr(mod, "__file__", "<unknown>")
        return Response({"module_file": path, "signature": sig})
    except Exception as e:
        return Response({"detail": str(e)}, status=500)

# def _weekday_slug(date_str: str) -> str | None:
#     try:
#         d = dt.date.fromisoformat(date_str)
#         return WEEKDAYS[d.weekday()]
#     except Exception:
#         return None

@api_view(["GET"])
@permission_classes([AllowAny])
def pricing_quote_view(request):
    try:
        excursion_id = int(request.GET.get("excursion_id"))
        adults = int(request.GET.get("adults", 0))
        children = int(request.GET.get("children", 0))
        infants = int(request.GET.get("infants", 0))
        lang = request.GET.get("lang") or "ru"

        hotel_id_raw = request.GET.get("hotel_id")
        hotel_id = int(hotel_id_raw) if (hotel_id_raw and hotel_id_raw.isdigit()) else None
        hotel_name = request.GET.get("hotel_name") or request.GET.get("hotel")
        date = request.GET.get("date")

        if adults < 0 or children < 0 or infants < 0:
            return Response({"detail": "Negative quantities not allowed"}, status=400)

        # hotel_id по названию (если нужно)
        if not hotel_id and hotel_name:
            hid = _resolve_hotel_id_by_name(hotel_name)
            if hid:
                hotel_id = hid
        if not hotel_id:
            return Response({"detail": "hotel_id is required (could not resolve by hotel_name)"}, status=400)

        # Проверка доступности даты по экскурсии (если дата передана)
        if date:
            wd = _weekday_slug(date)
            if not wd:
                return Response({"detail": "Bad date format, use YYYY-MM-DD"}, status=400)
            try:
                ex = csi.excursion_detail(excursion_id)
            except Exception:
                ex = {}
            avail_raw = (ex.get("available_days") or ex.get("days") or [])
            avail_norm = []
            for x in avail_raw:
                if isinstance(x, int):
                    avail_norm.append(WEEKDAYS[x % 7])     # 0..6
                else:
                    avail_norm.append(str(x).strip().lower()[:3])
            if avail_norm and wd not in avail_norm:
                return Response({
                    "detail": f"Date {date} is not available for this excursion",
                    "available_days": avail_norm
                }, status=400)

        # 1) Основной путь — через pricing_quote (по региону)
        try:
            quote = pricing_quote(
                excursion_id=excursion_id,
                adults=adults,
                children=children,
                infants=infants,
                lang=lang,
                hotel_id=hotel_id,
                date=date,
            )
            return Response(quote)
        except NotFoundError:
            # 2) Фолбэк — посчитать из пикапа (как делает публичный сайт)
            client = get_client()

            price_adult = price_child = Decimal("0")
            pickup = None
            # если есть дата — берём конкретный пикап на дату (самый первый)
            try:
                if date:
                    picks = client.excursion_pickups(excursion_id=excursion_id, hotel_id=hotel_id, date=date) or []
                    if picks:
                        pickup = picks[0]
                if not pickup:
                    pickup = client.excursion_pickup(excursion_id, hotel_id) or {}
            except Exception:
                pickup = {}

            if pickup:
                try:
                    price_adult = Decimal(str(pickup.get("price_adult") or "0"))
                    price_child = Decimal(str(pickup.get("price_child") or "0"))
                except Exception:
                    price_adult = price_child = Decimal("0")

            if price_adult > 0 or price_child > 0:
                gross = (price_adult * Decimal(adults)) + (price_child * Decimal(children))
                return Response({
                    "excursion_id": excursion_id,
                    "hotel_id": hotel_id,
                    "date": date,
                    "price_source": "PICKUP",            # ← помечаем источник
                    "price_per_adult": str(price_adult),
                    "price_per_child": str(price_child),
                    "gross_total": str(gross.quantize(Decimal("0.01"))),
                }, status=200)

            return Response({"detail": "Price not available for given params (no region & no pickup price)"}, status=404)

    except (TypeError, ValueError) as e:
        return Response({"detail": str(e), "type": e.__class__.__name__}, status=400)
    except Exception as e:
        logging.getLogger(__name__).exception("pricing_quote_view failed")
        return Response({"detail": str(e), "type": e.__class__.__name__}, status=500)



@api_view(["GET"])
@permission_classes([AllowAny])
def debug_raw_hotel(request):
    from .services.costasolinfo import _get
    hotel_id = request.GET.get("hotel_id")
    if not hotel_id:
        return JsonResponse({"detail": "hotel_id required"}, status=400)
    try:
        hid = int(hotel_id)
    except ValueError:
        return JsonResponse({"detail": "hotel_id must be int"}, status=400)
    data = _get(f"/hotels/{hid}/", allow_404=True)
    return JsonResponse({"hotel_id": hid, "raw": data}, json_dumps_params={"ensure_ascii": False, "default": str})

@api_view(["GET"])
@permission_classes([AllowAny])
def debug_raw_excursion(request):
    from .services.costasolinfo import _get
    excursion_id = request.GET.get("excursion_id")
    if not excursion_id:
        return JsonResponse({"detail": "excursion_id required"}, status=400)
    try:
        exid = int(excursion_id)
    except ValueError:
        return JsonResponse({"detail": "excursion_id must be int"}, status=400)
    data = _get(f"/excursions/{exid}/", allow_404=True)
    return JsonResponse({"excursion_id": exid, "raw": data}, json_dumps_params={"ensure_ascii": False, "default": str})


class CompanyViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Company.objects.filter(is_active=True).order_by("name")
    serializer_class = CompanySerializer
    permission_classes = [AllowAny]  # <-- было IsAuthenticated


@method_decorator(csrf_exempt, name="dispatch")
class BookingCreateView(APIView):
    authentication_classes = []          # ← отключаем DRF SessionAuthentication (и его CSRF)
    permission_classes = [AllowAny]      # как и было для dev

    def post(self, request):
        ser = BookingSaleCreateSerializer(data=request.data, context={"request": request})
        ser.is_valid(raise_exception=True)
        booking = ser.save()
        return Response({"id": booking.id, "booking_code": booking.booking_code}, status=status.HTTP_200_OK)

class BookingListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        qs = BookingSale.objects.filter(guide=request.user).order_by("-created_at")[:200]
        return Response(BookingSaleListSerializer(qs, many=True).data)


class BookingDetailView(APIView):
    """
    GET    /api/sales/bookings/<pk>/       → данные одной брони
    PUT    /api/sales/bookings/<pk>/       → обновление (только если DRAFT)
    PATCH  /api/sales/bookings/<pk>/       → частичное обновление (только если DRAFT)
    DELETE /api/sales/bookings/<pk>/       → удаление (только если DRAFT)
    """
    permission_classes = [AllowAny]   # пока как и остальные тестовые эндпоинты

    def get_object(self, pk: int) -> BookingSale:
        return get_object_or_404(BookingSale, pk=pk)

    def get(self, request, pk: int):
        b = self.get_object(pk)
        return Response(_booking_to_json(b), status=200)

    @transaction.atomic
    def delete(self, request, pk: int):
        b = self.get_object(pk)
        if b.status != "DRAFT":
            return Response({"detail": "Only DRAFT bookings can be deleted"}, status=409)
        b.delete()
        return Response({"deleted": 1, "id": pk}, status=200)

    @transaction.atomic
    def put(self, request, pk: int):
        return self._update(request, pk, partial=False)

    @transaction.atomic
    def patch(self, request, pk: int):
        return self._update(request, pk, partial=True)

    def _update(self, request, pk: int, partial: bool):
        b = self.get_object(pk)
        if b.status != "DRAFT":
            return Response({"detail": "Only DRAFT bookings can be edited"}, status=409)

        data = request.data or {}
        # список разрешённых к правке полей
        editable = {
            "date", "room_number", "excursion_language",
            "pickup_point_id", "pickup_point_name", "pickup_time_str",
            "pickup_lat", "pickup_lng", "pickup_address",
            "adults", "children", "infants",
            "gross_total", "price_per_adult", "price_per_child",
        }

        # аккуратно приводим типы там, где нужно
        for key, val in list(data.items()):
            if key not in editable:
                data.pop(key, None)

        # date
        if "date" in data and data["date"]:
            try:
                data["date"] = dt.date.fromisoformat(str(data["date"])[:10])
            except Exception:
                return Response({"detail": "Bad date format, use YYYY-MM-DD"}, status=400)

        # числовые
        for k in ("adults", "children", "infants"):
            if k in data and data[k] is not None:
                try: data[k] = int(data[k])
                except Exception: return Response({"detail": f"{k} must be int"}, status=400)

        for k in ("price_per_adult", "price_per_child", "gross_total"):
            if k in data and data[k] is not None:
                try: data[k] = float(data[k])
                except Exception: return Response({"detail": f"{k} must be number"}, status=400)

        # обновляем
        for k, v in data.items():
            setattr(b, k, v)
        b.save(update_fields=[*data.keys()] or None)

        return Response(_booking_to_json(b), status=200)


@method_decorator(csrf_protect, name="dispatch")
class BookingCancelView(APIView):
    """
    POST /api/sales/bookings/<pk>/cancel/
    Требует активную сессию и валидный CSRF-токен.
    Меняет статус брони на CANCELLED и отправляет письмо об аннуляции.
    """
    authentication_classes = [SessionAuthentication]
    permission_classes = [IsAuthenticated]

    @transaction.atomic
    def post(self, request, pk: int):
        b = get_object_or_404(BookingSale, pk=pk)

        # DRAFT нельзя аннулировать — только удалять
        if b.status == "DRAFT":
            return Response({"detail": "Draft cannot be cancelled, delete it instead"}, status=409)

        # Уже отменённые возвращаем как есть (идемпотентность)
        if b.status == "CANCELLED":
            return Response(_booking_to_json(b), status=200)

        reason = (request.data or {}).get("reason") or ""

        # Письмо об аннуляции (если не ушло — всё равно продолжаем)
        try:
            send_cancellation_email(b, reason)
        except Exception:
            pass

        # Обновляем статус и время
        b.status = "CANCELLED"
        if hasattr(b, "cancelled_at"):
            b.cancelled_at = timezone.now()
        if hasattr(b, "cancel_reason"):
            b.cancel_reason = reason or getattr(b, "cancel_reason", "")

        b.save(
            update_fields=[
                "status",
                *(["cancelled_at"] if hasattr(b, "cancelled_at") else []),
                *(["cancel_reason"] if hasattr(b, "cancel_reason") else []),
            ]
        )

        return Response(_booking_to_json(b), status=200)
```


---

## `backend/sales/views_pages.py`

```py
# sales/views_pages.py
from django.shortcuts import render
from django.views.decorators.http import require_http_methods
from django.contrib import messages

from .forms import TouristsImportForm
from .importers.tourists_excel import import_file  # ← используем адаптер

@require_http_methods(["GET", "POST"])
def tourists_import_page(request):
    """
    Страница импорта туристов из Excel/CSV.
    Форма должна быть с enctype="multipart/form-data".
    В форме есть поля:
      - file  : загружаемый файл
      - dryrun: чекбокс «Пробный запуск (без сохранения)»
    """
    if request.method == "POST":
        form = TouristsImportForm(request.POST, request.FILES)
        if not form.is_valid():
            messages.error(request, "Проверьте форму — есть ошибки.")
            return render(request, "sales/tourists_import.html", {"form": form})

        up_file = form.cleaned_data["file"]
        dry_run = form.cleaned_data.get("dryrun", True)

        try:
            # import_file сам прочитает и запустит импортёр
            report = import_file(up_file, dry_run=dry_run)

            # Сообщение пользователю
            if dry_run:
                messages.info(
                    request,
                    f"Пробный запуск: будет создано семей: {report.get('families_created', 0)}, "
                    f"туристов: {report.get('travelers_created', 0)}. "
                    f"Пропущено строк: {report.get('skipped', 0)}."
                )
            else:
                messages.success(
                    request,
                    f"Импорт выполнен: создано семей: {report.get('families_created', 0)}, "
                    f"туристов: {report.get('travelers_created', 0)}. "
                    f"Пропущено строк: {report.get('skipped', 0)}."
                )

            # Показать отчёт (если шаблон это поддерживает)
            return render(request, "sales/tourists_import.html", {
                "form": form,
                "report": report,   # можно вывести цифры и замечания
            })

        except Exception as e:
            messages.error(request, f"Ошибка импорта: {e}")
            # падаем обратно на форму
            return render(request, "sales/tourists_import.html", {"form": form})

    # GET
    form = TouristsImportForm(initial={"dryrun": True})
    return render(request, "sales/tourists_import.html", {"form": form})

```


---

## `backend/sales/forms.py`

```py
# sales/forms.py
from django import forms

class TouristsImportForm(forms.Form):
    file = forms.FileField(label="Файл с туристами (Excel/CSV)")
    dry_run = forms.BooleanField(label="Только проверка", required=False)

```


---

## `backend/sales/importers/__init__.py`

```py

```


---

## `backend/sales/importers/tourists_excel.py`

```py


# sales/importers/tourists_excel.py
from __future__ import annotations

import re
from dataclasses import dataclass, field
from datetime import datetime
from io import BytesIO
from typing import Any, BinaryIO, Dict, List, Optional

import pandas as pd
from django.db import IntegrityError, transaction
from django.utils.timezone import make_naive

from sales.models import FamilyBooking, Traveler
from sales.services import costasolinfo as csi


# ---------- утилиты нормализации ----------

def _norm(s: str) -> str:
    if s is None:
        return ""
    s = str(s)
    s = s.replace("\xa0", " ")  # NBSP -> обычный пробел
    s = re.sub(r"\s+", " ", s).strip()
    s = s.lower()
    s = re.sub(r"[^\w\sа-яё\-]", "", s, flags=re.IGNORECASE)  # убираем мусор
    s = s.replace("-", " ")
    s = re.sub(r"\s+", " ", s).strip()
    return s


def _find_col(df: pd.DataFrame, aliases: List[str]) -> Optional[str]:
    """Ищем колонку по набору алиасов: сначала точное совпадение после _norm, потом вхождение."""
    cols = [str(c).strip() for c in df.columns]
    norm_cols = {c: _norm(c) for c in cols}
    norm_alias = [_norm(a) for a in aliases]

    for c, nc in norm_cols.items():
        if nc in norm_alias:
            return c
    for c, nc in norm_cols.items():
        if any(na and na in nc for na in norm_alias):
            return c
    return None


def _parse_date(v):
    if v is None or (isinstance(v, float) and pd.isna(v)) or (isinstance(v, str) and not v.strip()):
        return None
    if isinstance(v, (datetime, pd.Timestamp)):
        try:
            return make_naive(v).date() if isinstance(v, pd.Timestamp) and v.tzinfo else v.date()
        except Exception:
            return v.date() if hasattr(v, "date") else None
    for fmt in ("%d.%m.%Y", "%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y"):
        try:
            return datetime.strptime(str(v).strip(), fmt).date()
        except Exception:
            pass
    d = pd.to_datetime(v, dayfirst=True, errors="coerce")
    return d.date() if not pd.isna(d) else None


def _resolve_hotel(name: str) -> tuple[Optional[int], str, str]:
    """Пытаемся найти hotel_id по названию через CSI. Возвращаем (id, name, region_name)."""
    try:
        items = csi.search_hotels(name, limit=1) or []
        if isinstance(items, dict):
            items = items.get("items") or []
        if items:
            h = items[0]
            return (
                h.get("id"),
                h.get("name") or h.get("title") or name,
                (h.get("region") or h.get("region_name") or ""),
            )
    except Exception:
        pass
    return None, name, ""


# ---------- карта колонок ----------

COLMAP = {
    "ref_code": ["Номер брони", "Номер заявки", "Reservation", "Booking", "ref", "Заявка"],
    "hotel": ["Отель", "Hotel", "Гостиница"],
    "arrival": ["Дата заезда", "Arrival", "Дата прилёта", "Check-in", "Check in", "Заезд"],
    "departure": [
        "Дата выезда", "Дата отъезда", "Отъезд", "Выезд",
        "Дата возвращения", "Возврат",
        "Departure", "Return date",
        "Check-out", "Check out",
        "Дата вылета", "Вылет",
    ],
    "last_name": ["Фамилия", "Last name", "Surname"],
    "first_name": ["Имя", "First name", "Name"],
    "middle_name": ["Отчество", "Middle name", "Patronymic"],
    "dob": ["Дата рождения", "DOB", "Birth date"],
    "nationality": ["Национальность", "Nationality"],
    "passport": ["Паспорт", "Passport", "Doc number"],
    "passport_expiry": ["Срок действия паспорта", "Passport expiry", "Expiry"],
    "gender": ["Пол", "Sex", "Gender"],   # ← ДОБАВИЛИ
    "doc_type": ["Тип документа", "Document type", "Doc type", "Тип док."],
    "doc_expiry": ["Срок действия документа", "Document expiry", "Doc expiry", "Expiry date"],
    "phone": ["Телефон", "Phone", "Номер телефона", "Контактный телефон"],
    "email": ["Email", "E-mail", "Эл. почта", "Почта"],
    "note": ["Примечание", "Note", "Комментарий"],
}

def norm_gender(val: str | None) -> str | None:
    if not val:
        return None
    s = str(val).strip().upper().rstrip(".")
    if s in ("M", "MALE", "М", "МУЖ", "MR"):
        return "M"
    if s in ("F", "FEMALE", "Ж", "ЖЕН", "MRS", "MS", "MISS"):
        return "F"
    return None

def norm_doc_type(val: str | None) -> str | None:
    if not val:
        return None
    s = str(val).strip().lower().replace(".", "")
    if s in ("passport", "pass", "паспорт", "загранпаспорт"):
        return "passport"
    if s in ("dni", "id", "id card", "ид", "удостоверение", "нацпаспорт"):
        return "dni"
    return None

# --- вверху файла рядом с _norm и пр. добавь такую же нормализацию имён ---
def _norm_name_excel(s: str) -> str:
    """Повторяем логику _norm_name из модели (или максимально близко).
       Важно: она должна давать тот же результат, что и в Traveler.save()."""
    if s is None:
        return ""
    s = str(s).strip()
    # примеры: убираем лишние пробелы, приводим к Title Case
    s = re.sub(r"\s+", " ", s)
    return s.title()



# ---------- авто-детекция строки заголовков ----------

def _auto_header(df0: pd.DataFrame) -> pd.DataFrame:
    """Если заголовки 'Unnamed' или «мимо», ищем строку-шапку по знакомым названиям."""
    def _score(cols: List[str]) -> int:
        cols_l = [str(c).strip().lower() for c in cols]
        score = 0
        for aliases in COLMAP.values():
            for a in aliases:
                if a.lower() in cols_l:
                    score += 1
                    break
        return score

    if _score(list(df0.columns)) >= 2:
        return df0  # и так норм

    best = (None, -1)
    for i in range(min(10, len(df0))):
        row = [str(x).strip() for x in df0.iloc[i].tolist()]
        sc = _score(row)
        if sc > best[1]:
            best = (i, sc)
    header_idx, sc = best
    if header_idx is not None and sc >= 2:
        new_cols = [str(x).strip() or f"col_{j}" for j, x in enumerate(df0.iloc[header_idx].tolist())]
        df = df0.iloc[header_idx + 1:].copy()
        df.columns = new_cols
        return df

    return df0


# ---------- отчёт ----------

@dataclass
class RowIssue:
    rownum: int
    message: str
    payload: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ImportReport:
    sheet: str
    total_rows: int = 0
    created_families: int = 0
    updated_families: int = 0
    created_travelers: int = 0
    skipped: int = 0
    issues: List[RowIssue] = field(default_factory=list)


# ---------- основной импортёр ----------

def import_tourists_excel(file, dry_run: bool = True) -> Dict[str, Any]:
    # читаем .xlsx или .csv
    if hasattr(file, "name") and str(file.name).lower().endswith(".csv"):
        df0 = pd.read_csv(file, header=None)  # без заголовка — определим сами
        sheet_name = "CSV"
    else:
        xls = pd.ExcelFile(file)
        sheet_name = xls.sheet_names[0]
        df0 = xls.parse(sheet_name, header=None)  # без заголовков — определим сами

    df = _auto_header(df0)
    report = ImportReport(sheet=sheet_name, total_rows=len(df))

    # маппинг колонок
    cols = {key: _find_col(df, aliases) for key, aliases in COLMAP.items()}
    required = ["hotel", "last_name", "first_name"]
    missing = [k for k in required if not cols.get(k)]
    if missing:
        report.issues.append(RowIssue(0, f"Нет обязательных колонок: {missing}"))
        return {
            **report.__dict__,
            "column_mapping": {k: cols[k] for k in cols if cols[k]},
            "issues": [i.__dict__ for i in report.issues],
            "dry_run": dry_run,
        }

    def _do():
        for idx, row in df.iterrows():
            # отдельный savepoint на каждую строку
            with transaction.atomic():
                hotel_raw = str(row.get(cols["hotel"], "")).strip()
                if not hotel_raw:
                    report.issues.append(RowIssue(idx + 2, "Пустой отель"))
                    report.skipped += 1
                    continue

                hotel_id, hotel_name, region_name = _resolve_hotel(hotel_raw)

                ref_code = str(row.get(cols.get("ref_code"), "")).strip() if cols.get("ref_code") else ""
                arrival = _parse_date(row.get(cols.get("arrival"))) if cols.get("arrival") else None
                departure = _parse_date(row.get(cols.get("departure"))) if cols.get("departure") else None

                fam = FamilyBooking.objects.filter(ref_code=ref_code or "", hotel_id=hotel_id or 0).first()
                if not fam:
                    fam = FamilyBooking.objects.create(
                        ref_code=ref_code or "",
                        hotel_id=hotel_id or 0,
                        hotel_name=hotel_name,
                        region_name=region_name,
                        arrival_date=arrival,
                        departure_date=departure,
                    )
                    report.created_families += 1
                else:
                    changed = False
                    if arrival and fam.arrival_date != arrival:
                        fam.arrival_date = arrival
                        changed = True
                    if departure and fam.departure_date != departure:
                        fam.departure_date = departure
                        changed = True
                    if hotel_name and fam.hotel_name != hotel_name:
                        fam.hotel_name = hotel_name
                        changed = True
                    if region_name and fam.region_name != region_name:
                        fam.region_name = region_name
                        changed = True
                    if changed:
                        fam.save(update_fields=["arrival_date", "departure_date", "hotel_name", "region_name"])
                        report.updated_families += 1

                # Traveler уникален в пределах семьи по (last_name, first_name, dob)
                last_name = str(row.get(cols["last_name"], "")).strip()
                first_name = str(row.get(cols["first_name"], "")).strip()
                middle_name = str(row.get(cols.get("middle_name"), "")).strip() if cols.get("middle_name") else ""
                dob = _parse_date(row.get(cols.get("dob"))) if cols.get("dob") else None

                defaults = {
                    "middle_name": middle_name,
                    "nationality": str(row.get(cols.get("nationality"), "")).strip() if cols.get("nationality") else "",
                    "passport": str(row.get(cols.get("passport"), "")).strip() if cols.get("passport") else "",
                    "passport_expiry": _parse_date(row.get(cols.get("passport_expiry"))) if cols.get("passport_expiry") else None,
                    "phone": str(row.get(cols.get("phone"), "")).strip() if cols.get("phone") else "",
                    "email": str(row.get(cols.get("email"), "")).strip() if cols.get("email") else "",
                    "note": str(row.get(cols.get("note"), "")).strip() if cols.get("note") else "",
                }

                # безопасная логика: get_or_create + обновление полей, без вставки дублей
                try:
                    obj, created = Traveler.objects.get_or_create(
                        family=fam,
                        last_name=last_name,
                        first_name=first_name,
                        dob=dob,
                        defaults={k: v for k, v in defaults.items() if v not in (None, "", pd.NaT)},
                    )
                    if created:
                        report.created_travelers += 1
                    else:
                        # обновляем только непустые и изменившиеся поля
                        changed_fields = []
                        for k, v in defaults.items():
                            if v not in (None, "", pd.NaT):
                                cur = getattr(obj, k, None)
                                if cur != v:
                                    setattr(obj, k, v)
                                    changed_fields.append(k)
                        if changed_fields:
                            obj.save(update_fields=changed_fields)

                except IntegrityError:
                    # крайне редко (гонка/нормализация в save) — помечаем как пропуск и едем дальше
                    report.skipped += 1
                    report.issues.append(RowIssue(
                        idx + 2,
                        "Дублирующийся турист (уникальность нарушена)",
                        {"family_id": fam.id, "last_name": last_name, "first_name": first_name, "dob": dob}
                    ))

    if dry_run:
        # сухой прогон откатывает всё
        with transaction.atomic():
            _do()
            transaction.set_rollback(True)
    else:
        _do()

    colmap_human = {k: cols[k] for k in cols if cols[k]}
    return {
        **report.__dict__,
        "column_mapping": colmap_human,
        "issues": [i.__dict__ for i in report.issues],
        "dry_run": dry_run,
    }


# ---------- адаптер для админки ----------

def import_file(up_file: BinaryIO, dry_run: bool = False) -> dict:
    """
    Унифицированный вход, который ожидает админка.
    Возвращает словарь с ключами, которые показываем в сообщении.
    """
    data = up_file.read()
    result = import_tourists_excel(BytesIO(data), dry_run=dry_run)
    return {
        "families_created": int(result.get("created_families", 0)),
        "travelers_created": int(result.get("created_travelers", 0)),
        "skipped": int(result.get("skipped", 0)),
        # "_raw": result  # можно вернуть подробный отчёт при необходимости
    }


```


---

## `backend/sales/services/costasolinfo.py`

```py
# sales/services/costasolinfo.py
from __future__ import annotations

from dataclasses import dataclass
import logging
import requests
from decimal import Decimal, ROUND_HALF_UP
from typing import Any, Dict, Optional, List

import requests
from urllib.parse import urljoin, quote_plus
from django.conf import settings
from django.core.cache import cache

log = logging.getLogger(__name__)


def _money(x) -> float:
    return float(Decimal(str(x or 0)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP))

def _normalize_region_obj(raw: dict | None) -> dict | None:
    if not raw:
        return None
    rid = raw.get("id")
    rslug = raw.get("slug") or raw.get("code") or raw.get("name")
    return {"id": rid, "slug": rslug} if (rid or rslug) else None

# --- Region resolver that survives broken /hotels/<id>/ ----------------------
def _hotel_region(hotel_id: int) -> str | None:
    """
    Возвращает регион (slug) по hotel_id.
    Алгоритм:
      1) /api/hotels/<id>/ → region или region_slug
      2) fallback: /api/hotels/?search=<hotel_name_from_id_or_guess>
         либо просто /api/hotels/?search=<hotel_id> и берём item с совпадающим id
    """
    if not hotel_id:
        return None

    # 1) прямой запрос
    data = _get(f"/hotels/{int(hotel_id)}/", allow_404=True)
    if isinstance(data, dict) and data:
        reg = (data.get("region") or data.get("region_slug") or "").strip()
        if reg:
            return reg

    # 2) фолбэк через поиск: пробуем найти карточку именно с таким id
    try:
        items = search_hotels(str(hotel_id), limit=25)
        items = items if isinstance(items, list) else (items.get("items") or [])
        for it in items:
            try:
                if int(it.get("id") or 0) == int(hotel_id):
                    reg = (it.get("region") or it.get("region_slug") or "").strip()
                    if reg:
                        return reg
            except Exception:
                continue
    except Exception:
        pass

    # 3) ещё одна «мягкая» попытка: поиск по названию, если удастся его вытащить
    #    (иногда /hotels/<id>/ отдаёт только имя)
    try:
        name = ""
        if isinstance(data, dict):
            name = (data.get("name") or data.get("title") or "").strip()
        if name:
            items = search_hotels(name, limit=10)
            items = items if isinstance(items, list) else (items.get("items") or [])
            for it in items:
                if str(it.get("name") or it.get("title") or "").strip().lower() == name.lower():
                    reg = (it.get("region") or it.get("region_slug") or "").strip()
                    if reg:
                        return reg
    except Exception:
        pass

    return None


def _pick_first(*values):
    for v in values:
        if v is not None:
            return v
    return None

def _extract_price_row(row: dict) -> tuple[float, float, str] | None:
    # поддержим разные имена полей
    a = _pick_first(row.get("adult"), row.get("adult_price"), row.get("price_adult"), row.get("adultGross"))
    c = _pick_first(row.get("child"), row.get("child_price"), row.get("price_child"), row.get("childGross"))
    cur = _pick_first(row.get("currency"), row.get("curr"))
    if a is None and c is None:
        return None
    if c is None:
        c = a
    return _money(a), _money(c), (cur or "EUR")

def _excursion_price_for_region(excursion_id: int, region: dict | None) -> tuple[float, float, str] | None:
    detail = _get(f"/excursions/{excursion_id}/", allow_404=True)
    if not detail:
        return None

    # A) prices_by_region: [ {region:{id/slug}, adult/child/currency} ]
    pbr = detail.get("prices_by_region") or detail.get("pricesByRegion") or detail.get("region_prices")
    if isinstance(pbr, list) and region:
        rid = region.get("id")
        rslug = (region.get("slug") or "").lower() if region.get("slug") else None
        for row in pbr:
            r = row.get("region") or {}
            if (rid and r.get("id") == rid) or (rslug and (str(r.get("slug") or "").lower() == rslug)):
                got = _extract_price_row(row)
                if got:
                    return got

    # B) Табличные структуры: {"prices":[{"region":...,"adult_price":...},...]} или {"tariffs":[...]}
    for key in ("prices", "tariffs", "pricing", "price_table"):
        arr = detail.get(key)
        if isinstance(arr, list) and region:
            rid = region.get("id")
            rslug = (region.get("slug") or "").lower() if region.get("slug") else None
            for row in arr:
                r = row.get("region") or {}
                if (rid and r.get("id") == rid) or (rslug and (str(r.get("slug") or "").lower() == rslug)):
                    got = _extract_price_row(row)
                    if got:
                        return got

    # C) Поля вида adult_price_{slug}/child_price_{slug}
    if region and region.get("slug"):
        slug = str(region["slug"]).lower()
        a = detail.get(f"adult_price_{slug}")
        c = detail.get(f"child_price_{slug}")
        if a is not None or c is not None:
            a2 = _money(a if a is not None else c)
            c2 = _money(c if c is not None else a)
            return a2, c2, detail.get("currency", "EUR")

    # D) Базовые без регионов
    a = _pick_first(detail.get("adult_price"), detail.get("price_adult"))
    c = _pick_first(detail.get("child_price"), detail.get("price_child"))
    if a is not None or c is not None:
        a2 = _money(a if a is not None else c)
        c2 = _money(c if c is not None else a)
        return a2, c2, detail.get("currency", "EUR")

    return None



def _base() -> str:
    base = getattr(settings, "CSI_API_BASE", None)
    if not base:
        raise RuntimeError("CSI_API_BASE is not configured. Check .env and settings.py")
    return base.rstrip("/") + "/"


def _get(
    path: str,
    params: Optional[Dict[str, Any]] = None,
    cache_key: Optional[str] = None,
    *,
    cache_seconds: Optional[int] = None,
    allow_404: bool = False,
    timeout: Optional[float] = None,
) -> Any:
    """
    Универсальный GET с таймаутом, кэшированием и аккуратной обработкой ошибок.

    - allow_404=True → 404 не считается ошибкой, возвращаем None
    - cache_seconds: если не задан, используем settings.CSI_CACHE_SECONDS
    - timeout: если не задан, используем settings.CSI_HTTP_TIMEOUT
    """
    url = urljoin(_base(), path.lstrip("/"))

    # аккуратно собираем ключ кэша
    if cache_key:
        key = cache_key
    else:
        params_tuple = tuple(sorted((params or {}).items()))
        key = f"csi::{path}::{params_tuple}"

    cached = cache.get(key)
    if cached is not None:
        return cached

    try:
        resp = requests.get(url, params=params, timeout=timeout or settings.CSI_HTTP_TIMEOUT)

        # мягкая обработка 404 по флагу
        if resp.status_code == 404 and allow_404:
            return None

        resp.raise_for_status()

        try:
            data = resp.json()
        except ValueError:
            # неожиданно не-JSON ответ
            log.exception("CSI GET non-JSON response: %s", url)
            data = {"error": "bad_json"}

        cache.set(key, data, timeout=cache_seconds if cache_seconds is not None else settings.CSI_CACHE_SECONDS)
        return data

    except requests.RequestException as e:
        log.exception("CSI GET failed: %s %s", url, e)
        # если был кэш — его уже вернули выше; здесь возвращаем «мягкую» заглушку
        return {"error": "unavailable", "items": []}


# ==== Конкретные «обёртки» под текущие эндпоинты CostaSolinfo ====

def search_hotels(q: str, limit: int = 10):
    safe_q = quote_plus(q or "")
    cache_key = f"hotels:{safe_q}:{limit}"
    cached = cache.get(cache_key)
    if cached is not None:
        return cached

    try:
        url = urljoin(_base(), "hotels/")
        resp = requests.get(url, params={"search": q, "limit": limit}, timeout=settings.CSI_HTTP_TIMEOUT)
        resp.raise_for_status()
        data = resp.json()
    except requests.RequestException:
        log.exception("CSI search_hotels failed")
        data = {"items": []}

    cache.set(cache_key, data, timeout=60)
    return data


def transfer_schedule(hotel_id: int, date: str, type_: str = "group"):
    params = {"hotel_id": hotel_id, "date": date, "type": type_}
    return _get("transfer-schedule/", params)


def transfer_content(slug: str, lang: str = "ru"):
    params = {"lang": lang}
    return _get(f"transfer-content/{slug}/", params)


def list_excursions(lang: str = "ru", date: str | None = None, region: str | None = None):
    params = {"lang": lang}
    if date:
        params["date"] = date
    if region:
        params["region"] = region
    return _get("excursions/", params)


def excursion_detail(excursion_id: int, lang: str = "ru"):
    params = {"lang": lang}
    return _get(f"excursions/{excursion_id}/", params)


def excursion_title(excursion_id: int, lang: str = "ru") -> str:
    data = excursion_detail(excursion_id, lang) or {}
    return data.get("localized_title") or data.get("title") or ""


@dataclass
class PickupItem:
    id: int
    point: str
    time: Optional[str]  # "HH:MM" or None
    lat: Optional[float] = None
    lng: Optional[float] = None
    direction: Optional[str] = None  # e.g. "to_gibraltar" / "to_malaga"


def _num(x, default=None):
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default

def _pick(raw, *names, cast=float):
    """Достаёт первое непустое поле из списка имён и приводит тип."""
    for n in names:
        if n in raw and raw[n] is not None:
            try:
                return cast(raw[n])
            except Exception:
                try:
                    return cast(str(raw[n]).replace(',', '.'))
                except Exception:
                    return None
    return None

class CSIClient:
    def __init__(self,
                 base: Optional[str] = None,
                 timeout: Optional[float] = None,
                 cache_seconds: Optional[int] = None):
        self.base = (base or getattr(settings, "CSI_API_BASE", "")).rstrip("/")
        self.timeout = timeout or getattr(settings, "CSI_HTTP_TIMEOUT", 8.0)
        self.cache_seconds = cache_seconds if cache_seconds is not None else getattr(settings, "CSI_CACHE_SECONDS", 60)

    # --- internal helpers -------------------------------------------------
    def _get_json(self, url: str, params: Dict[str, Any] | None = None) -> Any:
        resp = requests.get(url, params=params or {}, timeout=self.timeout)
        resp.raise_for_status()
        return resp.json()

    def excursion_title(self, excursion_id: int, lang: str = "ru") -> str | None:
        if not self.base:
            return None
        try:
            url = f"{self.base}/excursions/{excursion_id}/"
            data = self._get_json(url, params={"lang": lang})
            return data.get("title") or data.get("localized_title") or data.get("name")
        except Exception:
            return None

    def _normalize_time(self, value: Any) -> Optional[str]:
        """Return HH:MM if possible; otherwise None."""
        if not value:
            return None
        s = str(value).strip().replace(".", ":")
        parts = s.split(":")
        if len(parts) >= 2 and parts[0].isdigit() and parts[1].isdigit():
            hh = int(parts[0])
            mm = int(parts[1])
            if 0 <= hh <= 23 and 0 <= mm <= 59:
                return f"{hh:02d}:{mm:02d}"
        return None

    def _normalize_pickup(self, raw: Dict[str, Any]) -> PickupItem:
        pid = raw.get("id") or raw.get("pk") or raw.get("pickup_id")
        point = raw.get("point") or raw.get("name") or raw.get("pickup_point") or "Pickup"

        time_val = raw.get("time") or raw.get("pickup_time") or raw.get("departure")
        lat = raw.get("lat") or raw.get("latitude")
        lng = raw.get("lng") or raw.get("longitude")
        direction = raw.get("direction")

        # ← новые варианты названий полей с ценами
        price_adult = _pick(
            raw,
            "price_adult", "adult_price", "price_adult_eur", "priceA", "price", "adult",
            cast=float
        )
        price_child = _pick(
            raw,
            "price_child", "child_price", "price_child_eur", "priceC", "child",
            cast=float
        )

        try:
            pid = int(pid) if pid is not None else 0
        except Exception:
            pid = 0

        item = PickupItem(
            id=pid,
            point=str(point).strip(),
            time=self._normalize_time(time_val),
            lat=float(lat) if lat is not None else None,
            lng=float(lng) if lng is not None else None,
            direction=str(direction) if direction else None,
        )
        # положим как атрибуты, чтобы их увидел pricing_quote
        item.price_adult = price_adult
        item.price_child = price_child
        return item

    # --- public API -------------------------------------------------------
    def excursion_pickup(self, excursion_id: int, hotel_id: int) -> dict | None:
        if not self.base:
            raise RuntimeError("CSI_API_BASE is not configured")

        pickup_url = f"{self.base}/excursions/{excursion_id}/pickup/"
        try:
            raw = self._get_json(pickup_url, params={"hotel_id": hotel_id})
            if not isinstance(raw, dict) or ("id" not in raw and "name" not in raw):
                return None

            item = {
                "id": raw.get("id"),
                "name": raw.get("name"),
                "lat": float(raw["lat"]) if raw.get("lat") is not None else None,
                "lng": float(raw["lng"]) if raw.get("lng") is not None else None,
                "time": raw.get("time"),
                "price_adult": _pick(raw, "price_adult", "adult_price", "price_adult_eur", "priceA", "price", "adult"),
                "price_child": _pick(raw, "price_child", "child_price", "price_child_eur", "priceC", "child"),
            }

            title = self.excursion_title(excursion_id, lang=getattr(settings, "LANGUAGE_CODE", "ru"))
            if title:
                item["excursion_title"] = title

            return item
        except requests.HTTPError as e:
            if e.response is not None and e.response.status_code == 404:
                return None
            raise

    def excursion_pickups(self, excursion_id: int, hotel_id: Optional[int], date: str) -> List[Dict[str, Any]]:
        """
        Эмулируем список пикапов на дату. Сейчас источник отдаёт одну точку для (excursion, hotel).
        """
        if not hotel_id:
            return []
        one = self.excursion_pickup(excursion_id, hotel_id)
        if not one:
            return []
        return [{
            "id": one.get("id"),
            "point": one.get("name") or one.get("point") or "Pickup",
            "time": one.get("time"),
            "lat": one.get("lat"),
            "lng": one.get("lng"),
            "direction": one.get("direction"),
            "price_adult": one.get("price_adult"),
            "price_child": one.get("price_child"),
        }]

    # --- pricing -----------------------------------------------------------
    def excursion_pricing(self,
                          excursion_id: int,
                          adults: int,
                          children: int,
                          infants: int,
                          region: str | None = None,
                          company_id: int | None = None,
                          lang: str = "ru") -> dict:
        """
        Тянем котировку из основной базы.
        Пробуем основной эндпоинт /api/excursions/{id}/pricing/,
        а затем несколько запасных вариантов. Возвращаем нормализованный dict.
        """
        if not self.base:
            raise RuntimeError("CSI_API_BASE is not configured")

        params = {
            "adults": adults,
            "children": children,
            "infants": infants,
            "lang": lang
        }
        if region:
            params["region"] = region
        if company_id is not None:
            params["company_id"] = company_id

        # список возможных url (на случай, если в старой админке другой роут)
        candidates = [
            f"{self.base}/excursions/{excursion_id}/pricing/",
            f"{self.base}/excursions/{excursion_id}/quote/",
            f"{self.base}/excursions/{excursion_id}/price/",
        ]

        data = None
        last_exc = None
        for url in candidates:
            try:
                data = self._get_json(url, params=params)
                break
            except requests.HTTPError as e:
                last_exc = e
                # если 404 — пробуем следующий кандидат
                if e.response is not None and e.response.status_code == 404:
                    continue
                else:
                    raise
            except Exception as e:
                last_exc = e
                continue

        if data is None:
            # ничего не нашли — мягкий фолбэк
            return {
                "ok": False,
                "gross": 0.0,
                "currency": "EUR",
                "net": None,
                "commission": None,
                "per_adult": None,
                "per_child": None,
                "raw": {"error": str(last_exc) if last_exc else "no-data"}
            }

        # разные сериализаторы отдают разные ключи — аккуратно вытащим общие поля
        currency = (data.get("currency")
                    or data.get("curr")
                    or data.get("code")
                    or "EUR")

        gross = (_num(data.get("gross"))
                 or _num(data.get("total"))
                 or _num(data.get("price_total"))
                 or 0.0)

        net = (_num(data.get("net"))
               or _num(data.get("netto"))
               or None)

        commission = (_num(data.get("commission"))
                      or _num(data.get("comm"))
                      or (gross - net if (gross is not None and net is not None) else None))

        per_adult = (_num(data.get("price_adult"))
                     or _num(data.get("adult_price"))
                     or None)

        per_child = (_num(data.get("price_child"))
                     or _num(data.get("child_price"))
                     or None)

        return {
            "ok": True if gross else False,
            "gross": float(gross or 0.0),
            "currency": str(currency),
            "net": net,
            "commission": commission,
            "per_adult": per_adult,
            "per_child": per_child,
            "raw": data,  # полезно для отладки в DEV
        }


# --- модульные врапперы -----------------------------------------------------

class NotFoundError(Exception):
    pass

def _to_money(x) -> float:
    if x is None:
        return 0.0
    d = Decimal(str(x)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
    return float(d)

def pricing_quote(
    excursion_id: int,
    adults: int,
    children: int,
    infants: int,
    lang: str | None = None,
    hotel_id: int | None = None,
    hotel_name: str | None = None,
    date: str | None = None,
    region_override: dict | None = None,
    **_
) -> dict:
    """
    Возвращает {"gross": float, "currency": "EUR", "meta": {...}}.
    Порядок: (1) CSI-котировщик → (2) PICKUP v2 → (3) REGION.
    """

    # 1) Попытка через CSI (если когда-нибудь появится рабочая ручка)
    try:
        data = _get(
            f"/excursions/{excursion_id}/pricing/",
            params={
                "adults": adults,
                "children": children,
                "infants": infants,
                "lang": lang or "ru",
                "hotel_id": hotel_id,
                "date": date,
            },
            allow_404=True,
        )
        if isinstance(data, dict) and "gross" in data:
            return {
                "gross": _money(data.get("gross")),
                "currency": data.get("currency", "EUR"),
                "meta": {
                    "adult_price": _money((data.get("breakdown") or {}).get("adult_price")),
                    "child_price": _money((data.get("breakdown") or {}).get("child_price")),
                    "source": "CSI",
                    "excursion_id": excursion_id,
                    "hotel_id": hotel_id,
                    "date": date,
                },
            }
    except Exception:
        pass

    # 2) PICKUP v2: считаем из цены точки сбора на конкретную дату
    try:
        pickups = get_client().excursion_pickups(
            excursion_id=excursion_id,
            hotel_id=hotel_id,
            date=date or "",
        )
    except Exception:
        pickups = []

    if pickups:
        p = pickups[0]
        adult_price = _money(p.get("price_adult"))
        child_price = _money(p.get("price_child") if p.get("price_child") is not None else adult_price)
        gross = _money(adult_price * adults + child_price * children)
        return {
            "gross": gross,
            "currency": p.get("currency") or "EUR",
            "meta": {
                "adult_price": adult_price,
                "child_price": child_price,
                "source": "PICKUP",
                "excursion_id": excursion_id,
                "hotel_id": hotel_id,
                "date": date,
            },
        }

    # 3) REGION-фолбэк: берём цены экскурсии для региона отеля (или оверрайд)
    if region_override and (region_override.get("id") or region_override.get("slug")):
        region = {"id": region_override.get("id"), "slug": region_override.get("slug")}
    elif hotel_id:
        region = _hotel_region(hotel_id)
    else:
        region = None

    prices = _excursion_price_for_region(excursion_id, region)
    if prices:
        a, c, cur = prices
        gross = _money(a * adults + c * children)
        return {
            "gross": gross,
            "currency": cur or "EUR",
            "meta": {
                "adult_price": _money(a),
                "child_price": _money(c),
                "source": "REGION",
                "region": region,
                "excursion_id": excursion_id,
                "hotel_id": hotel_id,
                "date": date,
            },
        }

    raise NotFoundError("Pricing not available (no pickup and no CSI quote).")


# Factory (single place to construct client)
_client: Optional[CSIClient] = None


def get_client() -> CSIClient:
    global _client
    if _client is None:
        _client = CSIClient()
    return _client


def excursion_pickups(excursion_id: int, hotel_id: Optional[int], date: str):
    return get_client().excursion_pickups(excursion_id=excursion_id, hotel_id=hotel_id, date=date)


def excursion_pickup(excursion_id: int, hotel_id: int):
    return get_client().excursion_pickup(excursion_id, hotel_id)


def excursion_pickup_once(excursion_id: int, hotel_id: int) -> dict | None:
    """Возвращает одну точку сбора для пары (excursion, hotel) или None.
    Нормализует поля цен в ключи price_adult / price_child (float)."""
    url = urljoin(_base(), f"excursions/{excursion_id}/pickup/")
    try:
        resp = requests.get(
            url,
            params={"hotel_id": hotel_id},
            timeout=settings.CSI_HTTP_TIMEOUT,
        )
        if resp.status_code == 404:
            return None
        resp.raise_for_status()
        data = resp.json()
        if not isinstance(data, dict):
            return None

        def _num(v):
            if v is None or v == "":
                return None
            try:
                return float(v)
            except Exception:
                try:
                    return float(str(v).replace(",", "."))
                except Exception:
                    return None

        def _pick(raw, *names):
            for n in names:
                if n in raw and raw[n] not in (None, ""):
                    val = _num(raw[n])
                    if val is not None:
                        return val
            return None

        # Нормализуем цены к единому виду
        pa = _pick(data, "price_adult", "adult_price", "price_adult_eur", "priceA", "price", "adult")
        pc = _pick(data, "price_child", "child_price", "price_child_eur", "priceC", "child")

        data["price_adult"] = pa
        data["price_child"] = pc

        return data

    except requests.RequestException:
        log.exception("CSI excursion_pickup_once failed: %s", url)
        return None



def _safe_float(x, default=None):
    try:
        if x is None: return default
        return float(x)
    except Exception:
        return default


```


---

## `backend/sales/services/emails.py`

```py
# sales/services/emails.py
from __future__ import annotations

import logging
import re
from functools import lru_cache
from typing import Any, Dict, List, Optional

from django.apps import apps
from django.conf import settings
from django.core.mail import EmailMultiAlternatives
from django.template.loader import render_to_string
from django.utils.html import strip_tags

from sales.services.titles import compose_bilingual_title, spanish_excursion_name

log = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Модели по ленивому доступу (чтобы не ломать импорт, если порядок app'ов меняется)
Traveler = apps.get_model("sales", "Traveler")

# ---------------------------------------------------------------------------
# Попытка использовать единый сервис испанских названий.
# Если файла sales/services/titles.py пока нет — используем встроенный fallback.
try:
    from sales.services.titles import spanish_excursion_name as _spanish_excursion_name  # type: ignore
    _HAS_TITLES_SERVICE = True
except Exception:
    _HAS_TITLES_SERVICE = False

    # --- Fallback: извлекаем ES-имя (core -> CSI -> эвристика) ----------------
    from sales.services import costasolinfo as csi  # локальный импорт, чтобы не тянуть при старте

    _EMOJI_OR_MISC = re.compile(r"[\u2600-\u27BF\U0001F300-\U0001FAFF]")
    TOPONYM_RU_ES = {
        "севилья": "Sevilla",
        "гибралтар": "Gibraltar",
        "кордоба": "Córdoba",
        "ронда": "Ronda",
        "танжер": "Tánger",
        "каминито дель рей": "Caminito del Rey",
        "нерха и фрихилиана": "Nerja y Frigiliana",
        "королевская тропа": "Caminito del Rey",
    }

    def _strip_to_toponym(ru_title: str) -> str:
        s = (ru_title or "").strip()
        s = _EMOJI_OR_MISC.sub("", s)
        s = re.split(r"[—\-:]", s, maxsplit=1)[0].strip()
        s = re.sub(r"[\(\)\[\]«»\"']", "", s).strip()
        return s

    @lru_cache(maxsize=512)
    def _title_in_lang(excursion_id: int, lang: str) -> str:
        try:
            return csi.excursion_title(excursion_id, lang=lang) or ""
        except Exception:
            return ""

    @lru_cache(maxsize=512)
    def _title_es_from_core_any(excursion_id: int, ru_title: str) -> str:
        """
        Достаём испанское имя из core.Excursion.name (колонка «Экскурсия»).
        Стратегии:
          1) core.Excursion(csi_id=excursion_id).name
          2) core.Excursion(id=excursion_id).name
          3) core.ExcursionContentBlock(excursion__csi_id=excursion_id).excursion.name
          4) по топониму: ищем core.Excursion.name ~ 'Sevilla', 'Ronda', ...
        """
        try:
            CoreExcursion = apps.get_model("core", "Excursion")
        except Exception:
            CoreExcursion = None
            log.warning("emails: core.Excursion model not found")

        try:
            CoreBlock = apps.get_model("core", "ExcursionContentBlock")
        except Exception:
            CoreBlock = None

        # 1) по csi_id
        if CoreExcursion and excursion_id:
            name = (CoreExcursion.objects
                    .filter(csi_id=excursion_id)
                    .values_list("name", flat=True)
                    .first())
            if name:
                return name

        # 2) safety-net: по внутреннему id
        if CoreExcursion and excursion_id:
            name = (CoreExcursion.objects
                    .filter(id=excursion_id)
                    .values_list("name", flat=True)
                    .first())
            if name:
                return name

        # 3) через контент-блок
        if CoreBlock and excursion_id:
            name = (CoreBlock.objects
                    .filter(excursion__csi_id=excursion_id)
                    .values_list("excursion__name", flat=True)
                    .first())
            if name:
                return name

        # 4) по топониму из русского
        base_ru = _strip_to_toponym(ru_title)
        guess_es = TOPONYM_RU_ES.get((base_ru or "").lower())
        if CoreExcursion and guess_es:
            # точное совпадение
            name = (CoreExcursion.objects
                    .filter(name__iexact=guess_es)
                    .values_list("name", flat=True)
                    .first())
            if name:
                return name
            # contains
            name = (CoreExcursion.objects
                    .filter(name__icontains=guess_es)
                    .values_list("name", flat=True)
                    .first())
            if name:
                return name

        log.info("emails: ES title not found in core (exc_id=%s, ru='%s')", excursion_id, ru_title)
        return ""

    @lru_cache(maxsize=1024)
    def _spanish_excursion_name(excursion_id: int, ru_title: str) -> str:
        """
        Fallback-реализация spanish_excursion_name:
          1) core.Excursion.name
          2) CSI API (lang='es'), укорачиваем по разделителю
          3) эвристика: топоним из RU и словарь
        """
        es_core = _title_es_from_core_any(excursion_id, ru_title)
        if es_core:
            return es_core

        es_api = _title_in_lang(excursion_id, "es") if excursion_id else ""
        if es_api:
            short = re.split(r"[—:]", es_api, maxsplit=1)[0].strip()
            return short or es_api

        base_ru = _strip_to_toponym(ru_title)
        lower = base_ru.lower()
        for key in sorted(TOPONYM_RU_ES.keys(), key=len, reverse=True):
            if key in lower:
                return TOPONYM_RU_ES[key]
        return base_ru

# Публичная обёртка: не привязываемся к наличию внешнего сервиса
def spanish_excursion_name(excursion_id: int, ru_title: str) -> str:
    try:
        return _spanish_excursion_name(int(excursion_id or 0), ru_title or "")
    except Exception:
        # если вообще всё пошло не так — вернём хотя бы RU
        return (ru_title or "").strip()


# ---------------------------------------------------------------------------
# Прочие утилиты

def _fmt_date(d) -> str:
    """Человекочитаемая дата для темы письма. Без локали — безопасно."""
    try:
        return d.strftime("%d.%m.%Y") if d else ""
    except Exception:
        return str(d or "")

def _maps_url_for(booking) -> Optional[str]:
    """Формируем стабильный Google Maps URL из координат или названия точки/отеля."""
    from urllib.parse import quote
    lat = getattr(booking, "pickup_lat", None)
    lng = getattr(booking, "pickup_lng", None)
    if lat is not None and lng is not None:
        return f"https://maps.google.com/?q={str(lat).strip()},{str(lng).strip()}"
    q = (getattr(booking, "pickup_point_name", None) or getattr(booking, "hotel_name", None) or "").strip()
    return f"https://maps.google.com/?q={quote(q)}" if q else None

def _special_key(title: Optional[str]) -> Optional[str]:
    s = (title or "").lower()
    if "tang" in s or "танж" in s:
        return "tangier"
    if "granad" in s or "грана" in s:
        return "granada"
    if "gibr" in s or "гибр" in s:
        return "gibraltar"
    if "sevil" in s or "севил" in s:
        return "seville"
    return None

def _parse_travelers_csv(csv: str) -> List[int]:
    return [int(p) for p in str(csv or "").split(",") if p.strip().isdigit()]

def _collect_travelers(booking) -> List[Dict[str, Any]]:
    """Вытягиваем пассажиров из CSV id → список словарей, сохраняя исходный порядок."""
    ids = _parse_travelers_csv(getattr(booking, "travelers_csv", ""))
    if not ids:
        return []
    rows = (
        Traveler.objects
        .filter(id__in=ids)
        .values(
            "id", "first_name", "last_name",
            "passport", "nationality",
            "dob", "gender", "doc_type", "doc_expiry", "passport_expiry",
        )
    )
    by_id = {r["id"]: r for r in rows}
    out: List[Dict[str, Any]] = []
    for i in ids:
        r = by_id.get(i)
        if not r:
            continue
        out.append({
            "id": i,
            "first_name": r.get("first_name") or "",
            "last_name":  r.get("last_name")  or "",
            "passport":   r.get("passport")   or "",
            "nationality":r.get("nationality")or "",
            "dob":            (r["dob"].isoformat() if r.get("dob") else ""),
            "gender":         r.get("gender") or "",
            "doc_type":       r.get("doc_type") or "",
            "doc_expiry":     (r["doc_expiry"].isoformat() if r.get("doc_expiry") else ""),
            "passport_expiry":(r["passport_expiry"].isoformat() if r.get("passport_expiry") else ""),
        })
    return out

def _build_common_ctx(booking) -> Dict[str, Any]:
    """Единая сборка контекста для шаблонов брони/аннуляции."""
    title_es = spanish_excursion_name(
        int(getattr(booking, "excursion_id", 0) or 0),
        getattr(booking, "excursion_title", "") or ""
    )

    title_bi_html  = compose_bilingual_title(getattr(booking, "excursion_title", ""), title_es, html=True)
    title_bi_plain = compose_bilingual_title(getattr(booking, "excursion_title", ""), title_es, html=False)

    return {
        "booking": {
            "title_es":           title_es,
            "excursion_title":    getattr(booking, "excursion_title", ""),  # fallback
            "title_bi_html":  title_bi_html,
            "title_bi_plain": title_bi_plain,
            "excursion_language": getattr(booking, "excursion_language", ""),
            "date":               (getattr(booking, "date", None).isoformat() if getattr(booking, "date", None) else ""),
            "company":            getattr(booking, "company", None),
            "booking_code":       getattr(booking, "booking_code", ""),
            "hotel_name":         getattr(booking, "hotel_name", ""),
            "room_number":        getattr(booking, "room_number", ""),
            "adults":             getattr(booking, "adults", 0),
            "children":           getattr(booking, "children", 0),
            "infants":            getattr(booking, "infants", 0),
            "pickup_point_name":  getattr(booking, "pickup_point_name", ""),
            "pickup_time_str":    getattr(booking, "pickup_time_str", ""),
            "pickup_address":     getattr(booking, "pickup_address", ""),
            "pickup_lat":         getattr(booking, "pickup_lat", None),
            "pickup_lng":         getattr(booking, "pickup_lng", None),
            "maps_url":           _maps_url_for(booking),
        },
        "travelers":  _collect_travelers(booking),
        "special_key":_special_key(getattr(booking, "excursion_title", "")),
    }

# ---------------------------------------------------------------------------
# Отправка писем

def send_booking_email(booking, *, subject_prefix: str = "[SalesPortal]") -> bool:
    """
    Письмо-заявка/бронирование в офис партнёра.
    Возвращает True, если письмо успешно передано SMTP-бэкенду.
    """
    # Кому шлём
    to: List[str] = []
    company = getattr(booking, "company", None)
    comp_email = getattr(company, "email_for_orders", None)
    if comp_email:
        to.append(comp_email)

    fallback_to = getattr(settings, "BOOKINGS_FALLBACK_EMAIL", None)
    if not to and fallback_to:
        to.append(fallback_to)
    if not to:
        log.warning("send_booking_email: no recipients for booking_code=%s", getattr(booking, "booking_code", ""))
        return True  # не считаем ошибкой: просто некуда отправлять

    ctx = _build_common_ctx(booking)
    html = render_to_string("sales/email_reservation.html", ctx)
    text = strip_tags(html)

    title_es = ctx["booking"].get("title_es") or ctx["booking"].get("excursion_title") or ""
    when = _fmt_date(getattr(booking, "date", None))
    who = (getattr(getattr(booking, "company", None), "name", "")
           or getattr(getattr(booking, "guide", None), "get_full_name", lambda: "")()
           or "").strip() or "—"

    subject = f"{subject_prefix} Reserva de {who} — {title_es} — {when} — {getattr(booking, 'booking_code', '')}"
    subject = re.sub(r"\s+", " ", subject).strip()

    from_email = getattr(settings, "DEFAULT_FROM_EMAIL", "no-reply@example.com")
    msg = EmailMultiAlternatives(subject=subject, body=text, from_email=from_email, to=to)
    msg.attach_alternative(html, "text/html")

    try:
        sent = msg.send(fail_silently=False)
        return bool(sent)
    except Exception:
        log.exception("send_booking_email failed for booking_code=%s", getattr(booking, "booking_code", ""))
        return False


def send_cancellation_email(booking, reason: str = "", *, subject_prefix: str = "[SalesPortal]") -> bool:
    """
    Письмо-Аннуляция в офис партнёра.
    """
    to: List[str] = []
    company = getattr(booking, "company", None)
    comp_email = getattr(company, "email_for_orders", None)
    if comp_email:
        to.append(comp_email)

    fallback_to = getattr(settings, "BOOKINGS_FALLBACK_EMAIL", None)
    if not to and fallback_to:
        to.append(fallback_to)
    if not to:
        log.warning("send_cancellation_email: no recipients for booking_code=%s", getattr(booking, "booking_code", ""))
        return True

    ctx = _build_common_ctx(booking)
    ctx["reason"] = reason or ""

    title_es = ctx["booking"].get("title_es") or ctx["booking"].get("excursion_title") or ""
    when = _fmt_date(getattr(booking, "date", None))
    comp_or_guide = (getattr(getattr(booking, "company", None), "name", None)
                     or getattr(getattr(booking, "guide", None), "get_full_name", lambda: "")()
                     or "—")

    subject = f"{subject_prefix} Cancelación — Reserva de {comp_or_guide}: {title_es} · {when} · {getattr(booking, 'booking_code', '')}"
    subject = re.sub(r"\s+", " ", subject).strip()

    html = render_to_string("sales/email_cancellation.html", ctx)
    text = strip_tags(html)
    from_email = getattr(settings, "DEFAULT_FROM_EMAIL", "no-reply@example.com")

    msg = EmailMultiAlternatives(subject=subject, body=text, from_email=from_email, to=to)
    msg.attach_alternative(html, "text/html")
    try:
        return bool(msg.send(fail_silently=False))
    except Exception:
        log.exception("send_cancellation_email failed for booking_code=%s", getattr(booking, "booking_code", ""))
        return False

```


---

## `backend/sales/services/netto.py`

```py
# sales/services/netto.py
from decimal import Decimal, ROUND_HALF_UP
from django.utils import timezone
from sales.models import ExcursionNetPrice

def _in_range(rec, d):
    if not d: return True
    if rec.valid_from and d < rec.valid_from: return False
    if rec.valid_to   and d > rec.valid_to:   return False
    return True

def resolve_net_prices(*, company_id: int|None, excursion_id: int, region_slug: str|None, date=None):
    """
    Возвращает словарь:
      {'currency':'EUR','net_adult':Decimal,'net_child':Decimal}
    Ищет в порядке приоритета: company+region → company → any+region → any.
    Берёт актуальную запись по дате.
    """
    qs = ExcursionNetPrice.objects.filter(is_active=True, excursion_id=excursion_id)
    region_slug = (region_slug or '').strip().lower()
    today = date or timezone.now().date()

    # кандидаты по убыванию специфичности
    candidates = list(qs.filter(company_id=company_id, region_slug=region_slug)) + \
                 list(qs.filter(company_id=company_id, region_slug='')) + \
                 list(qs.filter(company_id__isnull=True, region_slug=region_slug)) + \
                 list(qs.filter(company_id__isnull=True, region_slug=''))

    # сначала по дате, затем «самая свежая» valid_from
    best = None
    for rec in candidates:
        if not _in_range(rec, today): 
            continue
        if best is None or (rec.valid_from or today) > (best.valid_from or today):
            best = rec

    if not best:
        return None

    cur = best.currency or 'EUR'
    net_adult = Decimal(best.net_per_adult)
    if best.net_per_child is not None:
        net_child = Decimal(best.net_per_child)
    else:
        disc = Decimal(best.child_discount_pct or 0) / Decimal(100)
        net_child = (net_adult * (Decimal(1) - disc)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

    return {"currency": cur, "net_adult": net_adult, "net_child": net_child}

```


---

## `backend/sales/services/titles.py`

```py
# backend/sales/services/titles.py
from __future__ import annotations

import logging
import re
from functools import lru_cache

from django.apps import apps

log = logging.getLogger(__name__)

# -----------------------------------------------------------------------------
# CSI (API) title helper

@lru_cache(maxsize=512)
def csi_title_in_lang(excursion_id: int, lang: str) -> str:
    """Пробуем получить название экскурсии из внешнего CSI в нужной локали."""
    if not excursion_id:
        return ""
    try:
        # Локальный импорт, чтобы модуль не ронялся при старте проекта без CSI.
        from sales.services import costasolinfo as csi  # type: ignore
        return (csi.excursion_title(excursion_id, lang=lang) or "").strip()
    except Exception:
        return ""

# -----------------------------------------------------------------------------
# CORE -> ES lookup (через наши модели контента)

@lru_cache(maxsize=512)
def core_es_title_by_ids(excursion_id: int) -> str:
    """
    Пытаемся достать испанское имя из core разными путями:
      1) core.Excursion(csi_id=excursion_id).name
      2) core.Excursion(id=excursion_id).name           (safety-net)
      3) core.ExcursionContentBlock(excursion__csi_id=excursion_id).excursion.name
    """
    if not excursion_id:
        return ""

    try:
        CoreExcursion = apps.get_model("core", "Excursion")
    except Exception:
        CoreExcursion = None

    try:
        CoreBlock = apps.get_model("core", "ExcursionContentBlock")
    except Exception:
        CoreBlock = None

    # 1) по csi_id
    if CoreExcursion:
        name = (
            CoreExcursion.objects
            .filter(csi_id=excursion_id)
            .values_list("name", flat=True)
            .first()
        )
        if name:
            return str(name).strip()

        # 2) safety-net: по внутреннему id
        name = (
            CoreExcursion.objects
            .filter(id=excursion_id)
            .values_list("name", flat=True)
            .first()
        )
        if name:
            return str(name).strip()

    # 3) через контентный блок
    if CoreBlock:
        name = (
            CoreBlock.objects
            .filter(excursion__csi_id=excursion_id)
            .values_list("excursion__name", flat=True)
            .first()
        )
        if name:
            return str(name).strip()

    return ""

# -----------------------------------------------------------------------------
# Эвристика: RU -> ES по топонимам

_EMOJI_OR_MISC = re.compile(r"[\u2600-\u27BF\U0001F300-\U0001FAFF]")

TOPONYM_RU_ES = {
    "севилья": "Sevilla",
    "гибралтар": "Gibraltar",
    "кордоба": "Córdoba",
    "ронда": "Ronda",
    "танжер": "Tánger",
    "каминито дель рей": "Caminito del Rey",
    "нерха и фрихилиана": "Nerja y Frigiliana",
    "королевская тропа": "Caminito del Rey",
}

def _strip_to_toponym(ru_title: str) -> str:
    s = (ru_title or "").strip()
    s = _EMOJI_OR_MISC.sub("", s)
    # Берём основу до первого длинного тире/дефиса/двоеточия
    s = re.split(r"[—\-:]", s, maxsplit=1)[0].strip()
    # Убираем кавычки/скобки
    s = re.sub(r"[\(\)\[\]«»\"']", "", s).strip()
    return s

# -----------------------------------------------------------------------------
# Публичные функции

@lru_cache(maxsize=1024)
def spanish_excursion_name(excursion_id: int, ru_title: str) -> str:
    """
    Единая точка получения «испанского» названия:
      1) core.Excursion.name
      2) CSI API (lang='es'), укоротим по разделителю
      3) эвристика: выжать топоним из RU и замапить словарём
    """
    # 1) CORE
    es = core_es_title_by_ids(int(excursion_id or 0))
    if es:
        return es

    # 2) CSI (es)
    es_api = csi_title_in_lang(int(excursion_id or 0), "es")
    if es_api:
        short = re.split(r"[—:]", es_api, maxsplit=1)[0].strip()
        return short or es_api

    # 3) Эвристика RU -> ES
    base_ru = _strip_to_toponym(ru_title or "")
    low = base_ru.lower()
    for k in sorted(TOPONYM_RU_ES.keys(), key=len, reverse=True):
        if k in low:
            return TOPONYM_RU_ES[k]
    # Если ничего не нашли — возвращаем очищенную RU-основу или исходное RU
    return base_ru or (ru_title or "")

# --- Backward compatibility -------------------------------------------------
def excursion_title_es(excursion_id: int, ru_title: str) -> str:
    """
    Старое имя функции, которое используется в templatetags и шаблонах.
    Делегирует в spanish_excursion_name.
    """
    return spanish_excursion_name(excursion_id, ru_title)

__all__ = ["spanish_excursion_name", "excursion_title_es"]


def compose_bilingual_title(ru_title: str | None, es_title: str | None, *, html: bool = True) -> str:
    ru = (ru_title or "").strip()
    es = (es_title or "").strip()
    if not es or es.lower() == ru.lower():
        return ru
    if html:
        return f'{ru} <span class="es-title">({es})</span>'
    return f"{ru} ({es})"


```


---

## `backend/sales/tests.py`

```py
from django.test import TestCase

# Create your tests here.

```


---

## `backend/templates/admin/sales/excursionnetprice/change_list.html`

```html
{% extends "admin/change_list.html" %}
{% load static %}

{% block object-tools-items %}
  {{ block.super }}
  <li>
    <a class="button" href="{% url 'admin:sales_netprice_matrix' %}">
      Матрица нетто-цен
    </a>
  </li>
{% endblock %}

```


---

## `backend/templates/admin/sales/familybooking/change_list.html`

```html
{% extends "admin/change_list.html" %}
{% load i18n %}

{% block object-tools-items %}
  {{ block.super }}
  <li>
    <a class="addlink" href="{% url 'admin:sales_familybooking_import' %}">
      Импорт туристов
    </a>
  </li>
{% endblock %}

```


---

## `backend/templates/admin/sales/familybooking/import_form.html`

```html
{% extends "admin/base_site.html" %}

{% block content %}
  <div class="content">
    <h1>{{ title }}</h1>
    <form method="post" enctype="multipart/form-data" novalidate>
      {% csrf_token %}
      <fieldset class="module aligned">
        <div class="form-row">
          <label for="id_file">{{ form.file.label }}:</label>
          {{ form.file }}
          {% if form.file.errors %}<div class="errors">{{ form.file.errors }}</div>{% endif %}
        </div>
        <div class="form-row">
          <label for="id_dry_run">{{ form.dry_run.label }}:</label>
          {{ form.dry_run }}
          {% if form.dry_run.errors %}<div class="errors">{{ form.dry_run.errors }}</div>{% endif %}
        </div>
      </fieldset>
      <div class="submit-row">
        <input type="submit" class="default" value="Запустить импорт">
        <a href="{% url 'admin:sales_familybooking_changelist' %}" class="button">Отмена</a>
      </div>
    </form>
  </div>
{% endblock %}

```


---

## `backend/templates/admin/sales/net_prices_matrix.html`

```html
{% extends "admin/base_site.html" %}
{% load extras %}

{% load static %}
{% net_saved saved ex.id reg sel_company|default_if_none:0 as row %}


{% block content %}
<h1>Матрица нетто-цен</h1>

<form method="get" style="margin-bottom: 12px;">
  <label>Компания:&nbsp;</label>
  <select name="company" onchange="this.form.submit()">
    <option value="">— для всех компаний —</option>
    {% for c in companies %}
      <option value="{{ c.id }}" {% if sel_company == c.id %}selected{% endif %}>{{ c.name }}</option>
    {% endfor %}
  </select>
</form>

<form method="post" novalidate>
  {% csrf_token %}
  <div class="results">
    <table class="table table-striped" style="min-width: 960px;">
      <thead>
        <tr>
          <th>Экскурсия</th>
          <th>Регион</th>
          <th>Нетто (взрослый)</th>
          <th>Нетто (ребёнок)</th>
        </tr>
      </thead>
      <tbody>
        {% for ex in excursions %}
          {% for reg in ex.region_slugs %}
            {% net_saved saved ex.id reg sel_company|default_if_none:0 as row %}
            <tr>
              {% if forloop.first %}
                <td rowspan="{{ ex.region_slugs|length }}">
                  <strong>{{ ex.title }}</strong><br>
                  <small>ex#{{ ex.id }}</small>
                </td>
              {% endif %}
              <td><code>{{ reg }}</code></td>
              <td>
                <input type="text"
                       name="price-{{ ex.id }}-{{ reg }}-adult"
                       value="{{ row.net_per_adult|default_if_none:'' }}"
                       class="vTextField"
                       style="width:120px;">
              </td>
              <td>
                <input type="text"
                       name="price-{{ ex.id }}-{{ reg }}-child"
                       value="{{ row.net_per_child|default_if_none:'' }}"
                       class="vTextField"
                       style="width:120px;">
              </td>
            </tr>
          {% endfor %}
        {% empty %}
          <tr><td colspan="4" class="warning">Нет данных по экскурсиям.</td></tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <div style="margin-top:12px;">
    <button type="submit" class="button default">Сохранить</button>
    <a href="{% url 'admin:sales_excursionnetprice_changelist' %}" class="button">Назад к списку</a>
  </div>
</form>
{% endblock %}

```


---

## `backend/templates/sales/email_cancellation.html`

```html
<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Solicitud de anulación</title>
</head>
<body style="font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#111827;">
  <div style="max-width:760px;margin:0 auto;padding:16px;">
    <h2 style="margin:0 0 12px 0;">Solicitud de anulación de reserva</h2>

    <div style="margin:8px 0 14px 0;padding:10px;border:1px solid #ef4444;border-radius:8px;background:#fee2e2;">
      Por favor, anulen la reserva indicada abajo y confirmen la anulación por correo.
      {% if reason %}<div style="margin-top:6px;"><b>Motivo:</b> {{ reason }}</div>{% endif %}
    </div>

    <table cellpadding="0" cellspacing="0" style="border-collapse:collapse;width:100%;font-size:14px;margin:0 0 12px 0;">
      <tr>
        <td style="padding:4px 0;width:40%;color:#6b7280;">Excursión:</td>
        <td style="padding:4px 0;">
          <b>{{ booking.title_es|default:booking.excursion_title }}</b>
          {% if booking.excursion_language %} ({{ booking.excursion_language|upper }}){% endif %}
        </td>
      </tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Fecha:</td><td style="padding:4px 0;">{{ booking.date|default:"—" }}</td></tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Compañía:</td><td style="padding:4px 0;">{{ booking.company.name|default:"—" }}</td></tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Order ID:</td><td style="padding:4px 0;">{{ booking.booking_code|default:"—" }}</td></tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Hotel:</td><td style="padding:4px 0;">{{ booking.hotel_name|default:"—" }} · Habitación: {{ booking.room_number|default:"—" }}</td></tr>
      <tr>
        <td style="padding:4px 0;color:#6b7280;">Pasajeros:</td>
        <td style="padding:4px 0;">Adultos: {{ booking.adults|default:"0" }}, Niños: {{ booking.children|default:"0" }}, Infantes: {{ booking.infants|default:"0" }}</td>
      </tr>
    </table>

    <div style="margin:12px 0 16px 0; padding:10px; border:1px solid #e5e7eb; border-radius:8px;">
      <div style="font-weight:600;margin-bottom:6px;">Punto de recogida</div>
      <div style="font-size:14px;line-height:1.4;">
        {{ booking.pickup_point_name|default:"—" }}<br>
        Hora: <b>{{ booking.pickup_time_str|default:"—" }}</b><br>
        Dirección: {{ booking.pickup_address|default:"—" }}<br>
        {% if booking.maps_url %}
          <a href="{{ booking.maps_url }}">Abrir el mapa</a>
        {% elif booking.pickup_lat and booking.pickup_lng %}
          <a href="https://maps.google.com/?q={{ booking.pickup_lat }},{{ booking.pickup_lng }}">Abrir en el mapa</a>
        {% else %}
          <span style="color:#6b7280;">Enlace no disponible</span>
        {% endif %}
      </div>
    </div>

    {% if travelers %}
      <table cellpadding="6" cellspacing="0" border="1" style="border-collapse:collapse;font-size:14px;width:100%;">
        <thead style="background:#f9fafb;">
          <tr>
            <th align="left">Apellido</th>
            <th align="left">Nombre</th>
            <th align="left">Pasaporte</th>
            <th align="left">Nacionalidad</th>
            <th align="left">Fecha de nacimiento</th>
          </tr>
        </thead>
        <tbody>
          {% for t in travelers %}
            <tr>
              <td>{{ t.last_name|default:"—" }}</td>
              <td>{{ t.first_name|default:"—" }}</td>
              <td>{{ t.passport|default:"—" }}</td>
              <td>{{ t.nationality|default:"—" }}</td>
              <td>{{ t.dob|default:"—" }}</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    {% endif %}
  </div>
</body>
</html>

```


---

## `backend/templates/sales/email_reservation.html`

```html
{# backend/templates/sales/email_reservation.html #}
<!doctype html>
<html lang="es">
<head><meta charset="utf-8"><title>Reserva de excursión</title></head>
<body style="font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#111827;">
  <div style="max-width:760px;margin:0 auto;padding:16px;">
    <h2 style="margin:0 0 12px 0;">Reserva de excursión</h2>

    <table cellpadding="0" cellspacing="0" style="border-collapse:collapse;width:100%;font-size:14px;margin:0 0 12px 0;">
      <tr>
        <td style="padding:4px 0;width:40%;color:#6b7280;">Excursión:</td>
        <td style="padding:4px 0;">
          <b>{{ booking.title_es|default:booking.title_bi_html|safe }}</b>
          {% if booking.excursion_language %} ({{ booking.excursion_language|upper }}){% endif %}
        </td>
      </tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Fecha:</td>
          <td style="padding:4px 0;">{{ booking.date|default:"—" }}</td></tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Compañía:</td>
          <td style="padding:4px 0;">{{ booking.company.name|default:"—" }}</td></tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Order ID:</td>
          <td style="padding:4px 0;">{{ booking.booking_code|default:"—" }}</td></tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Hotel:</td>
          <td style="padding:4px 0;">{{ booking.hotel_name|default:"—" }} · Habitación: {{ booking.room_number|default:"—" }}</td></tr>
      <tr><td style="padding:4px 0;color:#6b7280;">Pasajeros:</td>
          <td style="padding:4px 0;">Adultos: {{ booking.adults|default:"0" }}, Niños: {{ booking.children|default:"0" }}, Infantes: {{ booking.infants|default:"0" }}</td></tr>
    </table>

    <div style="margin:12px 0 16px 0; padding:10px; border:1px solid #e5e7eb; border-radius:8px;">
      <div style="font-weight:600;margin-bottom:6px;">Punto de recogida</div>
      <div style="font-size:14px;line-height:1.4;">
        {{ booking.pickup_point_name|default:"—" }}<br>
        Hora: <b>{{ booking.pickup_time_str|default:"—" }}</b><br>
        Dirección: {{ booking.pickup_address|default:"—" }}<br>
        {% if booking.maps_url %}
          <a href="{{ booking.maps_url }}">Abrir el mapa</a>
        {% elif booking.pickup_lat and booking.pickup_lng %}
          <a href="https://maps.google.com/?q={{ booking.pickup_lat }},{{ booking.pickup_lng }}">Abrir en el mapa</a>
        {% else %}
          <span style="color:#6b7280;">Enlace no disponible</span>
        {% endif %}
      </div>
    </div>

    {% with key=special_key %}
      {% if not key %}
        {% for t in travelers|slice:":1" %}
          <div style="margin:8px 0 0 0;font-size:14px;">
            Apellido y nombre: <b>{{ t.last_name|default:"" }} {{ t.first_name|default:"" }}</b>
          </div>
        {% empty %}{% endfor %}
      {% else %}
        <table cellpadding="6" cellspacing="0" border="1" style="border-collapse:collapse; font-size:14px; width:100%;">
          <thead style="background:#f9fafb;">
            <tr>
              <th align="left">Apellido</th>
              <th align="left">Nombre</th>
              {% if key == "granada" or key == "tangier" or key == "seville" %}<th align="left">Pasaporte</th>{% endif %}
              {% if key == "granada" or key == "gibraltar" or key == "tangier" or key == "seville" %}<th align="left">Nacionalidad</th>{% endif %}
              {% if key == "seville" or key == "tangier" %}<th align="left">Fecha de nacimiento</th>{% endif %}
              {% if key == "tangier" %}<th align="left">Género</th><th align="left">Tipo de documento</th><th align="left">Fecha de caducidad</th>{% endif %}
            </tr>
          </thead>
          <tbody>
            {% for t in travelers %}
              <tr>
                <td>{{ t.last_name|default:"—" }}</td>
                <td>{{ t.first_name|default:"—" }}</td>
                {% if key == "granada" or key == "tangier" or key == "seville" %}<td>{{ t.passport|default:"—" }}</td>{% endif %}
                {% if key == "granada" or key == "gibraltar" or key == "tangier" or key == "seville" %}<td>{{ t.nationality|default:"—" }}</td>{% endif %}
                {% if key == "seville" or key == "tangier" %}<td>{{ t.dob|default:"—" }}</td>{% endif %}
                {% if key == "tangier" %}<td>{{ t.gender|default:"—" }}</td><td>{{ t.doc_type|default:"—" }}</td><td>{{ t.doc_expiry|default:t.passport_expiry|default:"—" }}</td>{% endif %}
              </tr>
            {% empty %}
              <tr><td colspan="8" style="color:#6b7280;">No hay participantes</td></tr>
            {% endfor %}
          </tbody>
        </table>
      {% endif %}
    {% endwith %}
  </div>
</body>
</html>

```


---

## `backend/templates/sales/ticket.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<style>
/* ОДНА СТРАНИЦА НУЖНОЙ ВЫСОТЫ ПОД ЛЕНТУ 72 мм */
@page { size: 72mm {{ page_h_mm }}mm; margin: 6mm; }

/* Базовые сбросы + запрет разрывов страниц */
html, body { margin: 0; padding: 0; }
* {
  break-inside: avoid;           /* современный */
  page-break-inside: avoid;      /* старые движки */
}
.ticket, h1, .row, .guests, .guests .name, .qr2, .qrbox, .footer { 
  break-inside: avoid;
  page-break-inside: avoid;
}

/* БАЗА (укрупнено) */
body  { font-family: "DejaVu Sans", sans-serif; font-size: 32px; line-height: 1.35; color: #000; }
.ticket { width: 100%; border-top: 1px solid #999; padding-top: 6px; }

/* ЛОГО */
.logo { text-align: center; margin-bottom: 6px; }
.logo img { max-width: 300px; max-height: 100px; object-fit: contain; }

/* ЗАГОЛОВОК ЭКСКУРСИИ */
h1 { font-size: 40px; font-weight: 700; text-align: center; margin: 0 0 6px; }

/* Код бронирования */
.booking {
  text-align: center;
  font-size: 30px;
  font-weight: 800;
  margin: 6px 0 4px;
  letter-spacing: 0.5px;
}
.booking .code {
  font-family: "DejaVu Sans Mono", "DejaVu Sans", monospace;
}

/* СТРОКИ */
.row { margin-bottom: 4px; }
.label { font-weight: 800; }
.row, .label { word-break: break-word; }

/* ГОСТИ — крупно и жирно */
.hr { border-top: 1px solid #999; margin: 8px 0; }
.guests { margin-top: 4px; }
.guests .label { display: block; margin-bottom: 4px; font-size: 28px; }
.guests .name {
  display: block;
  font-size: 30px;
  font-weight: 800;
  margin-bottom: 2px;
}

/* ДВА QR РЯДОМ */
.qr2   { display: flex; justify-content: space-between; gap: 8px; margin-top: 10px; }
.qrbox { width: 48%; text-align: center; }
.qrbox img { width: 250px; height: 250px; }  /* 203 dpi хватает для сканирования */
.caption { font-size: 25px; margin-top: 2px; font-weight: 700; }
.small   { font-size: 16px; color: #333; word-break: break-all; }

/* НИЗ БИЛЕТА — крупнее подпись + благодарность */
.footer {
  text-align: center;
  margin-top: 5px;
  border-top: 1px dashed #aaa;
  padding-top: 3px;
}
.footer .show   { font-size: 26px; font-weight: 800; margin-bottom: 4px; }
.footer .thanks { font-size: 22px; font-style: italic; }
</style>
</head>
<body>
  <div class="ticket">
    <!-- ЛОГОТИП -->
    <div class="logo">
      <img src="{{ logo_url }}" alt="CostaSolinfo">
    </div>

    <h1>{{ title_en }}</h1>

    <div class="booking">
      Booking No: <span class="code">{{ b.booking_code }}</span>
    </div>

    <div class="row"><span class="label">Date:</span> {{ date_en }}</div>
    <div class="row"><span class="label">Language:</span> {{ b.excursion_language }}</div>
    <div class="row"><span class="label">Company:</span> {{ b.company.name }}</div>
    <div class="row"><span class="label">Hotel:</span> {{ b.hotel_name }}</div>
    <div class="row"><span class="label">Pickup:</span> {{ b.pickup_time_str }}</div>
    <div class="row">
      <span class="label">Adults:</span> {{ b.adults }}
      &nbsp; <span class="label">Children:</span> {{ b.children }}
      &nbsp; <span class="label">Infants:</span> {{ b.infants|default:0 }}
    </div>

    {% if travelers and travelers|length > 0 %}
      <div class="hr"></div>
      <div class="row guests">
        <span class="label">Guests:</span>
        {% for full in travelers %}
          <span class="name">{{ full }}</span>
        {% endfor %}
      </div>
    {% endif %}

    <!-- ДВА QR: сайт и точка сбора -->
    <div class="qr2">
      <div class="qrbox">
        <img src="{{ qr_site }}" alt="QR Website">
        <div class="caption">Website</div>
      </div>
      <div class="qrbox">
        <img src="{{ qr_maps }}" alt="QR Pickup">
        <div class="caption">Pickup point</div>
      </div>
    </div>

    <div class="footer">
      <div class="show">Show this ticket to the guide</div>
      <div class="thanks">Thank you for choosing CostaSolinfo! Have a wonderful excursion.</div>
    </div>
  </div>
</body>
</html>

```


---

## `backend/templates/sales/tourists_import.html`

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>Импорт туристов</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; max-width:980px; }
    .row { margin:12px 0; }
    table { border-collapse: collapse; width:100%; margin-top:10px; }
    th, td { border:1px solid #e5e7eb; padding:8px; font-size:14px; }
    th { background:#f9fafb; text-align:left; }
    .ok { color:#065f46; } .warn { color:#92400e; } .err { color:#991b1b; }
    .messages { margin: 12px 0; }
  </style>
</head>
<body>
  <h1>Импорт туристов (Excel/CSV)</h1>

  <div class="messages">
    {% if messages %}
      {% for m in messages %}
        <div class="{{ m.tags }}">{{ m }}</div>
      {% endfor %}
    {% endif %}
  </div>

  <div class="card">
    <form method="post" enctype="multipart/form-data">
      {% csrf_token %}
      <div class="row">
        {{ form.file.label_tag }}<br>
        {{ form.file }}
        <div style="font-size:12px;color:#6b7280">{{ form.file.help_text }}</div>
      </div>
      <div class="row">
        <label>{{ form.dry_run }} {{ form.dry_run.label }}</label>
      </div>
      <div class="row">
        <button type="submit">Загрузить</button>
      </div>
    </form>
  </div>

  {% if report %}
    <h2>Отчёт</h2>
    <div class="card">
      <p>Лист: <b>{{ report.sheet }}</b></p>
      <p>Строк всего: {{ report.total_rows }}</p>
      <p>Семей создано: {{ report.created_families }},
         обновлено: {{ report.updated_families }},
         туристов создано: {{ report.created_travelers }}</p>

      <h3>Сопоставление колонок</h3>
      <table>
        <thead><tr><th>Поле</th><th>Колонка в файле</th></tr></thead>
        <tbody>
          {% for k,v in report.column_mapping.items %}
            <tr><td>{{ k }}</td><td>{{ v }}</td></tr>
          {% endfor %}
        </tbody>
      </table>

      {% if report.issues and report.issues|length > 0 %}
        <h3>Замечания</h3>
        <table>
          <thead><tr><th>#</th><th>Сообщение</th><th>Данные</th></tr></thead>
          <tbody>
            {% for it in report.issues %}
              <tr>
                <td>{{ it.rownum }}</td>
                <td>{{ it.message }}</td>
                <td><pre style="white-space:pre-wrap">{{ it.payload|default:"" }}</pre></td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      {% endif %}
    </div>
  {% endif %}
</body>
</html>

```
