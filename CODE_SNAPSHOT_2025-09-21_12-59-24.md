# Code snapshot (2025-09-21T12:59:24)



---

## `backend/manage.py`

```py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```


---

## `backend/sales_portal/settings.py`

```py
"""
Django settings for sales_portal project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

import os
from pathlib import Path
from dotenv import load_dotenv
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

CSI_API_MODE = os.getenv("CSI_API_MODE", "prod")
CSI_API_BASE = os.getenv("CSI_API_BASE_PROD") if CSI_API_MODE == "prod" else os.getenv("CSI_API_BASE_LOCAL")
CSI_HTTP_TIMEOUT = float(os.getenv("CSI_HTTP_TIMEOUT", "6"))
CSI_CACHE_SECONDS = int(os.getenv("CSI_CACHE_SECONDS", "60"))

CSI = {
    "MODE": CSI_API_MODE,
    "BASE": CSI_API_BASE,
    "HTTP_TIMEOUT": CSI_HTTP_TIMEOUT,
    "CACHE_SECONDS": CSI_CACHE_SECONDS,
    "TOKEN": os.getenv("CSI_API_TOKEN", ""),
}


# Простой локальный кэш (на проде можно поменять на Redis)
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "salesportal-cache",
        "TIMEOUT": CSI_CACHE_SECONDS,
        "KEY_FUNCTION": "sales.cache.make_key",  # <— вот это
    }
}

REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
        "rest_framework.parsers.FormParser",
        "rest_framework.parsers.MultiPartParser",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        # позже добавим JWT, если понадобится
    ],
}

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "console": {"class": "logging.StreamHandler"},
    },
    "loggers": {
        "django": {"handlers": ["console"], "level": "INFO"},
        "sales": {"handlers": ["console"], "level": "DEBUG"},  # наш app
        "requests": {"handlers": ["console"], "level": "WARNING"},
    },
}



# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv(
    "SECRET_KEY",
    "django-insecure-#zl=j@4t*mj1s^hy*o5nb@+jbg_od^=+bq25)jd%a)_jb6z@1y"
)

DEBUG = os.getenv("DEBUG", "1") == "1"
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "").split(",") if not DEBUG else []

# Безопасные куки и заголовки — зависят от DEBUG:
if DEBUG:
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
    # Локально редирект на HTTPS не нужен
    # SECURE_SSL_REDIRECT = False
else:
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
    # Включим редирект на HTTPS на проде (раскомментируй при готовности):
    # SECURE_SSL_REDIRECT = True


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    "rest_framework",
    "corsheaders",
    "sales",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOW_ALL_ORIGINS = True  # ок для dev
CORS_ALLOW_CREDENTIALS = True

CSRF_TRUSTED_ORIGINS = [
    "http://127.0.0.1:3000",
    "http://localhost:3000",
]

ROOT_URLCONF = 'sales_portal.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# TEMPLATES
TEMPLATES[0]["DIRS"] = [BASE_DIR / "templates"]  # был пустой список

WSGI_APPLICATION = 'sales_portal.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "sales_portal.sqlite3",
    },
    # Разкомментируем, если понадобится прямой доступ к старой БД:
    # "legacy": {
    #     "ENGINE": "django.db.backends.sqlite3",
    #     "NAME": "/Users/vladimir_hirko/Documents/CostaSolinfo/backend/db.sqlite3",
    #     "OPTIONS": {"timeout": 20},
    # }
}

DATA_UPLOAD_MAX_MEMORY_SIZE = 20 * 1024 * 1024  # 20 MB
FILE_UPLOAD_MAX_MEMORY_SIZE = 20 * 1024 * 1024


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'ru'

TIME_ZONE = 'Europe/Madrid'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

# Static / Media
STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"           # пригодится на проде
STATICFILES_DIRS = [BASE_DIR / "static"]         # если положишь кастомные стили/скрипты

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

```


---

## `backend/sales_portal/urls.py`

```py
# backend/sales_portal/urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

# используем health из sales.views_api
from sales import views_api as api

urlpatterns = [
    path('admin/', admin.site.urls),
    path("api/health/", api.health),        # /api/health/ → один источник
    path("api/sales/", include("sales.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

```


---

## `backend/sales_portal/wsgi.py`

```py
"""
WSGI config for sales_portal project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')

application = get_wsgi_application()

```


---

## `backend/sales_portal/asgi.py`

```py
"""
ASGI config for sales_portal project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')

application = get_asgi_application()

```


---

## `backend/sales/apps.py`

```py
from django.apps import AppConfig


class SalesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'sales'

```


---

## `backend/sales/models.py`

```py
# backend/sales/models.py
from django.db import models
from django.contrib.auth.models import User
import re


# ↓ ДОБАВИМ справочник языков (используем на уровне брони)
LANG_CHOICES = (
    ("ru", "Русский"),
    ("en", "English"),
    ("es", "Español"),
    ("de", "Deutsch"),
)

PRICE_SOURCE = (
    ("PICKUP", "По данным pickup/v2"),
    ("REGION", "По региональным ценам"),
    ("MANUAL", "Указано вручную"),
)

# ───────────────────────────────────────────────────────────────────────────────
# utils
def _norm_name(s: str) -> str:
    """Убрать лишние пробелы, привести к Title Case. Пустое -> ''."""
    s = (s or "").strip()
    s = re.sub(r"\s+", " ", s)
    return s.title()


# ───────────────────────────────────────────────────────────────────────────────
class Company(models.Model):
    name = models.CharField(max_length=120)
    slug = models.SlugField(unique=True)
    email_for_orders = models.EmailField(blank=True, null=True)
    is_active = models.BooleanField(default=True)
    def __str__(self): return self.name


class GuideProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    companies = models.ManyToManyField(Company, blank=True)
    def __str__(self): return self.user.get_username()


class BookingSale(models.Model):
    STATUS = [
        ("DRAFT","DRAFT"),                # ← новый
        ("PENDING","PENDING"),
        ("HOLD","HOLD"),
        ("PAID","PAID"),
        ("CANCELLED","CANCELLED"),
        ("EXPIRED","EXPIRED"),
    ]

    company = models.ForeignKey(Company, on_delete=models.PROTECT)
    guide = models.ForeignKey(User, on_delete=models.PROTECT)

    family = models.ForeignKey(
        'FamilyBooking', on_delete=models.SET_NULL,
        null=True, blank=True, related_name="bookings"
    )

    # внешние справочники (снэпшоты)
    excursion_id = models.IntegerField()
    excursion_title = models.CharField(max_length=255, blank=True)

    hotel_id = models.IntegerField(null=True, blank=True)
    hotel_name = models.CharField(max_length=255, blank=True)
    region_name = models.CharField(max_length=120, blank=True)

    pickup_point_id = models.IntegerField(null=True, blank=True)
    pickup_point_name = models.CharField(max_length=255, blank=True)
    pickup_time_str = models.CharField(max_length=16, blank=True)

    # NEW: география точки сбора (снапшот)
    pickup_lat = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
    pickup_lng = models.DecimalField(max_digits=9, decimal_places=6, null=True, blank=True)
    pickup_address = models.CharField(max_length=255, blank=True)  # если приходит от источника

    # состав группы (любой простой формат; если SQLite — храним CSV)
    travelers_csv = models.TextField(blank=True)  # "12,15,33"  (упрощение для SQLite)

    status = models.CharField(max_length=10, choices=STATUS, default="DRAFT")  # ← по умолчанию draft

    # для батч-отправки
    batch_code = models.CharField(max_length=20, blank=True)  # сгруппировать несколько строк
    sent_at = models.DateTimeField(null=True, blank=True)     # когда ушло в офис
    sent_to_email = models.EmailField(blank=True)

    # ↓ НОВОЕ: язык экскурсии, выбранный туристом (обязателен для письма)
    excursion_language = models.CharField(
        max_length=5, choices=LANG_CHOICES, blank=True
    )
    # ↓ НОВОЕ: номер комнаты (заполняется вручную на фронте)
    room_number = models.CharField(max_length=20, blank=True)

    # ↓ НОВОЕ: фиксируем источник и «пер-голова» цены на момент брони
    price_source = models.CharField(
        max_length=10, choices=PRICE_SOURCE, default="PICKUP"
    )
    price_per_adult = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    price_per_child = models.DecimalField(max_digits=10, decimal_places=2, default=0)

    date = models.DateField()
    adults = models.PositiveIntegerField(default=1)
    children = models.PositiveIntegerField(default=0)
    infants = models.PositiveIntegerField(default=0)

    gross_total = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    net_total = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    commission = models.DecimalField(max_digits=10, decimal_places=2, default=0)

    status = models.CharField(max_length=10, choices=STATUS, default="PENDING")
    payment_method = models.CharField(max_length=30, blank=True)
    booking_code = models.CharField(max_length=20, unique=True)

    created_at = models.DateTimeField(auto_now_add=True)

    def maps_url(self):
        if self.pickup_lat and self.pickup_lng:
            return f"https://maps.google.com/?q={self.pickup_lat},{self.pickup_lng}"
        if self.pickup_point_name:
            from urllib.parse import quote_plus
            return "https://maps.google.com/?q=" + quote_plus(self.pickup_point_name)
        return ""

    class Meta:
        indexes = [
            models.Index(fields=["company", "date"]),
            models.Index(fields=["excursion_id", "date"]),
            models.Index(fields=["excursion_language"]),
        ]

    def __str__(self): return f"{self.booking_code} / {self.company}"


class FamilyBooking(models.Model):
    ref_code = models.CharField("Номер брони/заявки", max_length=64, db_index=True, blank=True)
    hotel_id = models.IntegerField()
    hotel_name = models.CharField(max_length=255, blank=True)
    region_name = models.CharField(max_length=120, blank=True)

    arrival_date = models.DateField(null=True, blank=True)
    departure_date = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=64, blank=True)
    email = models.EmailField(blank=True)
    comment = models.TextField(blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=["hotel_id", "arrival_date"]),
            models.Index(fields=["ref_code"]),
        ]
        ordering = ["-arrival_date", "hotel_name"]

    def __str__(self):
        return f"{self.ref_code or '—'} @ {self.hotel_name}"


class Traveler(models.Model):
    family = models.ForeignKey(FamilyBooking, on_delete=models.CASCADE, related_name="travelers")
    first_name = models.CharField(max_length=64)
    last_name  = models.CharField(max_length=64)
    middle_name = models.CharField(max_length=64, blank=True)
    dob = models.DateField("Дата рождения", null=True, blank=True)
    nationality = models.CharField(max_length=64, blank=True)
    passport = models.CharField(max_length=64, blank=True)
    passport_expiry = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=64, blank=True)
    email = models.EmailField(blank=True)
    note = models.CharField(max_length=255, blank=True)

    class Meta:
        unique_together = [("family", "last_name", "first_name", "dob")]
        indexes = [
            models.Index(fields=["family", "last_name", "first_name", "dob"]),
            models.Index(fields=["last_name", "first_name", "dob"]),
        ]

    def save(self, *args, **kwargs):
        self.last_name = _norm_name(self.last_name)
        self.first_name = _norm_name(self.first_name)
        self.middle_name = _norm_name(self.middle_name)
        super().save(*args, **kwargs)

    def __str__(self): return f"{self.last_name} {self.first_name}"

```


---

## `backend/sales/admin.py`

```py
# sales/admin.py
from django.contrib import admin, messages
from django.template.response import TemplateResponse
from django.urls import path
from django.shortcuts import redirect

from .models import Company, GuideProfile, BookingSale, FamilyBooking, Traveler
from .forms import TouristsImportForm
from .importers import tourists_excel  # импортёр Excel

# ── BookingSale ─────────────────────────────────────────────────────────────────
@admin.register(BookingSale)
class BookingSaleAdmin(admin.ModelAdmin):
    list_display = (
        "booking_code", "company", "excursion_title", "date",
        "hotel_name", "pickup_point_name", "pickup_time_str",
        "excursion_language", "room_number",
        "adults", "children", "gross_total", "status",
    )
    list_filter = ("company", "status", "excursion_language", "date")
    search_fields = ("booking_code", "excursion_title", "hotel_name",
                     "pickup_point_name", "room_number")
    readonly_fields = ("created_at",)

    actions = ["export_bookings_xlsx"]

    def export_bookings_xlsx(self, request, queryset):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Bookings"

        cols = [
            ("Booking code", "booking_code"),
            ("Company", lambda o: o.company.name if o.company_id else ""),
            ("Date", "date"),
            ("Excursion", "excursion_title"),
            ("Hotel", "hotel_name"),
            ("Pickup name", "pickup_point_name"),
            ("Pickup time", "pickup_time_str"),
            ("Pickup lat", "pickup_lat"),
            ("Pickup lng", "pickup_lng"),
            ("Pickup address", "pickup_address"),
            ("Maps URL", lambda o: o.maps_url()),
            ("Adults", "adults"),
            ("Children", "children"),
            ("Gross", "gross_total"),
            ("Language", "excursion_language"),
            ("Room", "room_number"),
            ("Created at", "created_at"),
        ]

        # шапка
        for i,(title,_) in enumerate(cols, start=1):
            ws.cell(row=1, column=i, value=title)

        # строки
        r = 2
        for obj in queryset:
            for c,(title,field) in enumerate(cols, start=1):
                if callable(field):
                    val = field(obj)
                else:
                    val = getattr(obj, field, "")
                ws.cell(row=r, column=c, value=val)
            r += 1

        # автоподбор ширины
        for i in range(1, len(cols)+1):
            ws.column_dimensions[get_column_letter(i)].width = 18

        resp = HttpResponse(
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
        resp['Content-Disposition'] = 'attachment; filename="bookings.xlsx"'
        wb.save(resp)
        return resp

    export_bookings_xlsx.short_description = "Экспортировать выбранные брони в Excel"
    
# ── FamilyBooking ──────────────────────────────────────────────────────────────
@admin.register(FamilyBooking)
class FamilyBookingAdmin(admin.ModelAdmin):
    list_display = ("ref_code", "hotel_name", "arrival_date", "departure_date", "created_at")
    search_fields = ("ref_code", "hotel_name", "region_name", "phone", "email")
    list_filter = ("arrival_date", "region_name")

    # кнопка «Импорт туристов» на change_list
    change_list_template = "admin/sales/familybooking/change_list.html"

    def get_urls(self):
        urls = super().get_urls()
        custom = [
            path(
                "import/",
                self.admin_site.admin_view(self.import_view),
                name="sales_familybooking_import",
            ),
        ]
        return custom + urls

    def import_view(self, request):
        if not self.has_add_permission(request):
            messages.error(request, "Недостаточно прав для импорта.")
            return redirect("admin:sales_familybooking_changelist")

        context = dict(self.admin_site.each_context(request), title="Импорт туристов")

        if request.method == "POST":
            form = TouristsImportForm(request.POST, request.FILES)
            if form.is_valid():
                up_file = form.cleaned_data.get("file")
                dry = bool(form.cleaned_data.get("dry_run", False))
                try:
                    result = tourists_excel.import_file(up_file, dry_run=dry)
                    families = result.get("families_created", 0)
                    travelers = result.get("travelers_created", 0)
                    skipped = result.get("skipped", 0)
                    msg = f"Семей: {families}, туристов: {travelers}, пропущено: {skipped}."
                    messages.success(
                        request,
                        ("Проверка прошла успешно. " if dry else "Импорт завершён. ") + msg
                    )
                    return redirect("admin:sales_familybooking_changelist")
                except Exception as e:
                    messages.error(request, f"Ошибка импорта: {e}")
            else:
                messages.error(request, f"Проверьте форму: {form.errors.as_text()}")
        else:
            form = TouristsImportForm()

        context["form"] = form
        return TemplateResponse(request, "admin/sales/familybooking/import_form.html", context)

# ── Traveler ───────────────────────────────────────────────────────────────────
@admin.register(Traveler)
class TravelerAdmin(admin.ModelAdmin):
    list_display = ("last_name", "first_name", "dob", "family")
    search_fields = ("last_name", "first_name", "passport", "email", "phone")
    list_filter = ("dob",)

# ── Прочие справочники (одиночная регистрация, без дублей) ─────────────────────
@admin.register(Company)
class CompanyAdmin(admin.ModelAdmin):
    list_display = ("name", "slug", "email_for_orders", "is_active")
    search_fields = ("name", "slug", "email_for_orders")
    list_filter = ("is_active",)

@admin.register(GuideProfile)
class GuideProfileAdmin(admin.ModelAdmin):
    list_display = ("user",)
    search_fields = ("user__username", "user__email")

```


---

## `backend/sales/urls.py`

```py
# backend/sales/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter

from . import views_api as v
from .views_pages import tourists_import_page   # ← добавили

router = DefaultRouter()
router.register(r"companies", v.CompanyViewSet, basename="company")

app_name = "sales"

urlpatterns = [
    # Health
    path("health/", v.health, name="health"),

    # HTML-страницы
    path("import/tourists/", tourists_import_page, name="tourists_import_page"),  # ← используем прямую функцию

    # Публичные API
    path("login/", v.login_view, name="login"),
    path("hotels/", v.hotels, name="hotels"),
    path("tourists/", v.tourists, name="tourists"),
    path("families/<int:fam_id>/", v.family_detail, name="family_detail"),
    path("excursions/", v.excursions, name="excursions"),

    # Пикапы
    path("pickups/v2/", v.SalesExcursionPickupsView.as_view(), name="pickups_v2"),
    path("pickups/", v.pickups, name="pickups"),

    # Калькуляция цены
    path("pricing/quote/", v.pricing_quote_view, name="pricing_quote"),

    # Отладка
    path("debug/csi-base/", v.debug_csi_base, name="debug_csi_base"),
    path("debug/pricing-sig/", v.pricing_debug_signature, name="debug_pricing_sig"),
    path("debug/hotel-region/", v.debug_hotel_region, name="debug_hotel_region"),
    path("debug/excursion-prices/", v.debug_excursion_prices, name="debug_excursion_prices"),
    path("debug/raw/hotel/", v.debug_raw_hotel, name="debug_raw_hotel"),
    path("debug/raw/excursion/", v.debug_raw_excursion, name="debug_raw_excursion"),

    # DRF router (companies)
    path("", include(router.urls)),

    # Бронирования (боевые)
    path("bookings/create/", v.BookingCreateView.as_view(), name="booking-create"),
    path("bookings/", v.BookingListView.as_view(), name="booking-list"),
    path("bookings/family/<int:fam_id>/drafts/", v.FamilyBookingDraftsView.as_view(), name="family-drafts"),
    path("bookings/batch/preview/", v.BookingBatchPreviewView.as_view(), name="bookings-batch-preview"),
    path("bookings/batch/send/", v.BookingBatchSendView.as_view(), name="bookings-batch-send"),

]

```


---

## `backend/sales/views_api.py`

```py
# sales/views_api.py
from collections import defaultdict
from datetime import date
import datetime as dt
from django.db.models import Q
from django.conf import settings
from django.contrib.auth import get_user_model
from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse
from django.views.decorators.http import require_GET
from django.views.decorators.csrf import csrf_exempt
from django.utils.dateparse import parse_date
from django.utils.decorators import method_decorator
from sales.services.costasolinfo import NotFoundError
from .services import costasolinfo as csi
from .services.costasolinfo import get_client, pricing_quote
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.decorators import api_view, permission_classes, authentication_classes
from rest_framework.views import APIView
from rest_framework import status, viewsets
from .models import FamilyBooking, Traveler, Company, BookingSale
from .serializers import CompanySerializer, BookingSaleCreateSerializer, BookingSaleListSerializer
import re, html
import requests
import logging
import inspect

WEEKDAYS = ["mon","tue","wed","thu","fri","sat","sun"]

def _resolve_user(request):
    """ Dev-fallback: если нет аутентификации — берём первого активного. """
    u = getattr(request, "user", None)
    if u and getattr(u, "is_authenticated", False):
        return u
    User = get_user_model()
    return (
        User.objects.filter(is_active=True)
        .order_by("-is_superuser", "-is_staff", "id")
        .first()
    )

def _normalize_name(s: str) -> str:
    """Убираем лишнее и приводим к нижнему регистру для сравнения."""
    s = (s or "").strip().lower()
    s = re.sub(r"\s+", " ", s)
    return s

def _resolve_hotel_id_by_name(hotel_name: str) -> int | None:
    """
    Ищет hotel_id в CSI по названию отеля.
    Приоритет: точное совпадение → начинается с → первый результат.
    """
    if not hotel_name:
        return None

    try:
        res = csi.search_hotels(hotel_name, limit=10)
        items = res if isinstance(res, list) else (res.get("items") or [])
        if not items:
            return None

        target = _normalize_name(hotel_name)
        # 1) точное совпадение
        for it in items:
            name = _normalize_name(it.get("name") or it.get("title") or "")
            if name == target:
                return int(it.get("id"))

        # 2) начинается с
        for it in items:
            name = _normalize_name(it.get("name") or it.get("title") or "")
            if name.startswith(target) or target.startswith(name):
                return int(it.get("id"))

        # 3) первый адекватный
        for it in items:
            if it.get("id"):
                return int(it["id"])
    except Exception:
        pass
    return None

def _weekday_slug(date_str: str) -> str | None:
    # Делает парсер терпимым: обрезаем мусор, берём только YYYY-MM-DD
    try:
        s = (date_str or "").strip()[:10]
        d = dt.date.fromisoformat(s)
        return WEEKDAYS[d.weekday()]  # 0=mon ... 6=sun
    except Exception:
        return None


@api_view(["GET"])
@permission_classes([AllowAny])
def debug_hotel_region(request):
    """Показывает, какой регион видит CSI для данного hotel_id."""
    hotel_id_raw = request.GET.get("hotel_id")
    try:
        hotel_id = int(hotel_id_raw) if hotel_id_raw else None
    except ValueError:
        return JsonResponse({"detail": "hotel_id must be int"}, status=400)
    if not hotel_id:
        return JsonResponse({"detail": "hotel_id required"}, status=400)

    # импортируем только внутри функции, чтобы не ломать загрузку модуля
    try:
        from .services.costasolinfo import _hotel_region as svc_hotel_region
    except ImportError:
        return JsonResponse({"detail": "helper _hotel_region is not defined in costasolinfo.py"}, status=500)

    region = svc_hotel_region(hotel_id)
    return JsonResponse({"hotel_id": hotel_id, "region": region}, json_dumps_params={"ensure_ascii": False})


@api_view(["GET"])
@permission_classes([AllowAny])
def debug_excursion_prices(request):
    """Возвращает цены экскурсии по региону (adult/child/currency) для пары (excursion_id, region)."""
    try:
        excursion_id = int(request.GET.get("excursion_id"))
    except (TypeError, ValueError):
        return JsonResponse({"detail": "excursion_id required (int)"}, status=400)

    region_id = request.GET.get("region_id")
    region_slug = request.GET.get("region_slug")
    region = None
    if region_id or region_slug:
        try:
            region = {"id": int(region_id)} if region_id else {"id": None}
        except ValueError:
            return JsonResponse({"detail": "region_id must be int"}, status=400)
        if region_slug:
            region["slug"] = region_slug

    try:
        from .services.costasolinfo import _excursion_price_for_region as svc_ex_price_region
    except ImportError:
        return JsonResponse({"detail": "helper _excursion_price_for_region is not defined in costasolinfo.py"}, status=500)

    prices = svc_ex_price_region(excursion_id, region)
    return JsonResponse(
        {"excursion_id": excursion_id, "region": region, "prices": prices},
        json_dumps_params={"ensure_ascii": False},
    )

log = logging.getLogger(__name__)

_TAG_RE = re.compile(r"<[^>]+>")

def login_view(request): return JsonResponse({"ok": True})

def _csi_url(path: str) -> str:
    """Надёжно склеивает CSI_API_BASE и относительный путь."""
    base = getattr(settings, "CSI_API_BASE", "http://127.0.0.1:8000").rstrip("/")
    if base.endswith("/api"):
        return f"{base}/{path.lstrip('/')}"           # base уже с /api
    return f"{base}/api/{path.lstrip('/')}"           # добавим /api

@csrf_exempt
@api_view(["POST"])
@authentication_classes([])          # отключаем SessionAuthentication => не требует CSRF
@permission_classes([AllowAny])      # в деве позволим всем
def create_booking(request):
    # На этом шаге просто эхо-заглушка, чтобы проверить POST
    data = request.data or {}
    return Response({
        "status": "PENDING",
        "booking_code": "S-000001",
        "echo": data,                # вернём то, что прислали, для наглядности
    })

@api_view(["GET"])
def debug_csi_base(request):
    from django.conf import settings
    return Response({
        "CSI_API_MODE": settings.CSI_API_MODE,
        "CSI_API_BASE": settings.CSI_API_BASE,
        "timeout": settings.CSI_HTTP_TIMEOUT,
        "cache_sec": settings.CSI_CACHE_SECONDS,
    })

@api_view(["GET"])
@permission_classes([AllowAny])
def health(request):
    return Response({"status": "ok"})

def _via_client(query: str, limit: int) -> list:
    from .services import costasolinfo as csi
    data = csi.search_hotels(query, limit=limit)
    return data if isinstance(data, list) else (data.get("items") if isinstance(data, dict) else [])

def _via_proxy(query: str, limit: int) -> list:
    """
    Пробуем REST-эндпоинты источника:
    1) /api/hotels/?search=
    2) /api/available-hotels/?search=
    Возвращаем первый непустой результат.
    """
    for path in ("hotels/", "available-hotels/"):
        r = requests.get(_csi_url(path), params={"search": query, "limit": limit}, timeout=6)
        if r.ok:
            data = r.json()
            items = data if isinstance(data, list) else (data.get("items") if isinstance(data, dict) else [])
            if items:
                return items
    return []

@api_view(["GET"])
@permission_classes([AllowAny])
def hotels(request):
    """
    /api/sales/hotels/?q=best benalmadena   или   ?search=best benalmadena
    Возвращает {items:[...]}.
    Алгоритм: полная строка → последнее слово → первое слово;
    для каждой попытки: сначала через csi-клиент, затем прямой прокси.
    """
    q = (request.query_params.get("q") or request.query_params.get("search") or "").strip()
    if not q:
        return Response({"items": []})

    try:
        limit = int(request.query_params.get("limit", "10"))
    except ValueError:
        limit = 10

    attempts = [q]
    parts = [p for p in re.split(r"[\s,.;-]+", q) if p]
    if len(parts) > 1:
        attempts += [parts[-1], parts[0]]  # сначала «benalmadena», затем «best»

    for query in attempts:
        items = []
        # 1) через клиент
        try:
            items = _via_client(query, limit)
        except Exception:
            items = []
        # 2) фолбэк — прямые REST эндпоинты источника
        if not items:
            try:
                items = _via_proxy(query, limit)
            except Exception:
                items = []

        if items:
            _enrich_hotels(items)       # ← ДОБАВЛЕНО: подмешиваем счётчик
            return Response({"items": items})

    return Response({"items": []})


@api_view(["GET"])
@permission_classes([AllowAny])
def tourists(request):
    """
    /api/sales/tourists/?hotel_name=RIU%20COSTA%20DEL%20SOL&search=ivan
    Также понимает: ?hotel_id=... (зарезервировано), ?q=...
    Возвращает {items:[{ id, last_name, first_name, checkin, checkout, room, party:[...] }]}
    где party — все путешественники (Traveler) в рамках одной FamilyBooking.
    """
    # 1) входные параметры
    hotel_name = (request.query_params.get("hotel_name")
                  or request.query_params.get("hotel")
                  or "").strip()
    _ = request.query_params.get("hotel_id")  # пока не используем
    q = (request.query_params.get("search")
         or request.query_params.get("q")
         or "").strip()

    if not hotel_name:
        return Response({"items": []})

    # 2) модели
    from .models import FamilyBooking, Traveler

    # 3) все семейные брони по отелю (icontains — нечувствительно к регистру)
    fam_ids = list(
        FamilyBooking.objects
        .filter(hotel_name__icontains=hotel_name)
        .values_list("id", flat=True)
    )
    if not fam_ids:
        return Response({"items": []})

    # 4) выбираем путешественников этих семей
    trav_qs = Traveler.objects.filter(family_id__in=fam_ids)
    if q:
        trav_qs = trav_qs.filter(Q(last_name__icontains=q) | Q(first_name__icontains=q))

    # Берём только нужные поля и убираем дубликаты на уровне БД
    trav_rows = (
        trav_qs
        .values("id", "last_name", "first_name", "dob", "family_id")
        .order_by("family_id", "last_name", "first_name", "id")
        .distinct()
    )

    if not trav_rows:
        return Response({"items": []})

    # 5) группируем по family_id
    groups = defaultdict(list)
    for r in trav_rows:
        groups[r["family_id"]].append(r)

    fam_map = {
        f.id: f for f in FamilyBooking.objects.filter(id__in=groups.keys())
    }

    def is_child(dob):
        if not dob:
            return False
        try:
            today = date.today()
            age = today.year - dob.year - ((today.month, today.day) < (dob.month, dob.day))
            return age < 12
        except Exception:
            return False

    items = []
    for fam_id, members in groups.items():
        fam = fam_map.get(fam_id)
        head = members[0]  # первый по алфавиту
        party = [{
            "id": m["id"],
            "full_name": f'{m["last_name"]} {m["first_name"]}'.strip(),
            "is_child": is_child(m.get("dob")),
        } for m in members]

        items.append({
            "id": fam_id,  # id семейной брони — ключ карточки
            "last_name": head["last_name"],
            "first_name": head["first_name"],
            "checkin": (fam.arrival_date.isoformat() if getattr(fam, "arrival_date", None) else None),
            "checkout": (fam.departure_date.isoformat() if getattr(fam, "departure_date", None) else None),
            "room": "",  # комнат в модели нет — оставляем пусто
            "party": party,
        })

    # свежие заезды выше
    items.sort(key=lambda x: (x["checkin"] or ""), reverse=True)
    return Response({"items": items})

def _tourists_count_by_hotel_name(name: str) -> int:
    # считаем именно путешественников (distinct на случай задвоений)
    fam_ids = list(
        FamilyBooking.objects.filter(hotel_name__icontains=name)
        .values_list("id", flat=True)
    )
    if not fam_ids:
        return 0
    return (
        Traveler.objects.filter(family_id__in=fam_ids)
        .distinct()
        .count()
    )

def _enrich_hotels(items: list[dict]) -> list[dict]:
    # безопасно добавляем поле tourists_count к каждому отелю
    for it in items:
        name = (it.get("name") or it.get("title") or "").strip()
        it["tourists_count"] = _tourists_count_by_hotel_name(name) if name else 0
    return items


def _strip_html(s: str) -> str:
    if not s:
        return ""
    # 1) раскодировать HTML сущности (&mdash; и т.д.)
    s = html.unescape(s)
    # 2) убрать теги
    s = _TAG_RE.sub("", s)
    # 3) нормализовать пробелы
    return re.sub(r"\s+", " ", s).strip()

WEEKDAY_NUM_TO_CODE = {0:"mon",1:"tue",2:"wed",3:"thu",4:"fri",5:"sat",6:"sun"}
WEEKDAY_CODE_TO_NUM = {v:k for k,v in WEEKDAY_NUM_TO_CODE.items()}

def _is_child(birth_date):
    if not birth_date:
        return False
    today = date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
    return age < 12

@api_view(["GET"])
@permission_classes([AllowAny])
def family_detail(request, fam_id: int):
    """
    GET /api/sales/families/<fam_id>/
    Возвращает карточку семьи с hotel_id и списком путешественников.
    """
    from .models import FamilyBooking, Traveler

    fam = get_object_or_404(FamilyBooking, pk=fam_id)

    party = []
    for t in Traveler.objects.filter(family=fam).order_by("last_name", "first_name"):
        party.append({
            "id": t.id,
            "first_name": t.first_name,
            "last_name": t.last_name,
            "full_name": f"{t.last_name} {t.first_name}".strip(),
            "is_child": _is_child(t.dob),
        })

    return Response({
        "id": fam.id,
        "hotel_id": fam.hotel_id,                     # важно для пикапов/квоты
        "hotel_name": fam.hotel_name,
        "checkin": fam.arrival_date.isoformat() if fam.arrival_date else None,
        "checkout": fam.departure_date.isoformat() if fam.departure_date else None,
        "room": "",                                   # если позже появится поле — подставим его
        "party": party,
    })

# --- Черновики броней по семье (для текущего гида) ----------------------------
class FamilyBookingDraftsView(APIView):
    permission_classes = [AllowAny]

    def get(self, request, fam_id: int):
        qs = BookingSale.objects.filter(family_id=fam_id)

        # ограничиваем по гиду только если юзер залогинен
        user = getattr(request, "user", None)
        if getattr(user, "is_authenticated", False) and user.id:
            qs = qs.filter(guide_id=user.id)

        # (необязательно) если хочешь показывать только черновики/ожидающие:
        # qs = qs.filter(status__in=["DRAFT", "PENDING"])

        qs = qs.order_by("-created_at")
        data = BookingSaleListSerializer(qs, many=True).data
        return Response(data)


@method_decorator(csrf_exempt, name="dispatch")
class BookingBatchPreviewView(APIView):
    """
    POST /api/sales/bookings/batch/preview/
    Body JSON: { "family_id": 123 } ИЛИ { "booking_ids": [1,2,3] }
    Возвращает сводку черновиков текущего "гида" (status='DRAFT').
    """
    authentication_classes = []
    permission_classes = [AllowAny]

    def post(self, request):
        booking_ids = request.data.get("booking_ids") or []
        family_id = request.data.get("family_id")

        user = _resolve_user(request)

        qs = BookingSale.objects.filter(status="DRAFT")
        if user:
            qs = qs.filter(guide=user)

        try:
            if family_id:
                qs = qs.filter(family_id=family_id)
            elif booking_ids:
                qs = qs.filter(id__in=booking_ids)
        except FieldError:
            return Response({"detail": "В модели BookingSale нет поля family."}, status=400)

        items = []
        total = 0
        for b in qs.order_by("-created_at"):
            gross = b.gross_total or 0
            total += gross
            items.append({
                "id": b.id,
                "booking_code": b.booking_code,
                "company": getattr(b.company, "name", None),
                "date": b.date.isoformat() if b.date else None,
                "excursion_id": b.excursion_id,
                "excursion_title": b.excursion_title,
                "hotel_name": b.hotel_name,
                "pickup_point_name": b.pickup_point_name,
                "pickup_time_str": b.pickup_time_str,
                "excursion_language": getattr(b, "excursion_language", None),
                "room_number": getattr(b, "room_number", ""),
                "adults": b.adults, "children": b.children, "infants": b.infants,
                "gross_total": str(gross),
                "price_per_adult": str(getattr(b, "price_per_adult", 0) or 0),
                "price_per_child": str(getattr(b, "price_per_child", 0) or 0),
                "pickup_lat": getattr(b, "pickup_lat", None),
                "pickup_lng": getattr(b, "pickup_lng", None),
                "pickup_address": getattr(b, "pickup_address", ""),
            })
        return Response({"count": len(items), "total": f"{total:.2f}", "items": items}, status=200)



@method_decorator(csrf_exempt, name="dispatch")
class BookingBatchSendView(APIView):
    """
    POST /api/sales/bookings/batch/send/
    Body JSON: { "family_id": 123 } ИЛИ { "booking_ids": [1,2,3] }
    Переводит выбранные черновики из DRAFT -> PENDING и (опционально) запускает отправку.
    """
    authentication_classes = []
    permission_classes = [AllowAny]

    def post(self, request):
        booking_ids = request.data.get("booking_ids") or []
        family_id = request.data.get("family_id")

        user = _resolve_user(request)

        qs = BookingSale.objects.filter(status="DRAFT")
        if user:
            qs = qs.filter(guide=user)

        try:
            if family_id:
                qs = qs.filter(family_id=family_id)
            elif booking_ids:
                qs = qs.filter(id__in=booking_ids)
        except FieldError:
            return Response({"detail": "В модели BookingSale нет поля family."}, status=400)

        # тут можно собрать XLSX/почту; сейчас просто меняем статус
        updated = qs.update(status="PENDING")
        return Response({"updated": updated}, status=200)



def _normalize_excursions(raw, compact: bool = True, limit: int | None = None, offset: int = 0):
    """
    Приводим ответ к единому формату { items: [ ... ], total: N }.
    Поддерживаем как массив, так и {items: [...]} из старого API.
    """
    items = raw.get("items") if isinstance(raw, dict) else raw
    if not isinstance(items, list):
        items = []

    total = len(items)
    # пагинация на нашей стороне (простая)
    if limit is not None:
        items = items[offset: offset + limit]

    norm = []
    for it in items:
        # исходные поля
        _id = it.get("id")
        title = it.get("localized_title") or it.get("title") or ""
        description_html = it.get("localized_description") or it.get("description") or ""
        image = it.get("image")
        duration = it.get("duration")
        direction = it.get("direction")
        # дни – могут прийти и кодами, и цифрами; соберём оба и унифицируем
        days_code = it.get("days") or []
        days_num = it.get("available_days") or []
        # добьём отсутствующие представления
        if not days_code and days_num:
            days_code = [WEEKDAY_NUM_TO_CODE.get(n) for n in days_num if n in WEEKDAY_NUM_TO_CODE]
        if not days_num and days_code:
            days_num = [WEEKDAY_CODE_TO_NUM.get(c) for c in days_code if c in WEEKDAY_CODE_TO_NUM]

        languages = it.get("tour_languages") or it.get("languages") or []

        if compact:
            short = _strip_html(description_html)[:220].rstrip()  # короткое описание ~ 220 симв.
            norm.append({
                "id": _id,
                "title": title,
                "short_description": short,
                "duration": duration,
                "direction": direction,
                "days": days_code,              # ["thu", ...]
                "available_days": days_num,     # [3, ...]
                "languages": languages,
                "image": image,
            })
        else:
            # полный вариант, оставляем HTML
            norm.append({
                "id": _id,
                "title": title,
                "description_html": description_html,
                "duration": duration,
                "direction": direction,
                "days": days_code,
                "available_days": days_num,
                "languages": languages,
                "image": image,
            })
    return {"items": norm, "total": total}

@api_view(["GET"])
def excursions(request):
    lang = request.query_params.get("lang", "ru")
    date = request.query_params.get("date")
    region = request.query_params.get("region")
    compact = request.query_params.get("compact", "1") not in ("0", "false", "False")
    # простая пагинация
    try:
        limit = int(request.query_params.get("limit", "20"))
    except ValueError:
        limit = 20
    try:
        offset = int(request.query_params.get("offset", "0"))
    except ValueError:
        offset = 0

    raw = csi.list_excursions(lang=lang, date=date, region=region)
    data = _normalize_excursions(raw, compact=compact, limit=limit, offset=offset)
    return Response(data)


class SalesExcursionPickupsView(APIView):
    """GET /api/sales/pickups/v2/?excursion_id=&hotel_id=&hotel_name=&date=YYYY-MM-DD
    Returns: {excursion_id, excursion_title, hotel_id, date, count, results:[{...}]}
    """

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        # 1) excursion_id обязателен и целый
        try:
            excursion_id = int(request.GET.get("excursion_id", ""))
        except (TypeError, ValueError):
            return Response({"detail": "excursion_id must be integer"}, status=status.HTTP_400_BAD_REQUEST)

        # 2) date обязателен и в формате YYYY-MM-DD
        date_str = request.GET.get("date")
        if not date_str or not parse_date(date_str):
            return Response({"detail": "Invalid or missing 'date' (YYYY-MM-DD)"}, status=status.HTTP_400_BAD_REQUEST)

        # 3) hotel_id ИЛИ hotel_name (fallback)
        hotel_name = (request.GET.get("hotel_name") or request.GET.get("hotel") or "").strip()
        hotel_id = None
        hotel_id_raw = request.GET.get("hotel_id")
        try:
            hotel_id = int(hotel_id_raw) if hotel_id_raw not in (None, "",) else None
        except ValueError:
            hotel_id = None

        if not hotel_id and hotel_name:
            hid = _resolve_hotel_id_by_name(hotel_name)
            if hid:
                hotel_id = hid

        if not hotel_id:
            # мягкий ответ, как и раньше: просто пустой список без ошибки
            title = csi.excursion_title(excursion_id, lang=(request.GET.get("lang") or "ru")[:5])
            return Response({
                "excursion_id": excursion_id,
                "excursion_title": title,
                "hotel_id": None,
                "date": date_str,
                "count": 0,
                "results": [],
            })

        # 4) тянем пикапы у клиента
        client = get_client()
        pickups = client.excursion_pickups(excursion_id=excursion_id, hotel_id=hotel_id, date=date_str)

        # 5) добавим заголовок экскурсии
        lang = (request.GET.get("lang") or request.headers.get("Accept-Language") or "ru")[:5]
        title = csi.excursion_title(excursion_id, lang=lang)

        results = []
        for it in pickups:
            results.append({
                "id": it.get("id"),
                "point": it.get("name") or it.get("point"),
                "time": it.get("time"),
                "lat": it.get("lat"),
                "lng": it.get("lng"),
                "address": it.get("address") or "",
            })

        return Response({
            "excursion_id": excursion_id,
            "excursion_title": title,
            "hotel_id": hotel_id,
            "date": date_str,
            "count": len(pickups),
            "results": pickups,
        })



@api_view(["GET"])
def pickups(request):
    ex_id = request.GET.get("excursion_id")
    hotel_id = request.GET.get("hotel_id")
    date = request.GET.get("date")  # пока не используем

    if not ex_id or not hotel_id:
        return Response({"error": "excursion_id and hotel_id are required", "items": []}, status=400)

    try:
        ex_id = int(ex_id)
        hotel_id = int(hotel_id)
    except ValueError:
        return Response({"error": "excursion_id and hotel_id must be integers", "items": []}, status=400)

    item = csi.get_client().excursion_pickup(ex_id, hotel_id)
    if not item:
        # совместимо с фронтом: пустой список — просто нет точки
        return Response({"items": []}, status=200)

    # язык для заголовка экскурсии
    lang = (request.GET.get("lang") or request.headers.get("Accept-Language") or "ru")[:5]
    title = csi.excursion_title(ex_id, lang=lang)

    # Нормализуем к единому виду
    norm = {
        "id": item.get("id"),
        "point": item.get("name"),
        "time": item.get("time"),       # "HH:MM" или None
        "lat": item.get("lat"),
        "lng": item.get("lng"),
        "price_adult": item.get("price_adult"),
        "price_child": item.get("price_child"),
    }
    return Response({
        "excursion_id": ex_id,
        "excursion_title": title,
        "hotel_id": hotel_id,
        "items": [norm]
    }, status=200)


@api_view(["GET"])
def quote(request):
    try:
        ex_id = int(request.query_params["excursion_id"])
        adults = int(request.query_params.get("adults", "1"))
        children = int(request.query_params.get("children", "0"))
        infants = int(request.query_params.get("infants", "0"))
    except (KeyError, ValueError):
        return Response({"detail": "invalid params"}, status=400)

    lang = request.query_params.get("lang", "ru")
    hotel_id_raw = request.query_params.get("hotel_id")
    hotel_id = int(hotel_id_raw) if (hotel_id_raw and hotel_id_raw.isdigit()) else None
    date = request.query_params.get("date")
    hotel_name = request.query_params.get("hotel_name") or request.query_params.get("hotel")

    if not hotel_id and hotel_name:
        hid = _resolve_hotel_id_by_name(hotel_name)
        if hid:
            hotel_id = hid

    if not hotel_id:
        return Response({"detail": "hotel_id is required (could not resolve by hotel_name)"}, status=400)

    try:
        data = pricing_quote(
            excursion_id=ex_id,
            adults=adults,
            children=children,
            infants=infants,
            lang=lang,
            hotel_id=hotel_id,
            date=date,
        )
        return Response(data)
    except Exception as e:
        logging.getLogger(__name__).exception("quote() failed")
        return Response({"detail": str(e)}, status=500)



@api_view(["GET"])
@permission_classes([AllowAny])
def pricing_debug_signature(request):
    try:
        import sales.services.costasolinfo as mod
        sig = str(inspect.signature(mod.pricing_quote))
        path = getattr(mod, "__file__", "<unknown>")
        return Response({"module_file": path, "signature": sig})
    except Exception as e:
        return Response({"detail": str(e)}, status=500)

def _weekday_slug(date_str: str) -> str | None:
    try:
        d = dt.date.fromisoformat(date_str)
        return WEEKDAYS[d.weekday()]
    except Exception:
        return None

@api_view(["GET"])
@permission_classes([AllowAny])
def pricing_quote_view(request):
    try:
        excursion_id = int(request.GET.get("excursion_id"))
        adults = int(request.GET.get("adults", 0))
        children = int(request.GET.get("children", 0))
        infants = int(request.GET.get("infants", 0))
        lang = request.GET.get("lang") or "ru"

        hotel_id_raw = request.GET.get("hotel_id")
        hotel_id = int(hotel_id_raw) if (hotel_id_raw and hotel_id_raw.isdigit()) else None
        hotel_name = request.GET.get("hotel_name") or request.GET.get("hotel")  # ← НОВОЕ
        date = request.GET.get("date")

        if adults < 0 or children < 0 or infants < 0:
            return Response({"detail": "Negative quantities not allowed"}, status=400)

        # Если hotel_id отсутствует — пробуем найти его по названию
        if not hotel_id and hotel_name:
            hid = _resolve_hotel_id_by_name(hotel_name)
            if hid:
                hotel_id = hid

        # Если до сих пор нет hotel_id — честно скажем об этом
        if not hotel_id:
            return Response({"detail": "hotel_id is required (could not resolve by hotel_name)"}, status=400)

        # Проверка доступности даты по экскурсии (если дата передана)
        if date:
            wd = _weekday_slug(date)
            if not wd:
                return Response({"detail": "Bad date format, use YYYY-MM-DD"}, status=400)
            try:
                ex = csi.excursion_detail(excursion_id)
            except Exception:
                ex = {}
            avail_raw = (ex.get("available_days") or ex.get("days") or [])
            avail_norm = []
            for x in avail_raw:
                if isinstance(x, int):
                    avail_norm.append(WEEKDAYS[x % 7])     # 0=mon..6=sun
                else:
                    avail_norm.append(str(x).strip().lower()[:3])
            if avail_norm and wd not in avail_norm:
                return Response({
                    "detail": f"Date {date} is not available for this excursion",
                    "available_days": avail_norm
                }, status=400)

        # ВАЖНО: передаём date/ hotel_id дальше
        quote = pricing_quote(
            excursion_id=excursion_id,
            adults=adults,
            children=children,
            infants=infants,
            lang=lang,
            hotel_id=hotel_id,
            date=date,
        )
        return Response(quote)

    except NotFoundError as e:
        # аккуратно: это нормальная «нет цены»
        return Response({"detail": str(e)}, status=404)
    except (TypeError, ValueError) as e:
        return Response({"detail": str(e), "type": e.__class__.__name__}, status=400)
    except Exception as e:
        logging.getLogger(__name__).exception("pricing_quote_view failed")
        return Response({"detail": str(e), "type": e.__class__.__name__}, status=500)


@api_view(["GET"])
@permission_classes([AllowAny])
def debug_raw_hotel(request):
    from .services.costasolinfo import _get
    hotel_id = request.GET.get("hotel_id")
    if not hotel_id:
        return JsonResponse({"detail": "hotel_id required"}, status=400)
    try:
        hid = int(hotel_id)
    except ValueError:
        return JsonResponse({"detail": "hotel_id must be int"}, status=400)
    data = _get(f"/hotels/{hid}/", allow_404=True)
    return JsonResponse({"hotel_id": hid, "raw": data}, json_dumps_params={"ensure_ascii": False, "default": str})

@api_view(["GET"])
@permission_classes([AllowAny])
def debug_raw_excursion(request):
    from .services.costasolinfo import _get
    excursion_id = request.GET.get("excursion_id")
    if not excursion_id:
        return JsonResponse({"detail": "excursion_id required"}, status=400)
    try:
        exid = int(excursion_id)
    except ValueError:
        return JsonResponse({"detail": "excursion_id must be int"}, status=400)
    data = _get(f"/excursions/{exid}/", allow_404=True)
    return JsonResponse({"excursion_id": exid, "raw": data}, json_dumps_params={"ensure_ascii": False, "default": str})


class CompanyViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Company.objects.filter(is_active=True).order_by("name")
    serializer_class = CompanySerializer
    permission_classes = [AllowAny]  # <-- было IsAuthenticated


class BookingCreateView(APIView):
    permission_classes = [AllowAny]  # ← временно для теста

    def post(self, request):
        ser = BookingSaleCreateSerializer(data=request.data, context={"request": request})
        ser.is_valid(raise_exception=True)
        booking = ser.save()
        return Response({"id": booking.id, "booking_code": booking.booking_code}, status=status.HTTP_200_OK)


class BookingListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        qs = BookingSale.objects.filter(guide=request.user).order_by("-created_at")[:200]
        return Response(BookingSaleListSerializer(qs, many=True).data)
```


---

## `backend/sales/views_pages.py`

```py
# sales/views_pages.py
from django.shortcuts import render
from django.views.decorators.http import require_http_methods
from django.contrib import messages
from .forms import TouristsImportForm
from .importers.tourists_excel import import_tourists_excel

@require_http_methods(["GET", "POST"])
def tourists_import_page(request):
    if request.method == "POST":
        form = TouristsImportForm(request.POST, request.FILES)
        if form.is_valid():
            f = form.cleaned_data["file"]
            dry = form.cleaned_data["dryrun"]
            try:
                report = import_tourists_excel(f, dry_run=dry)
                if report.get("issues"):
                    messages.warning(request, "Импорт завершён с замечаниями.")
                else:
                    messages.success(request, "Импорт завершён успешно.")
                return render(request, "sales/tourists_import.html", {
                    "form": form,
                    "report": report,
                })
            except Exception as e:
                messages.error(request, f"Ошибка импорта: {e}")
    else:
        form = TouristsImportForm()
    return render(request, "sales/tourists_import.html", {"form": form})

```


---

## `backend/sales/forms.py`

```py
# sales/forms.py
from django import forms

class TouristsImportForm(forms.Form):
    file = forms.FileField(label="Файл с туристами (Excel/CSV)")
    dry_run = forms.BooleanField(label="Только проверка", required=False)

```


---

## `backend/sales/importers/__init__.py`

```py

```


---

## `backend/sales/importers/tourists_excel.py`

```py
# sales/importers/tourists_excel.py
from __future__ import annotations

import os
import re
import tempfile
from dataclasses import dataclass, field
from datetime import datetime
from io import BytesIO
from typing import Any, BinaryIO, Dict, List, Optional

import pandas as pd
from django.db import IntegrityError, transaction
from django.utils.timezone import make_naive

from sales.models import FamilyBooking, Traveler
from sales.services import costasolinfo as csi


# ---------- утилиты нормализации ----------

def _norm(s: str) -> str:
    if s is None:
        return ""
    s = str(s)
    s = s.replace("\xa0", " ")  # NBSP -> обычный пробел
    s = re.sub(r"\s+", " ", s).strip()
    s = s.lower()
    s = re.sub(r"[^\w\sа-яё\-]", "", s, flags=re.IGNORECASE)  # убираем мусор
    s = s.replace("-", " ")
    s = re.sub(r"\s+", " ", s).strip()
    return s


def _find_col(df: pd.DataFrame, aliases: List[str]) -> Optional[str]:
    """Ищем колонку по набору алиасов: сначала точное совпадение после _norm, потом вхождение."""
    cols = [str(c).strip() for c in df.columns]
    norm_cols = {c: _norm(c) for c in cols}
    norm_alias = [_norm(a) for a in aliases]

    for c, nc in norm_cols.items():
        if nc in norm_alias:
            return c
    for c, nc in norm_cols.items():
        if any(na and na in nc for na in norm_alias):
            return c
    return None


def _parse_date(v):
    if v is None or (isinstance(v, float) and pd.isna(v)) or (isinstance(v, str) and not v.strip()):
        return None
    if isinstance(v, (datetime, pd.Timestamp)):
        try:
            return make_naive(v).date() if isinstance(v, pd.Timestamp) and v.tzinfo else v.date()
        except Exception:
            return v.date() if hasattr(v, "date") else None
    for fmt in ("%d.%m.%Y", "%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y"):
        try:
            return datetime.strptime(str(v).strip(), fmt).date()
        except Exception:
            pass
    d = pd.to_datetime(v, dayfirst=True, errors="coerce")
    return d.date() if not pd.isna(d) else None


def _resolve_hotel(name: str) -> tuple[Optional[int], str, str]:
    """Пытаемся найти hotel_id по названию через CSI. Возвращаем (id, name, region_name)."""
    try:
        items = csi.search_hotels(name, limit=1) or []
        if isinstance(items, dict):
            items = items.get("items") or []
        if items:
            h = items[0]
            return (
                h.get("id"),
                h.get("name") or h.get("title") or name,
                (h.get("region") or h.get("region_name") or ""),
            )
    except Exception:
        pass
    return None, name, ""


# ---------- карта колонок ----------

COLMAP = {
    "ref_code": ["Номер брони", "Номер заявки", "Reservation", "Booking", "ref", "Заявка"],
    "hotel": ["Отель", "Hotel", "Гостиница"],
    "arrival": ["Дата заезда", "Arrival", "Дата прилёта", "Check-in", "Check in", "Заезд"],
    "departure": [
        "Дата выезда", "Дата отъезда", "Отъезд", "Выезд",
        "Дата возвращения", "Возврат",
        "Departure", "Return date",
        "Check-out", "Check out",
        "Дата вылета", "Вылет",
    ],
    "last_name": ["Фамилия", "Last name", "Surname"],
    "first_name": ["Имя", "First name", "Name"],
    "middle_name": ["Отчество", "Middle name", "Patronymic"],
    "dob": ["Дата рождения", "DOB", "Birth date"],
    "nationality": ["Национальность", "Nationality"],
    "passport": ["Паспорт", "Passport", "Doc number"],
    "passport_expiry": ["Срок действия паспорта", "Passport expiry", "Expiry"],
    "phone": ["Телефон", "Phone", "Номер телефона", "Контактный телефон"],
    "email": ["Email", "E-mail", "Эл. почта", "Почта"],
    "note": ["Примечание", "Note", "Комментарий"],
}


# ---------- авто-детекция строки заголовков ----------

def _auto_header(df0: pd.DataFrame) -> pd.DataFrame:
    """Если заголовки 'Unnamed' или «мимо», ищем строку-шапку по знакомым названиям."""
    def _score(cols: List[str]) -> int:
        cols_l = [str(c).strip().lower() for c in cols]
        score = 0
        for aliases in COLMAP.values():
            for a in aliases:
                if a.lower() in cols_l:
                    score += 1
                    break
        return score

    if _score(list(df0.columns)) >= 2:
        return df0  # и так норм

    best = (None, -1)
    for i in range(min(10, len(df0))):
        row = [str(x).strip() for x in df0.iloc[i].tolist()]
        sc = _score(row)
        if sc > best[1]:
            best = (i, sc)
    header_idx, sc = best
    if header_idx is not None and sc >= 2:
        new_cols = [str(x).strip() or f"col_{j}" for j, x in enumerate(df0.iloc[header_idx].tolist())]
        df = df0.iloc[header_idx + 1:].copy()
        df.columns = new_cols
        return df

    return df0


# ---------- отчёт ----------

@dataclass
class RowIssue:
    rownum: int
    message: str
    payload: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ImportReport:
    sheet: str
    total_rows: int = 0
    created_families: int = 0
    updated_families: int = 0
    created_travelers: int = 0
    skipped: int = 0
    issues: List[RowIssue] = field(default_factory=list)


# ---------- основной импортёр ----------

def import_tourists_excel(file, dry_run: bool = True) -> Dict[str, Any]:
    # читаем .xlsx или .csv
    if hasattr(file, "name") and str(file.name).lower().endswith(".csv"):
        df0 = pd.read_csv(file, header=None)  # без заголовка — определим сами
        sheet_name = "CSV"
    else:
        xls = pd.ExcelFile(file)
        sheet_name = xls.sheet_names[0]
        df0 = xls.parse(sheet_name, header=None)  # без заголовков — определим сами

    df = _auto_header(df0)
    report = ImportReport(sheet=sheet_name, total_rows=len(df))

    # маппинг колонок
    cols = {key: _find_col(df, aliases) for key, aliases in COLMAP.items()}
    required = ["hotel", "last_name", "first_name"]
    missing = [k for k in required if not cols.get(k)]
    if missing:
        report.issues.append(RowIssue(0, f"Нет обязательных колонок: {missing}"))
        return {
            **report.__dict__,
            "column_mapping": {k: cols[k] for k in cols if cols[k]},
            "issues": [i.__dict__ for i in report.issues],
            "dry_run": dry_run,
        }

    @transaction.atomic
    def _do():
        for idx, row in df.iterrows():
            hotel_raw = str(row.get(cols["hotel"], "")).strip()
            if not hotel_raw:
                report.issues.append(RowIssue(idx + 2, "Пустой отель"))
                report.skipped += 1
                continue

            hotel_id, hotel_name, region_name = _resolve_hotel(hotel_raw)

            ref_code = str(row.get(cols.get("ref_code"), "")).strip() if cols.get("ref_code") else ""
            arrival = _parse_date(row.get(cols.get("arrival"))) if cols.get("arrival") else None
            departure = _parse_date(row.get(cols.get("departure"))) if cols.get("departure") else None

            fam = (
                FamilyBooking.objects.filter(ref_code=ref_code or "", hotel_id=hotel_id or 0).first()
            )
            if not fam:
                fam = FamilyBooking.objects.create(
                    ref_code=ref_code or "",
                    hotel_id=hotel_id or 0,
                    hotel_name=hotel_name,
                    region_name=region_name,
                    arrival_date=arrival,
                    departure_date=departure,
                )
                report.created_families += 1
            else:
                changed = False
                if arrival and fam.arrival_date != arrival:
                    fam.arrival_date = arrival
                    changed = True
                if departure and fam.departure_date != departure:
                    fam.departure_date = departure
                    changed = True
                if hotel_name and fam.hotel_name != hotel_name:
                    fam.hotel_name = hotel_name
                    changed = True
                if region_name and fam.region_name != region_name:
                    fam.region_name = region_name
                    changed = True
                if changed:
                    fam.save(update_fields=["arrival_date", "departure_date", "hotel_name", "region_name"])
                    report.updated_families += 1

            # Traveler уникален в пределах семьи по (last_name, first_name, dob)
            last_name = str(row.get(cols["last_name"], "")).strip()
            first_name = str(row.get(cols["first_name"], "")).strip()
            middle_name = str(row.get(cols.get("middle_name"), "")).strip() if cols.get("middle_name") else ""
            dob = _parse_date(row.get(cols.get("dob"))) if cols.get("dob") else None

            defaults = {
                "middle_name": middle_name,
                "nationality": str(row.get(cols.get("nationality"), "")).strip() if cols.get("nationality") else "",
                "passport": str(row.get(cols.get("passport"), "")).strip() if cols.get("passport") else "",
                "passport_expiry": _parse_date(row.get(cols.get("passport_expiry"))) if cols.get("passport_expiry") else None,
                "phone": str(row.get(cols.get("phone"), "")).strip() if cols.get("phone") else "",
                "email": str(row.get(cols.get("email"), "")).strip() if cols.get("email") else "",
                "note": str(row.get(cols.get("note"), "")).strip() if cols.get("note") else "",
            }

            try:
                # если дубликат — просто не создаём второй
                _obj, created = Traveler.objects.get_or_create(
                    family=fam,
                    last_name=last_name,
                    first_name=first_name,
                    dob=dob,
                    defaults=defaults,
                )
                if created:
                    report.created_travelers += 1
                else:
                    # при желании можно обновлять defaults у существующего
                    pass
            except IntegrityError:
                report.skipped += 1
                report.issues.append(RowIssue(idx + 2, "Дублирующийся турист (уникальность нарушена)",
                                              {"family_id": fam.id, "last_name": last_name, "first_name": first_name, "dob": dob}))

    if dry_run:
        with transaction.atomic():
            _do()
            transaction.set_rollback(True)
    else:
        _do()

    colmap_human = {k: cols[k] for k in cols if cols[k]}
    return {
        **report.__dict__,
        "column_mapping": colmap_human,
        "issues": [i.__dict__ for i in report.issues],
        "dry_run": dry_run,
    }


# ---------- адаптер для админки ----------

def import_file(up_file: BinaryIO, dry_run: bool = False) -> dict:
    """
    Унифицированный вход, который ожидает админка.
    Возвращает словарь с ключами, которые показываем в сообщении.
    """
    data = up_file.read()
    result = import_tourists_excel(BytesIO(data), dry_run=dry_run)
    return {
        "families_created": int(result.get("created_families", 0)),
        "travelers_created": int(result.get("created_travelers", 0)),
        "skipped": int(result.get("skipped", 0)),
        # опционально можно вернуть сырой отчёт:
        # "_raw": result
    }

```


---

## `backend/sales/services/costasolinfo.py`

```py
# sales/services/costasolinfo.py
from __future__ import annotations

from dataclasses import dataclass
import logging
import requests
from decimal import Decimal, ROUND_HALF_UP
from typing import Any, Dict, Optional, List

import requests
from urllib.parse import urljoin, quote_plus
from django.conf import settings
from django.core.cache import cache

log = logging.getLogger(__name__)


def _money(x) -> float:
    return float(Decimal(str(x or 0)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP))

def _normalize_region_obj(raw: dict | None) -> dict | None:
    if not raw:
        return None
    rid = raw.get("id")
    rslug = raw.get("slug") or raw.get("code") or raw.get("name")
    return {"id": rid, "slug": rslug} if (rid or rslug) else None

def _hotel_region(hotel_id: int) -> dict | None:
    data = _get(f"/hotels/{hotel_id}/", allow_404=True)
    if not data:
        return None
    # 1) вложенный объект region
    r = data.get("region")
    norm = _normalize_region_obj(r) if isinstance(r, dict) else None
    if norm:
        return norm
    # 2) плоское поле region_id
    rid = data.get("region_id")
    if rid is not None:
        return {"id": rid, "slug": None}
    # 3) иногда по другому называется
    for key in ("area", "zone", "resort"):
        r2 = data.get(key)
        if isinstance(r2, dict):
            norm = _normalize_region_obj(r2)
            if norm:
                return norm
    return None

def _pick_first(*values):
    for v in values:
        if v is not None:
            return v
    return None

def _extract_price_row(row: dict) -> tuple[float, float, str] | None:
    # поддержим разные имена полей
    a = _pick_first(row.get("adult"), row.get("adult_price"), row.get("price_adult"), row.get("adultGross"))
    c = _pick_first(row.get("child"), row.get("child_price"), row.get("price_child"), row.get("childGross"))
    cur = _pick_first(row.get("currency"), row.get("curr"))
    if a is None and c is None:
        return None
    if c is None:
        c = a
    return _money(a), _money(c), (cur or "EUR")

def _excursion_price_for_region(excursion_id: int, region: dict | None) -> tuple[float, float, str] | None:
    detail = _get(f"/excursions/{excursion_id}/", allow_404=True)
    if not detail:
        return None

    # A) prices_by_region: [ {region:{id/slug}, adult/child/currency} ]
    pbr = detail.get("prices_by_region") or detail.get("pricesByRegion") or detail.get("region_prices")
    if isinstance(pbr, list) and region:
        rid = region.get("id")
        rslug = (region.get("slug") or "").lower() if region.get("slug") else None
        for row in pbr:
            r = row.get("region") or {}
            if (rid and r.get("id") == rid) or (rslug and (str(r.get("slug") or "").lower() == rslug)):
                got = _extract_price_row(row)
                if got:
                    return got

    # B) Табличные структуры: {"prices":[{"region":...,"adult_price":...},...]} или {"tariffs":[...]}
    for key in ("prices", "tariffs", "pricing", "price_table"):
        arr = detail.get(key)
        if isinstance(arr, list) and region:
            rid = region.get("id")
            rslug = (region.get("slug") or "").lower() if region.get("slug") else None
            for row in arr:
                r = row.get("region") or {}
                if (rid and r.get("id") == rid) or (rslug and (str(r.get("slug") or "").lower() == rslug)):
                    got = _extract_price_row(row)
                    if got:
                        return got

    # C) Поля вида adult_price_{slug}/child_price_{slug}
    if region and region.get("slug"):
        slug = str(region["slug"]).lower()
        a = detail.get(f"adult_price_{slug}")
        c = detail.get(f"child_price_{slug}")
        if a is not None or c is not None:
            a2 = _money(a if a is not None else c)
            c2 = _money(c if c is not None else a)
            return a2, c2, detail.get("currency", "EUR")

    # D) Базовые без регионов
    a = _pick_first(detail.get("adult_price"), detail.get("price_adult"))
    c = _pick_first(detail.get("child_price"), detail.get("price_child"))
    if a is not None or c is not None:
        a2 = _money(a if a is not None else c)
        c2 = _money(c if c is not None else a)
        return a2, c2, detail.get("currency", "EUR")

    return None



def _base() -> str:
    base = getattr(settings, "CSI_API_BASE", None)
    if not base:
        raise RuntimeError("CSI_API_BASE is not configured. Check .env and settings.py")
    return base.rstrip("/") + "/"


def _get(
    path: str,
    params: Optional[Dict[str, Any]] = None,
    cache_key: Optional[str] = None,
    *,
    cache_seconds: Optional[int] = None,
    allow_404: bool = False,
    timeout: Optional[float] = None,
) -> Any:
    """
    Универсальный GET с таймаутом, кэшированием и аккуратной обработкой ошибок.

    - allow_404=True → 404 не считается ошибкой, возвращаем None
    - cache_seconds: если не задан, используем settings.CSI_CACHE_SECONDS
    - timeout: если не задан, используем settings.CSI_HTTP_TIMEOUT
    """
    url = urljoin(_base(), path.lstrip("/"))

    # аккуратно собираем ключ кэша
    if cache_key:
        key = cache_key
    else:
        params_tuple = tuple(sorted((params or {}).items()))
        key = f"csi::{path}::{params_tuple}"

    cached = cache.get(key)
    if cached is not None:
        return cached

    try:
        resp = requests.get(url, params=params, timeout=timeout or settings.CSI_HTTP_TIMEOUT)

        # мягкая обработка 404 по флагу
        if resp.status_code == 404 and allow_404:
            return None

        resp.raise_for_status()

        try:
            data = resp.json()
        except ValueError:
            # неожиданно не-JSON ответ
            log.exception("CSI GET non-JSON response: %s", url)
            data = {"error": "bad_json"}

        cache.set(key, data, timeout=cache_seconds if cache_seconds is not None else settings.CSI_CACHE_SECONDS)
        return data

    except requests.RequestException as e:
        log.exception("CSI GET failed: %s %s", url, e)
        # если был кэш — его уже вернули выше; здесь возвращаем «мягкую» заглушку
        return {"error": "unavailable", "items": []}


# ==== Конкретные «обёртки» под текущие эндпоинты CostaSolinfo ====

def search_hotels(q: str, limit: int = 10):
    safe_q = quote_plus(q or "")
    cache_key = f"hotels:{safe_q}:{limit}"
    cached = cache.get(cache_key)
    if cached is not None:
        return cached

    try:
        url = urljoin(_base(), "hotels/")
        resp = requests.get(url, params={"search": q, "limit": limit}, timeout=settings.CSI_HTTP_TIMEOUT)
        resp.raise_for_status()
        data = resp.json()
    except requests.RequestException:
        log.exception("CSI search_hotels failed")
        data = {"items": []}

    cache.set(cache_key, data, timeout=60)
    return data


def transfer_schedule(hotel_id: int, date: str, type_: str = "group"):
    params = {"hotel_id": hotel_id, "date": date, "type": type_}
    return _get("transfer-schedule/", params)


def transfer_content(slug: str, lang: str = "ru"):
    params = {"lang": lang}
    return _get(f"transfer-content/{slug}/", params)


def list_excursions(lang: str = "ru", date: str | None = None, region: str | None = None):
    params = {"lang": lang}
    if date:
        params["date"] = date
    if region:
        params["region"] = region
    return _get("excursions/", params)


def excursion_detail(excursion_id: int, lang: str = "ru"):
    params = {"lang": lang}
    return _get(f"excursions/{excursion_id}/", params)


def excursion_title(excursion_id: int, lang: str = "ru") -> str:
    data = excursion_detail(excursion_id, lang) or {}
    return data.get("localized_title") or data.get("title") or ""


@dataclass
class PickupItem:
    id: int
    point: str
    time: Optional[str]  # "HH:MM" or None
    lat: Optional[float] = None
    lng: Optional[float] = None
    direction: Optional[str] = None  # e.g. "to_gibraltar" / "to_malaga"


def _num(x, default=None):
    try:
        if x is None:
            return default
        return float(x)
    except Exception:
        return default

def _pick(raw, *names, cast=float):
    """Достаёт первое непустое поле из списка имён и приводит тип."""
    for n in names:
        if n in raw and raw[n] is not None:
            try:
                return cast(raw[n])
            except Exception:
                try:
                    return cast(str(raw[n]).replace(',', '.'))
                except Exception:
                    return None
    return None

class CSIClient:
    def __init__(self,
                 base: Optional[str] = None,
                 timeout: Optional[float] = None,
                 cache_seconds: Optional[int] = None):
        self.base = (base or getattr(settings, "CSI_API_BASE", "")).rstrip("/")
        self.timeout = timeout or getattr(settings, "CSI_HTTP_TIMEOUT", 8.0)
        self.cache_seconds = cache_seconds if cache_seconds is not None else getattr(settings, "CSI_CACHE_SECONDS", 60)

    # --- internal helpers -------------------------------------------------
    def _get_json(self, url: str, params: Dict[str, Any] | None = None) -> Any:
        resp = requests.get(url, params=params or {}, timeout=self.timeout)
        resp.raise_for_status()
        return resp.json()

    def excursion_title(self, excursion_id: int, lang: str = "ru") -> str | None:
        if not self.base:
            return None
        try:
            url = f"{self.base}/excursions/{excursion_id}/"
            data = self._get_json(url, params={"lang": lang})
            return data.get("title") or data.get("localized_title") or data.get("name")
        except Exception:
            return None

    def _normalize_time(self, value: Any) -> Optional[str]:
        """Return HH:MM if possible; otherwise None."""
        if not value:
            return None
        s = str(value).strip().replace(".", ":")
        parts = s.split(":")
        if len(parts) >= 2 and parts[0].isdigit() and parts[1].isdigit():
            hh = int(parts[0])
            mm = int(parts[1])
            if 0 <= hh <= 23 and 0 <= mm <= 59:
                return f"{hh:02d}:{mm:02d}"
        return None

    def _normalize_pickup(self, raw: Dict[str, Any]) -> PickupItem:
        pid = raw.get("id") or raw.get("pk") or raw.get("pickup_id")
        point = raw.get("point") or raw.get("name") or raw.get("pickup_point") or "Pickup"

        time_val = raw.get("time") or raw.get("pickup_time") or raw.get("departure")
        lat = raw.get("lat") or raw.get("latitude")
        lng = raw.get("lng") or raw.get("longitude")
        direction = raw.get("direction")

        # ← новые варианты названий полей с ценами
        price_adult = _pick(
            raw,
            "price_adult", "adult_price", "price_adult_eur", "priceA", "price", "adult",
            cast=float
        )
        price_child = _pick(
            raw,
            "price_child", "child_price", "price_child_eur", "priceC", "child",
            cast=float
        )

        try:
            pid = int(pid) if pid is not None else 0
        except Exception:
            pid = 0

        item = PickupItem(
            id=pid,
            point=str(point).strip(),
            time=self._normalize_time(time_val),
            lat=float(lat) if lat is not None else None,
            lng=float(lng) if lng is not None else None,
            direction=str(direction) if direction else None,
        )
        # положим как атрибуты, чтобы их увидел pricing_quote
        item.price_adult = price_adult
        item.price_child = price_child
        return item

    # --- public API -------------------------------------------------------
    def excursion_pickup(self, excursion_id: int, hotel_id: int) -> dict | None:
        if not self.base:
            raise RuntimeError("CSI_API_BASE is not configured")

        pickup_url = f"{self.base}/excursions/{excursion_id}/pickup/"
        try:
            raw = self._get_json(pickup_url, params={"hotel_id": hotel_id})
            if not isinstance(raw, dict) or ("id" not in raw and "name" not in raw):
                return None

            item = {
                "id": raw.get("id"),
                "name": raw.get("name"),
                "lat": float(raw["lat"]) if raw.get("lat") is not None else None,
                "lng": float(raw["lng"]) if raw.get("lng") is not None else None,
                "time": raw.get("time"),
                "price_adult": _pick(raw, "price_adult", "adult_price", "price_adult_eur", "priceA", "price", "adult"),
                "price_child": _pick(raw, "price_child", "child_price", "price_child_eur", "priceC", "child"),
            }

            title = self.excursion_title(excursion_id, lang=getattr(settings, "LANGUAGE_CODE", "ru"))
            if title:
                item["excursion_title"] = title

            return item
        except requests.HTTPError as e:
            if e.response is not None and e.response.status_code == 404:
                return None
            raise

    def excursion_pickups(self, excursion_id: int, hotel_id: Optional[int], date: str) -> List[Dict[str, Any]]:
        """
        Эмулируем список пикапов на дату. Сейчас источник отдаёт одну точку для (excursion, hotel).
        """
        if not hotel_id:
            return []
        one = self.excursion_pickup(excursion_id, hotel_id)
        if not one:
            return []
        return [{
            "id": one.get("id"),
            "point": one.get("name") or one.get("point") or "Pickup",
            "time": one.get("time"),
            "lat": one.get("lat"),
            "lng": one.get("lng"),
            "direction": one.get("direction"),
            "price_adult": one.get("price_adult"),
            "price_child": one.get("price_child"),
        }]

    # --- pricing -----------------------------------------------------------
    def excursion_pricing(self,
                          excursion_id: int,
                          adults: int,
                          children: int,
                          infants: int,
                          region: str | None = None,
                          company_id: int | None = None,
                          lang: str = "ru") -> dict:
        """
        Тянем котировку из основной базы.
        Пробуем основной эндпоинт /api/excursions/{id}/pricing/,
        а затем несколько запасных вариантов. Возвращаем нормализованный dict.
        """
        if not self.base:
            raise RuntimeError("CSI_API_BASE is not configured")

        params = {
            "adults": adults,
            "children": children,
            "infants": infants,
            "lang": lang
        }
        if region:
            params["region"] = region
        if company_id is not None:
            params["company_id"] = company_id

        # список возможных url (на случай, если в старой админке другой роут)
        candidates = [
            f"{self.base}/excursions/{excursion_id}/pricing/",
            f"{self.base}/excursions/{excursion_id}/quote/",
            f"{self.base}/excursions/{excursion_id}/price/",
        ]

        data = None
        last_exc = None
        for url in candidates:
            try:
                data = self._get_json(url, params=params)
                break
            except requests.HTTPError as e:
                last_exc = e
                # если 404 — пробуем следующий кандидат
                if e.response is not None and e.response.status_code == 404:
                    continue
                else:
                    raise
            except Exception as e:
                last_exc = e
                continue

        if data is None:
            # ничего не нашли — мягкий фолбэк
            return {
                "ok": False,
                "gross": 0.0,
                "currency": "EUR",
                "net": None,
                "commission": None,
                "per_adult": None,
                "per_child": None,
                "raw": {"error": str(last_exc) if last_exc else "no-data"}
            }

        # разные сериализаторы отдают разные ключи — аккуратно вытащим общие поля
        currency = (data.get("currency")
                    or data.get("curr")
                    or data.get("code")
                    or "EUR")

        gross = (_num(data.get("gross"))
                 or _num(data.get("total"))
                 or _num(data.get("price_total"))
                 or 0.0)

        net = (_num(data.get("net"))
               or _num(data.get("netto"))
               or None)

        commission = (_num(data.get("commission"))
                      or _num(data.get("comm"))
                      or (gross - net if (gross is not None and net is not None) else None))

        per_adult = (_num(data.get("price_adult"))
                     or _num(data.get("adult_price"))
                     or None)

        per_child = (_num(data.get("price_child"))
                     or _num(data.get("child_price"))
                     or None)

        return {
            "ok": True if gross else False,
            "gross": float(gross or 0.0),
            "currency": str(currency),
            "net": net,
            "commission": commission,
            "per_adult": per_adult,
            "per_child": per_child,
            "raw": data,  # полезно для отладки в DEV
        }


# --- модульные врапперы -----------------------------------------------------

class NotFoundError(Exception):
    pass

def _to_money(x) -> float:
    if x is None:
        return 0.0
    d = Decimal(str(x)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
    return float(d)

def pricing_quote(
    excursion_id: int,
    adults: int,
    children: int,
    infants: int,
    lang: str | None = None,
    hotel_id: int | None = None,
    hotel_name: str | None = None,
    date: str | None = None,
    region_override: dict | None = None,
    **_
) -> dict:
    """
    Возвращает {"gross": float, "currency": "EUR", "meta": {...}}.
    Порядок: (1) CSI-котировщик → (2) PICKUP v2 → (3) REGION.
    """

    # 1) Попытка через CSI (если когда-нибудь появится рабочая ручка)
    try:
        data = _get(
            f"/excursions/{excursion_id}/pricing/",
            params={
                "adults": adults,
                "children": children,
                "infants": infants,
                "lang": lang or "ru",
                "hotel_id": hotel_id,
                "date": date,
            },
            allow_404=True,
        )
        if isinstance(data, dict) and "gross" in data:
            return {
                "gross": _money(data.get("gross")),
                "currency": data.get("currency", "EUR"),
                "meta": {
                    "adult_price": _money((data.get("breakdown") or {}).get("adult_price")),
                    "child_price": _money((data.get("breakdown") or {}).get("child_price")),
                    "source": "CSI",
                    "excursion_id": excursion_id,
                    "hotel_id": hotel_id,
                    "date": date,
                },
            }
    except Exception:
        pass

    # 2) PICKUP v2: считаем из цены точки сбора на конкретную дату
    try:
        pickups = get_client().excursion_pickups(
            excursion_id=excursion_id,
            hotel_id=hotel_id,
            date=date or "",
        )
    except Exception:
        pickups = []

    if pickups:
        p = pickups[0]
        adult_price = _money(p.get("price_adult"))
        child_price = _money(p.get("price_child") if p.get("price_child") is not None else adult_price)
        gross = _money(adult_price * adults + child_price * children)
        return {
            "gross": gross,
            "currency": p.get("currency") or "EUR",
            "meta": {
                "adult_price": adult_price,
                "child_price": child_price,
                "source": "PICKUP",
                "excursion_id": excursion_id,
                "hotel_id": hotel_id,
                "date": date,
            },
        }

    # 3) REGION-фолбэк: берём цены экскурсии для региона отеля (или оверрайд)
    if region_override and (region_override.get("id") or region_override.get("slug")):
        region = {"id": region_override.get("id"), "slug": region_override.get("slug")}
    elif hotel_id:
        region = _hotel_region(hotel_id)
    else:
        region = None

    prices = _excursion_price_for_region(excursion_id, region)
    if prices:
        a, c, cur = prices
        gross = _money(a * adults + c * children)
        return {
            "gross": gross,
            "currency": cur or "EUR",
            "meta": {
                "adult_price": _money(a),
                "child_price": _money(c),
                "source": "REGION",
                "region": region,
                "excursion_id": excursion_id,
                "hotel_id": hotel_id,
                "date": date,
            },
        }

    raise NotFoundError("Pricing not available (no pickup and no CSI quote).")


# Factory (single place to construct client)
_client: Optional[CSIClient] = None


def get_client() -> CSIClient:
    global _client
    if _client is None:
        _client = CSIClient()
    return _client


def excursion_pickups(excursion_id: int, hotel_id: Optional[int], date: str):
    return get_client().excursion_pickups(excursion_id=excursion_id, hotel_id=hotel_id, date=date)


def excursion_pickup(excursion_id: int, hotel_id: int):
    return get_client().excursion_pickup(excursion_id, hotel_id)


def excursion_pickup_once(excursion_id: int, hotel_id: int) -> dict | None:
    """Возвращает одну точку сбора для пары (excursion, hotel) или None.
    Нормализует поля цен в ключи price_adult / price_child (float)."""
    url = urljoin(_base(), f"excursions/{excursion_id}/pickup/")
    try:
        resp = requests.get(
            url,
            params={"hotel_id": hotel_id},
            timeout=settings.CSI_HTTP_TIMEOUT,
        )
        if resp.status_code == 404:
            return None
        resp.raise_for_status()
        data = resp.json()
        if not isinstance(data, dict):
            return None

        def _num(v):
            if v is None or v == "":
                return None
            try:
                return float(v)
            except Exception:
                try:
                    return float(str(v).replace(",", "."))
                except Exception:
                    return None

        def _pick(raw, *names):
            for n in names:
                if n in raw and raw[n] not in (None, ""):
                    val = _num(raw[n])
                    if val is not None:
                        return val
            return None

        # Нормализуем цены к единому виду
        pa = _pick(data, "price_adult", "adult_price", "price_adult_eur", "priceA", "price", "adult")
        pc = _pick(data, "price_child", "child_price", "price_child_eur", "priceC", "child")

        data["price_adult"] = pa
        data["price_child"] = pc

        return data

    except requests.RequestException:
        log.exception("CSI excursion_pickup_once failed: %s", url)
        return None



def _safe_float(x, default=None):
    try:
        if x is None: return default
        return float(x)
    except Exception:
        return default


```


---

## `backend/sales/tests.py`

```py
from django.test import TestCase

# Create your tests here.

```


---

## `backend/templates/admin/sales/familybooking/change_list.html`

```html
{% extends "admin/change_list.html" %}
{% load i18n %}

{% block object-tools-items %}
  {{ block.super }}
  <li>
    <a class="addlink" href="{% url 'admin:sales_familybooking_import' %}">
      Импорт туристов
    </a>
  </li>
{% endblock %}

```


---

## `backend/templates/admin/sales/familybooking/import_form.html`

```html
{% extends "admin/base_site.html" %}

{% block content %}
  <div class="content">
    <h1>{{ title }}</h1>
    <form method="post" enctype="multipart/form-data" novalidate>
      {% csrf_token %}
      <fieldset class="module aligned">
        <div class="form-row">
          <label for="id_file">{{ form.file.label }}:</label>
          {{ form.file }}
          {% if form.file.errors %}<div class="errors">{{ form.file.errors }}</div>{% endif %}
        </div>
        <div class="form-row">
          <label for="id_dry_run">{{ form.dry_run.label }}:</label>
          {{ form.dry_run }}
          {% if form.dry_run.errors %}<div class="errors">{{ form.dry_run.errors }}</div>{% endif %}
        </div>
      </fieldset>
      <div class="submit-row">
        <input type="submit" class="default" value="Запустить импорт">
        <a href="{% url 'admin:sales_familybooking_changelist' %}" class="button">Отмена</a>
      </div>
    </form>
  </div>
{% endblock %}

```


---

## `backend/templates/sales/tourists_import.html`

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>Импорт туристов</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; max-width:980px; }
    .row { margin:12px 0; }
    table { border-collapse: collapse; width:100%; margin-top:10px; }
    th, td { border:1px solid #e5e7eb; padding:8px; font-size:14px; }
    th { background:#f9fafb; text-align:left; }
    .ok { color:#065f46; } .warn { color:#92400e; } .err { color:#991b1b; }
    .messages { margin: 12px 0; }
  </style>
</head>
<body>
  <h1>Импорт туристов (Excel/CSV)</h1>

  <div class="messages">
    {% if messages %}
      {% for m in messages %}
        <div class="{{ m.tags }}">{{ m }}</div>
      {% endfor %}
    {% endif %}
  </div>

  <div class="card">
    <form method="post" enctype="multipart/form-data">
      {% csrf_token %}
      <div class="row">
        {{ form.file.label_tag }}<br>
        {{ form.file }}
        <div style="font-size:12px;color:#6b7280">{{ form.file.help_text }}</div>
      </div>
      <div class="row">
        <label>{{ form.dry_run }} {{ form.dry_run.label }}</label>
      </div>
      <div class="row">
        <button type="submit">Загрузить</button>
      </div>
    </form>
  </div>

  {% if report %}
    <h2>Отчёт</h2>
    <div class="card">
      <p>Лист: <b>{{ report.sheet }}</b></p>
      <p>Строк всего: {{ report.total_rows }}</p>
      <p>Семей создано: {{ report.created_families }},
         обновлено: {{ report.updated_families }},
         туристов создано: {{ report.created_travelers }}</p>

      <h3>Сопоставление колонок</h3>
      <table>
        <thead><tr><th>Поле</th><th>Колонка в файле</th></tr></thead>
        <tbody>
          {% for k,v in report.column_mapping.items %}
            <tr><td>{{ k }}</td><td>{{ v }}</td></tr>
          {% endfor %}
        </tbody>
      </table>

      {% if report.issues and report.issues|length > 0 %}
        <h3>Замечания</h3>
        <table>
          <thead><tr><th>#</th><th>Сообщение</th><th>Данные</th></tr></thead>
          <tbody>
            {% for it in report.issues %}
              <tr>
                <td>{{ it.rownum }}</td>
                <td>{{ it.message }}</td>
                <td><pre style="white-space:pre-wrap">{{ it.payload|default:"" }}</pre></td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      {% endif %}
    </div>
  {% endif %}
</body>
</html>

```
