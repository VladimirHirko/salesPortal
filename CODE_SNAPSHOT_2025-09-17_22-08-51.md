# Code snapshot (2025-09-17T22:08:51)



---

## `backend/manage.py`

```py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```


---

## `backend/sales_portal/settings.py`

```py
"""
Django settings for sales_portal project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

import os
from pathlib import Path
from dotenv import load_dotenv
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

CSI_API_MODE = os.getenv("CSI_API_MODE", "prod")
CSI_API_BASE = os.getenv("CSI_API_BASE_PROD") if CSI_API_MODE == "prod" else os.getenv("CSI_API_BASE_LOCAL")
CSI_HTTP_TIMEOUT = float(os.getenv("CSI_HTTP_TIMEOUT", "6"))
CSI_CACHE_SECONDS = int(os.getenv("CSI_CACHE_SECONDS", "60"))

CSI = {
    "MODE": CSI_API_MODE,
    "BASE": CSI_API_BASE,
    "HTTP_TIMEOUT": CSI_HTTP_TIMEOUT,
    "CACHE_SECONDS": CSI_CACHE_SECONDS,
    "TOKEN": os.getenv("CSI_API_TOKEN", ""),
}


# Простой локальный кэш (на проде можно поменять на Redis)
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "salesportal-cache",
        "TIMEOUT": CSI_CACHE_SECONDS,
        "KEY_FUNCTION": "sales.cache.make_key",  # <— вот это
    }
}

REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
        "rest_framework.parsers.FormParser",
        "rest_framework.parsers.MultiPartParser",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        # позже добавим JWT, если понадобится
    ],
}

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "console": {"class": "logging.StreamHandler"},
    },
    "loggers": {
        "django": {"handlers": ["console"], "level": "INFO"},
        "sales": {"handlers": ["console"], "level": "DEBUG"},  # наш app
        "requests": {"handlers": ["console"], "level": "WARNING"},
    },
}



# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv(
    "SECRET_KEY",
    "django-insecure-#zl=j@4t*mj1s^hy*o5nb@+jbg_od^=+bq25)jd%a)_jb6z@1y"
)

DEBUG = os.getenv("DEBUG", "1") == "1"
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "").split(",") if not DEBUG else []

# Безопасные куки и заголовки — зависят от DEBUG:
if DEBUG:
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
    # Локально редирект на HTTPS не нужен
    # SECURE_SSL_REDIRECT = False
else:
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
    # Включим редирект на HTTPS на проде (раскомментируй при готовности):
    # SECURE_SSL_REDIRECT = True


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    "rest_framework",
    "corsheaders",
    "sales",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOW_ALL_ORIGINS = True  # ок для dev
CORS_ALLOW_CREDENTIALS = True

CSRF_TRUSTED_ORIGINS = [
    "http://127.0.0.1:3000",
    "http://localhost:3000",
]

ROOT_URLCONF = 'sales_portal.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# TEMPLATES
TEMPLATES[0]["DIRS"] = [BASE_DIR / "templates"]  # был пустой список

WSGI_APPLICATION = 'sales_portal.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "sales_portal.sqlite3",
    },
    # Разкомментируем, если понадобится прямой доступ к старой БД:
    # "legacy": {
    #     "ENGINE": "django.db.backends.sqlite3",
    #     "NAME": "/Users/vladimir_hirko/Documents/CostaSolinfo/backend/db.sqlite3",
    #     "OPTIONS": {"timeout": 20},
    # }
}

DATA_UPLOAD_MAX_MEMORY_SIZE = 20 * 1024 * 1024  # 20 MB
FILE_UPLOAD_MAX_MEMORY_SIZE = 20 * 1024 * 1024


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'ru'

TIME_ZONE = 'Europe/Madrid'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

# Static / Media
STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"           # пригодится на проде
STATICFILES_DIRS = [BASE_DIR / "static"]         # если положишь кастомные стили/скрипты

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

```


---

## `backend/sales_portal/urls.py`

```py
# backend/sales_portal/urls.py
from django.contrib import admin
from django.urls import path, include
from django.http import JsonResponse
from django.conf import settings
from django.conf.urls.static import static

def health(_): return JsonResponse({"status": "ok"})

urlpatterns = [
    path('admin/', admin.site.urls),
    path("api/sales/", include("sales.urls")),  # и API, и страница импорта тут же
    path("api/health/", health),
]

# В DEV раздаём media-файлы
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

```


---

## `backend/sales_portal/wsgi.py`

```py
"""
WSGI config for sales_portal project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')

application = get_wsgi_application()

```


---

## `backend/sales_portal/asgi.py`

```py
"""
ASGI config for sales_portal project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'sales_portal.settings')

application = get_asgi_application()

```


---

## `backend/sales/apps.py`

```py
from django.apps import AppConfig


class SalesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'sales'

```


---

## `backend/sales/models.py`

```py
from django.db import models
from django.contrib.auth.models import User

class Company(models.Model):
    name = models.CharField(max_length=120)
    slug = models.SlugField(unique=True)
    email_for_orders = models.EmailField(blank=True, null=True)
    is_active = models.BooleanField(default=True)
    def __str__(self): return self.name

class GuideProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    companies = models.ManyToManyField(Company, blank=True)
    def __str__(self): return self.user.get_username()

class BookingSale(models.Model):
    STATUS = [("PENDING","PENDING"),("HOLD","HOLD"),("PAID","PAID"),("CANCELLED","CANCELLED"),("EXPIRED","EXPIRED")]
    company = models.ForeignKey(Company, on_delete=models.PROTECT)
    guide = models.ForeignKey(User, on_delete=models.PROTECT)

    # Внешние справочники (из старой системы) — только ID + snapshot имени
    excursion_id = models.IntegerField()
    excursion_title = models.CharField(max_length=255, blank=True)

    hotel_id = models.IntegerField(null=True, blank=True)
    hotel_name = models.CharField(max_length=255, blank=True)
    region_name = models.CharField(max_length=120, blank=True)

    pickup_point_id = models.IntegerField(null=True, blank=True)
    pickup_point_name = models.CharField(max_length=255, blank=True)
    pickup_time_str = models.CharField(max_length=16, blank=True)

    date = models.DateField()
    adults = models.PositiveIntegerField(default=1)
    children = models.PositiveIntegerField(default=0)
    infants = models.PositiveIntegerField(default=0)

    gross_total = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    net_total = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    commission = models.DecimalField(max_digits=10, decimal_places=2, default=0)

    status = models.CharField(max_length=10, choices=STATUS, default="PENDING")
    payment_method = models.CharField(max_length=30, blank=True)
    booking_code = models.CharField(max_length=20, unique=True)

    created_at = models.DateTimeField(auto_now_add=True)
    def __str__(self): return f"{self.booking_code} / {self.company}"

class FamilyBooking(models.Model):
    # Привязка к внешнему отелю через ID + снэпшот названия
    ref_code = models.CharField("Номер брони/заявки", max_length=64, db_index=True, blank=True)
    hotel_id = models.IntegerField()
    hotel_name = models.CharField(max_length=255, blank=True)
    region_name = models.CharField(max_length=120, blank=True)

    arrival_date = models.DateField(null=True, blank=True)
    departure_date = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=64, blank=True)
    email = models.EmailField(blank=True)
    comment = models.TextField(blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=["hotel_id", "arrival_date"]),
            models.Index(fields=["ref_code"]),
        ]
        ordering = ["-arrival_date", "hotel_name"]

    def __str__(self):
        return f"{self.ref_code or '—'} @ {self.hotel_name}"

class Traveler(models.Model):
    family = models.ForeignKey(FamilyBooking, on_delete=models.CASCADE, related_name="travelers")
    first_name = models.CharField(max_length=64)
    last_name  = models.CharField(max_length=64)
    middle_name = models.CharField(max_length=64, blank=True)
    dob = models.DateField("Дата рождения", null=True, blank=True)
    nationality = models.CharField(max_length=64, blank=True)
    passport = models.CharField(max_length=64, blank=True)
    passport_expiry = models.DateField(null=True, blank=True)
    phone = models.CharField(max_length=64, blank=True)
    email = models.EmailField(blank=True)
    note = models.CharField(max_length=255, blank=True)

    class Meta:
        indexes = [models.Index(fields=["last_name", "first_name", "dob"])]
    def __str__(self): return f"{self.last_name} {self.first_name}"

```


---

## `backend/sales/admin.py`

```py
# sales/admin.py
from django.contrib import admin
from .models import Company, GuideProfile, BookingSale, FamilyBooking, Traveler

@admin.register(FamilyBooking)
class FamilyBookingAdmin(admin.ModelAdmin):
    list_display = ("ref_code","hotel_name","arrival_date","departure_date","created_at")
    search_fields = ("ref_code","hotel_name","region_name","phone","email")
    list_filter = ("arrival_date","region_name")

@admin.register(Traveler)
class TravelerAdmin(admin.ModelAdmin):
    list_display = ("last_name","first_name","dob","family")
    search_fields = ("last_name","first_name","passport","email","phone")
    list_filter = ("dob",)

admin.site.register(Company)
admin.site.register(GuideProfile)
admin.site.register(BookingSale)

```


---

## `backend/sales/urls.py`

```py
# backend/sales/urls.py
from django.urls import path
from . import views_api
from .views_pages import tourists_import_page  # страница импорта

app_name = "sales"

urlpatterns = [
    # HTML-страница (сейчас будет доступна по /api/sales/import/tourists/)
    path("import/tourists/", tourists_import_page, name="tourists_import_page"),

    # API endpoints
    path("login/", views_api.login_view, name="login"),
    path("hotels/", views_api.hotels, name="hotels"),
    path("excursions/", views_api.excursions, name="excursions"),

    # Легаси/простой вариант пикапов
    path("pickups/", views_api.pickups, name="pickups"),

    # Новый нормализованный вариант пикапов (не конфликтует, другой URL)
    path("sales/pickups/", views_api.SalesExcursionPickupsView.as_view(), name="sales_excursion_pickups"),

    path("pricing/quote/", views_api.quote, name="pricing_quote"),
    path("bookings/create/", views_api.create_booking, name="create_booking"),
    path("debug/csi-base/", views_api.debug_csi_base, name="debug_csi_base"),
]

```


---

## `backend/sales/views_api.py`

```py
# sales/views_api.py

from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.http import require_GET
from django.views.decorators.csrf import csrf_exempt
from django.utils.dateparse import parse_date
from .services import costasolinfo as csi
from .services.costasolinfo import get_client
from rest_framework.response import Response
from rest_framework.permissions import AllowAny
from rest_framework.decorators import api_view, permission_classes, authentication_classes
from rest_framework.views import APIView
from rest_framework import status
import re, html


def login_view(request): return JsonResponse({"ok": True})

@csrf_exempt
@api_view(["POST"])
@authentication_classes([])          # отключаем SessionAuthentication => не требует CSRF
@permission_classes([AllowAny])      # в деве позволим всем
def create_booking(request):
    # На этом шаге просто эхо-заглушка, чтобы проверить POST
    data = request.data or {}
    return Response({
        "status": "PENDING",
        "booking_code": "S-000001",
        "echo": data,                # вернём то, что прислали, для наглядности
    })

@api_view(["GET"])
def debug_csi_base(request):
    from django.conf import settings
    return Response({
        "CSI_API_MODE": settings.CSI_API_MODE,
        "CSI_API_BASE": settings.CSI_API_BASE,
        "timeout": settings.CSI_HTTP_TIMEOUT,
        "cache_sec": settings.CSI_CACHE_SECONDS,
    })

@api_view(["GET"])
def hotels(request):
    q = request.query_params.get("q", "").strip()
    if not q:
        return Response({"items": []})
    data = csi.search_hotels(q, limit=int(request.query_params.get("limit", "10")))
    return Response({"items": data} if isinstance(data, list) else (data or {"items": []}))

_TAG_RE = re.compile(r"<[^>]+>")

def _strip_html(s: str) -> str:
    if not s:
        return ""
    # 1) раскодировать HTML сущности (&mdash; и т.д.)
    s = html.unescape(s)
    # 2) убрать теги
    s = _TAG_RE.sub("", s)
    # 3) нормализовать пробелы
    return re.sub(r"\s+", " ", s).strip()

WEEKDAY_NUM_TO_CODE = {0:"mon",1:"tue",2:"wed",3:"thu",4:"fri",5:"sat",6:"sun"}
WEEKDAY_CODE_TO_NUM = {v:k for k,v in WEEKDAY_NUM_TO_CODE.items()}

def _normalize_excursions(raw, compact: bool = True, limit: int | None = None, offset: int = 0):
    """
    Приводим ответ к единому формату { items: [ ... ], total: N }.
    Поддерживаем как массив, так и {items: [...]} из старого API.
    """
    items = raw.get("items") if isinstance(raw, dict) else raw
    if not isinstance(items, list):
        items = []

    total = len(items)
    # пагинация на нашей стороне (простая)
    if limit is not None:
        items = items[offset: offset + limit]

    norm = []
    for it in items:
        # исходные поля
        _id = it.get("id")
        title = it.get("localized_title") or it.get("title") or ""
        description_html = it.get("localized_description") or it.get("description") or ""
        image = it.get("image")
        duration = it.get("duration")
        direction = it.get("direction")
        # дни – могут прийти и кодами, и цифрами; соберём оба и унифицируем
        days_code = it.get("days") or []
        days_num = it.get("available_days") or []
        # добьём отсутствующие представления
        if not days_code and days_num:
            days_code = [WEEKDAY_NUM_TO_CODE.get(n) for n in days_num if n in WEEKDAY_NUM_TO_CODE]
        if not days_num and days_code:
            days_num = [WEEKDAY_CODE_TO_NUM.get(c) for c in days_code if c in WEEKDAY_CODE_TO_NUM]

        languages = it.get("tour_languages") or it.get("languages") or []

        if compact:
            short = _strip_html(description_html)[:220].rstrip()  # короткое описание ~ 220 симв.
            norm.append({
                "id": _id,
                "title": title,
                "short_description": short,
                "duration": duration,
                "direction": direction,
                "days": days_code,              # ["thu", ...]
                "available_days": days_num,     # [3, ...]
                "languages": languages,
                "image": image,
            })
        else:
            # полный вариант, оставляем HTML
            norm.append({
                "id": _id,
                "title": title,
                "description_html": description_html,
                "duration": duration,
                "direction": direction,
                "days": days_code,
                "available_days": days_num,
                "languages": languages,
                "image": image,
            })
    return {"items": norm, "total": total}

@api_view(["GET"])
def excursions(request):
    lang = request.query_params.get("lang", "ru")
    date = request.query_params.get("date")
    region = request.query_params.get("region")
    compact = request.query_params.get("compact", "1") not in ("0", "false", "False")
    # простая пагинация
    try:
        limit = int(request.query_params.get("limit", "20"))
    except ValueError:
        limit = 20
    try:
        offset = int(request.query_params.get("offset", "0"))
    except ValueError:
        offset = 0

    raw = csi.list_excursions(lang=lang, date=date, region=region)
    data = _normalize_excursions(raw, compact=compact, limit=limit, offset=offset)
    return Response(data)


class SalesExcursionPickupsView(APIView):
    """GET /api/sales/pickups/?excursion_id=&hotel_id=&date=YYYY-MM-DD
    Returns: [{id, point, time, lat?, lng?, direction?}]"""

    def get(self, request, *args, **kwargs):
        try:
            excursion_id = int(request.GET.get("excursion_id", ""))
            hotel_id = int(request.GET.get("hotel_id", ""))
        except ValueError:
            return Response({
                "detail": "excursion_id and hotel_id must be integers"
            }, status=status.HTTP_400_BAD_REQUEST)

        date_str = request.GET.get("date")
        if not date_str or not parse_date(date_str):
            return Response({"detail": "Invalid or missing 'date' (YYYY-MM-DD)"}, status=status.HTTP_400_BAD_REQUEST)

        client = get_client()
        pickups = client.excursion_pickups(excursion_id=excursion_id, hotel_id=hotel_id, date=date_str)

        # добавим название экскурсии (язык можно брать из заголовка/квери, по умолчанию ru)
        lang = (request.GET.get("lang") or request.headers.get("Accept-Language") or "ru")[:5]
        title = csi.excursion_title(excursion_id, lang=lang)

        return Response({
            "excursion_id": excursion_id,
            "excursion_title": title,
            "hotel_id": hotel_id,
            "date": date_str,
            "count": len(pickups),
            "results": pickups,
        })


@api_view(["GET"])
def pickups(request):
    ex_id = request.GET.get("excursion_id")
    hotel_id = request.GET.get("hotel_id")
    date = request.GET.get("date")  # пока не используем

    if not ex_id or not hotel_id:
        return Response({"error": "excursion_id and hotel_id are required", "items": []}, status=400)

    try:
        ex_id = int(ex_id)
        hotel_id = int(hotel_id)
    except ValueError:
        return Response({"error": "excursion_id and hotel_id must be integers", "items": []}, status=400)

    item = csi.get_client().excursion_pickup(ex_id, hotel_id)
    if not item:
        # совместимо с фронтом: пустой список — просто нет точки
        return Response({"items": []}, status=200)

    # язык для заголовка экскурсии
    lang = (request.GET.get("lang") or request.headers.get("Accept-Language") or "ru")[:5]
    title = csi.excursion_title(ex_id, lang=lang)

    # Нормализуем к единому виду
    norm = {
        "id": item.get("id"),
        "point": item.get("name"),
        "time": item.get("time"),       # "HH:MM" или None
        "lat": item.get("lat"),
        "lng": item.get("lng"),
        "price_adult": item.get("price_adult"),
        "price_child": item.get("price_child"),
    }
    return Response({
        "excursion_id": ex_id,
        "excursion_title": title,
        "hotel_id": hotel_id,
        "items": [norm]
    }, status=200)




@api_view(["GET"])
def quote(request):
    try:
        ex_id = int(request.query_params["excursion_id"])
        adults = int(request.query_params.get("adults", "1"))
        children = int(request.query_params.get("children", "0"))
        infants = int(request.query_params.get("infants", "0"))
    except (KeyError, ValueError):
        return Response({"error": "invalid params"}, status=400)
    region = request.query_params.get("region")
    company_id = request.query_params.get("company_id")
    lang = request.query_params.get("lang", "ru")
    data = csi.pricing_quote(ex_id, adults, children, infants, region,
                             int(company_id) if company_id else None, lang)
    return Response(data)
```


---

## `backend/sales/views_pages.py`

```py
# sales/views_pages.py
from django.shortcuts import render
from django.views.decorators.http import require_http_methods
from django.contrib import messages
from .forms import TouristsImportForm
from .importers.tourists_excel import import_tourists_excel

@require_http_methods(["GET", "POST"])
def tourists_import_page(request):
    if request.method == "POST":
        form = TouristsImportForm(request.POST, request.FILES)
        if form.is_valid():
            f = form.cleaned_data["file"]
            dry = form.cleaned_data["dryrun"]
            try:
                report = import_tourists_excel(f, dry_run=dry)
                if report.get("issues"):
                    messages.warning(request, "Импорт завершён с замечаниями.")
                else:
                    messages.success(request, "Импорт завершён успешно.")
                return render(request, "sales/tourists_import.html", {
                    "form": form,
                    "report": report,
                })
            except Exception as e:
                messages.error(request, f"Ошибка импорта: {e}")
    else:
        form = TouristsImportForm()
    return render(request, "sales/tourists_import.html", {"form": form})

```


---

## `backend/sales/forms.py`

```py
# sales/forms.py
from django import forms

class TouristsImportForm(forms.Form):
    file = forms.FileField(
        label="Файл Excel/CSV",
        help_text="Поддерживается .xlsx (рекомендовано) и .csv"
    )
    dryrun = forms.BooleanField(
        label="Dry-run (проверка без сохранения)",
        initial=True,
        required=False
    )

```


---

## `backend/sales/importers/__init__.py`

```py

```


---

## `backend/sales/importers/tourists_excel.py`

```py
from __future__ import annotations
import pandas as pd
from datetime import datetime
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from django.db import transaction
from django.utils.timezone import make_naive
from sales.models import FamilyBooking, Traveler
from sales.services import costasolinfo as csi
import re

def _norm(s: str) -> str:
    if s is None:
        return ""
    s = str(s)
    s = s.replace("\xa0", " ")          # NBSP -> обычный пробел
    s = re.sub(r"\s+", " ", s).strip()
    s = s.lower()
    # уберём лишние символы, чтобы "check-out" == "check out"
    s = re.sub(r"[^\w\sа-яё\-]", "", s, flags=re.IGNORECASE)
    s = s.replace("-", " ")
    s = re.sub(r"\s+", " ", s).strip()
    return s

def _find_col(df: pd.DataFrame, aliases: List[str]) -> Optional[str]:
    cols = [str(c).strip() for c in df.columns]
    norm_cols = {c: _norm(c) for c in cols}
    norm_alias = [_norm(a) for a in aliases]

    # сначала — точное совпадение нормализованной строки
    for c, nc in norm_cols.items():
        if nc in norm_alias:
            return c
    # затем — частичное вхождение
    for c, nc in norm_cols.items():
        if any(na in nc for na in norm_alias if na):
            return c
    return None



COLMAP = {
    "ref_code": ["Номер брони","Номер заявки","Reservation","Booking","ref","Заявка"],
    "hotel": ["Отель","Hotel","Гостиница"],
    "arrival": ["Дата заезда","Arrival","Дата прилёта","Check-in","Check in","Заезд"],
    "departure": [
        "Дата выезда","Дата отъезда","Отъезд","Выезд",
        "Дата возвращения","Возврат",
        "Departure","Return date",
        "Check-out","Check out",
        "Дата вылета","Вылет"
    ],
    "last_name": ["Фамилия","Last name","Surname"],
    "first_name": ["Имя","First name","Name"],
    "middle_name": ["Отчество","Middle name","Patronymic"],
    "dob": ["Дата рождения","DOB","Birth date"],
    "nationality": ["Национальность","Nationality"],
    "passport": ["Паспорт","Passport","Doc number"],
    "passport_expiry": ["Срок действия паспорта","Passport expiry","Expiry"],
    "phone": ["Телефон","Phone","Номер телефона","Контактный телефон"],
    "email": ["Email","E-mail","Эл. почта","Почта"],
    "note": ["Примечание","Note","Комментарий"],
}

def _find_col(df: pd.DataFrame, aliases: List[str]) -> Optional[str]:
    cols = [str(c).strip() for c in df.columns]
    for a in aliases:
        for c in cols:
            if c.lower() == a.lower():
                return c
    low_alias = [a.lower() for a in aliases]
    for c in cols:
        lc = c.lower()
        if any(a in lc for a in low_alias):
            return c
    return None

def _parse_date(v):
    if v is None or (isinstance(v, float) and pd.isna(v)) or (isinstance(v, str) and not v.strip()):
        return None
    if isinstance(v, (datetime, pd.Timestamp)):
        try:
            return make_naive(v).date() if isinstance(v, pd.Timestamp) and v.tzinfo else v.date()
        except Exception:
            return v.date() if hasattr(v, "date") else None
    for fmt in ("%d.%m.%Y","%Y-%m-%d","%d/%m/%Y","%m/%d/%Y"):
        try: return datetime.strptime(str(v).strip(), fmt).date()
        except Exception: pass
    d = pd.to_datetime(v, dayfirst=True, errors="coerce")
    return d.date() if not pd.isna(d) else None

def _resolve_hotel(name: str) -> tuple[Optional[int], str, str]:
    try:
        items = csi.search_hotels(name, limit=1) or []
        if isinstance(items, dict):
            items = items.get("items") or []
        if items:
            h = items[0]
            return h.get("id"), h.get("name") or h.get("title") or name, (h.get("region") or h.get("region_name") or "")
    except Exception:
        pass
    return None, name, ""

# ---------- НОВОЕ: авто-детекция строки заголовков ----------
def _auto_header(df0: pd.DataFrame) -> pd.DataFrame:
    """
    Если текущие имена колонок «Unnamed: …» или не совпадают с алиасами,
    пытаемся найти строку, где есть знакомые заголовки (Фамилия, Имя, Отель)
    и назначаем её как header.
    """
    # если колонок с нормальными именами уже хватает — оставляем как есть
    def _score(cols: List[str]) -> int:
        cols_l = [str(c).strip().lower() for c in cols]
        score = 0
        for key, aliases in COLMAP.items():
            for a in aliases:
                a = a.lower()
                if a in cols_l:
                    score += 1
                    break
        return score

    if _score(list(df0.columns)) >= 2:
        return df0  # уже норм

    # перебираем первые 10 строк — ищем лучшую «шапку»
    best = (None, -1)
    for i in range(min(10, len(df0))):
        row = [str(x).strip() for x in df0.iloc[i].tolist()]
        sc = _score(row)
        if sc > best[1]:
            best = (i, sc)
    header_idx, sc = best
    if header_idx is not None and sc >= 2:
        # назначаем найденную строку заголовком
        new_cols = [str(x).strip() or f"col_{j}" for j, x in enumerate(df0.iloc[header_idx].tolist())]
        df = df0.iloc[header_idx + 1 : ].copy()
        df.columns = new_cols
        return df

    # fallback: вернуть как есть
    return df0

# ---------- Отчет ----------
@dataclass
class RowIssue:
    rownum: int
    message: str
    payload: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ImportReport:
    sheet: str
    total_rows: int = 0
    created_families: int = 0
    updated_families: int = 0
    created_travelers: int = 0
    issues: List[RowIssue] = field(default_factory=list)

def import_tourists_excel(file, dry_run: bool = True) -> Dict[str, Any]:
    # читаем .xlsx или .csv
    if hasattr(file, "name") and str(file.name).lower().endswith(".csv"):
        df0 = pd.read_csv(file, header=None)  # без заголовка — определим сами
        sheet_name = "CSV"
    else:
        xls = pd.ExcelFile(file)
        sheet_name = xls.sheet_names[0]
        # читаем БЕЗ заголовков, потом определим
        df0 = xls.parse(sheet_name, header=None)

    # авто-детекция header
    df = _auto_header(df0)
    report = ImportReport(sheet=sheet_name, total_rows=len(df))

    # сопоставление колонок
    cols = {key: _find_col(df, aliases) for key, aliases in COLMAP.items()}
    required = ["hotel","last_name","first_name"]
    missing = [k for k in required if not cols.get(k)]
    if missing:
        report.issues.append(RowIssue(0, f"Нет обязательных колонок: {missing}"))
        return {
            **report.__dict__,
            "column_mapping": {k: cols[k] for k in cols if cols[k]},
            "issues": [i.__dict__ for i in report.issues],
            "dry_run": dry_run,
        }

    @transaction.atomic
    def _do():
        for idx, row in df.iterrows():
            hotel_raw = str(row.get(cols["hotel"], "")).strip()
            if not hotel_raw:
                report.issues.append(RowIssue(idx+2, "Пустой отель")); continue
            hotel_id, hotel_name, region_name = _resolve_hotel(hotel_raw)

            ref_code = str(row.get(cols.get("ref_code"), "")).strip() if cols.get("ref_code") else ""
            arrival = _parse_date(row.get(cols.get("arrival"))) if cols.get("arrival") else None
            departure = _parse_date(row.get(cols.get("departure"))) if cols.get("departure") else None

            fam = (FamilyBooking.objects
                   .filter(ref_code=ref_code or "", hotel_id=hotel_id or 0)
                   .first())
            if not fam:
                fam = FamilyBooking.objects.create(
                    ref_code=ref_code or "",
                    hotel_id=hotel_id or 0,
                    hotel_name=hotel_name,
                    region_name=region_name,
                    arrival_date=arrival,
                    departure_date=departure,
                )
                report.created_families += 1
            else:
                changed = False
                if arrival and fam.arrival_date != arrival: fam.arrival_date = arrival; changed = True
                if departure and fam.departure_date != departure: fam.departure_date = departure; changed = True
                if hotel_name and fam.hotel_name != hotel_name: fam.hotel_name = hotel_name; changed = True
                if region_name and fam.region_name != region_name: fam.region_name = region_name; changed = True
                if changed:
                    fam.save(update_fields=["arrival_date","departure_date","hotel_name","region_name"])
                    report.updated_families += 1

            traveler = Traveler(
                family=fam,
                last_name=str(row.get(cols["last_name"], "")).strip(),
                first_name=str(row.get(cols["first_name"], "")).strip(),
                middle_name=str(row.get(cols.get("middle_name"), "")).strip() if cols.get("middle_name") else "",
                dob=_parse_date(row.get(cols.get("dob"))) if cols.get("dob") else None,
                nationality=str(row.get(cols.get("nationality"), "")).strip() if cols.get("nationality") else "",
                passport=str(row.get(cols.get("passport"), "")).strip() if cols.get("passport") else "",
                passport_expiry=_parse_date(row.get(cols.get("passport_expiry"))) if cols.get("passport_expiry") else None,
                phone=str(row.get(cols.get("phone"), "")).strip() if cols.get("phone") else "",
                email=str(row.get(cols.get("email"), "")).strip() if cols.get("email") else "",
                note=str(row.get(cols.get("note"), "")).strip() if cols.get("note") else "",
            )
            traveler.save()
            report.created_travelers += 1

    if dry_run:
        with transaction.atomic():
            _do()
            transaction.set_rollback(True)
    else:
        _do()

    colmap_human = {k: cols[k] for k in cols if cols[k]}
    return {**report.__dict__, "column_mapping": colmap_human, "issues": [i.__dict__ for i in report.issues], "dry_run": dry_run}

```


---

## `backend/sales/services/costasolinfo.py`

```py
# sales/services/costasolinfo.py
from __future__ import annotations
from dataclasses import dataclass
import logging
import requests
from urllib.parse import urljoin, quote_plus
from django.conf import settings
from django.core.cache import cache
from typing import Any, Dict, List, Optional

log = logging.getLogger(__name__)

def _base():
    base = getattr(settings, "CSI_API_BASE", None)
    if not base:
        raise RuntimeError("CSI_API_BASE is not configured. Check .env and settings.py")
    return base.rstrip("/") + "/"

def _get(path: str, params: dict | None = None, cache_key: str | None = None):
    """
    Универсальный GET с таймаутом, простым кэшированием и безопасными ошибками.
    """
    url = urljoin(_base(), path.lstrip("/"))
    key = cache_key or f"csi::{path}::{sorted(params.items()) if params else ''}"
    cached = cache.get(key)
    if cached is not None:
        return cached

    try:
        resp = requests.get(url, params=params, timeout=settings.CSI_HTTP_TIMEOUT)
        resp.raise_for_status()
        data = resp.json()
        cache.set(key, data, timeout=settings.CSI_CACHE_SECONDS)
        return data
    except requests.RequestException as e:
        log.exception("CSI GET failed: %s %s", url, e)
        # Возвращаем предыдущее кэш-значение, если есть
        if cached:
            return cached
        # Фоллбек, чтобы UI не падал
        return {"error": "unavailable", "items": []}

# ==== Конкретные «обёртки» под текущие эндпоинты CostaSolinfo ====

def search_hotels(q: str, limit: int = 10):
    safe_q = quote_plus(q or "")          # пробелы -> '+', прочее экранируется
    cache_key = f"hotels:{safe_q}:{limit}"
    data = cache.get(cache_key)
    if data is not None:
        return data

    # ... твой вызов к API ...
    data = client.search_hotels(q, limit=limit)

    cache.set(cache_key, data, timeout=60)   # или settings.CSI["CACHE_SECONDS"]
    return data

def transfer_schedule(hotel_id: int, date: str, type_: str = "group"):
    # Из твоих проверок: /api/transfer-schedule/?hotel_id=1&date=YYYY-MM-DD&type=group
    params = {"hotel_id": hotel_id, "date": date, "type": type_}
    return _get("transfer-schedule/", params)

def transfer_content(slug: str, lang: str = "ru"):
    # Примеры: transfer-content/transfer_home/?lang=ru
    params = {"lang": lang}
    return _get(f"transfer-content/{slug}/", params)

# Заглушки под экскурсии/прайсинг — подстроим под существующие эндпоинты,
# если у тебя уже есть /api/excursions/ и т.д.
def list_excursions(lang: str = "ru", date: str | None = None, region: str | None = None):
    params = {"lang": lang}
    if date: params["date"] = date
    if region: params["region"] = region
    return _get("excursions/", params)

def excursion_detail(excursion_id: int, lang: str = "ru"):
    """
    Вернёт объект экскурсии (минимум: title / localized_title),
    чтобы можно было отдать excursion_title в Sales-API.
    """
    params = {"lang": lang}
    return _get(f"excursions/{excursion_id}/", params)

def excursion_title(excursion_id: int, lang: str = "ru") -> str:
    data = excursion_detail(excursion_id, lang) or {}
    return (data.get("localized_title")
            or data.get("title")
            or "")

@dataclass
class PickupItem:
    id: int
    point: str
    time: Optional[str]  # "HH:MM" or None
    lat: Optional[float] = None
    lng: Optional[float] = None
    direction: Optional[str] = None  # e.g. "to_gibraltar" / "to_malaga"


class CSIClient:
    def __init__(self,
                 base: Optional[str] = None,
                 timeout: Optional[float] = None,
                 cache_seconds: Optional[int] = None):
        self.base = (base or getattr(settings, "CSI_API_BASE", "")).rstrip("/")
        self.timeout = timeout or getattr(settings, "CSI_HTTP_TIMEOUT", 8.0)
        self.cache_seconds = cache_seconds if cache_seconds is not None else getattr(settings, "CSI_CACHE_SECONDS", 60)

    # --- internal helpers -------------------------------------------------
    def _get_json(self, url: str, params: Dict[str, Any] | None = None) -> Any:
        resp = requests.get(url, params=params or {}, timeout=self.timeout)
        resp.raise_for_status()
        return resp.json()

    def excursion_title(self, excursion_id: int, lang: str = "ru") -> str | None:
        """
        Берём название экскурсии c CostaSolinfo.
        Пробуем детальный эндпоинт: /api/excursions/{id}/
        """
        if not self.base:
            return None
        try:
            url = f"{self.base}/excursions/{excursion_id}/"
            data = self._get_json(url, params={"lang": lang})
            # разные сериализаторы могут отдавать разные ключи — подстрахуемся
            return (data.get("title")
                    or data.get("localized_title")
                    or data.get("name"))
        except Exception:
            return None

    def _normalize_time(self, value: Any) -> Optional[str]:
        """Return HH:MM if possible; otherwise None."""
        if not value:
            return None
        s = str(value).strip()
        # Accept formats like HH:MM, HH:MM:SS, or "07.30"
        s = s.replace(".", ":")
        parts = s.split(":")
        if len(parts) >= 2 and parts[0].isdigit() and parts[1].isdigit():
            hh = int(parts[0])
            mm = int(parts[1])
            if 0 <= hh <= 23 and 0 <= mm <= 59:
                return f"{hh:02d}:{mm:02d}"
        return None

    def _normalize_pickup(self, raw: Dict[str, Any]) -> PickupItem:
        # Try common keys from CostaSolinfo
        pid = raw.get("id") or raw.get("pk") or raw.get("pickup_id")
        point = raw.get("point") or raw.get("name") or raw.get("pickup_point") or "Pickup"
        time_val = raw.get("time") or raw.get("pickup_time") or raw.get("departure")
        lat = raw.get("lat") or raw.get("latitude")
        lng = raw.get("lng") or raw.get("longitude")
        direction = raw.get("direction")
        try:
            pid = int(pid) if pid is not None else 0
        except Exception:
            pid = 0
        return PickupItem(
            id=pid,
            point=str(point).strip(),
            time=self._normalize_time(time_val),
            lat=float(lat) if lat is not None else None,
            lng=float(lng) if lng is not None else None,
            direction=str(direction) if direction else None,
        )

    # --- public API -------------------------------------------------------
    def excursion_pickup(self, excursion_id: int, hotel_id: int) -> dict | None:
        """
        Берём точку сбора для конкретной экскурсии и отеля
        с CostaSolinfo: /api/excursions/{id}/pickup/?hotel_id=...
        И дополняем полем excursion_title.
        """
        if not self.base:
            raise RuntimeError("CSI_API_BASE is not configured")

        # основной эндпоинт (соответствует твоему core.urls в CostaSolinfo)
        pickup_url = f"{self.base}/excursions/{excursion_id}/pickup/"
        try:
            raw = self._get_json(pickup_url, params={"hotel_id": hotel_id})
            # ожидаемый формат см. твой excursion_pickup_view в core: { id, name, lat, lng, time, price_* }
            if not isinstance(raw, dict) or ("id" not in raw and "name" not in raw):
                return None

            # нормализуем типы
            item = {
                "id": raw.get("id"),
                "name": raw.get("name"),
                "lat": float(raw["lat"]) if raw.get("lat") is not None else None,
                "lng": float(raw["lng"]) if raw.get("lng") is not None else None,
                "time": raw.get("time"),  # "HH:MM" or None
                "price_adult": raw.get("price_adult"),
                "price_child": raw.get("price_child"),
            }

            # подтянем название экскурсии (без panics, если не вышло)
            title = self.excursion_title(excursion_id, lang=getattr(settings, "LANGUAGE_CODE", "ru"))
            if title:
                item["excursion_title"] = title

            return item
        except requests.HTTPError as e:
            # 404 — точки нет
            if e.response is not None and e.response.status_code == 404:
                return None
            raise


# Factory (single place to construct client)
_client: Optional[CSIClient] = None

def get_client() -> CSIClient:
    global _client
    if _client is None:
        _client = CSIClient()
    return _client

def excursion_pickups(excursion_id: int, hotel_id: Optional[int], date: str):
    return get_client().excursion_pickups(
        excursion_id=excursion_id,
        hotel_id=hotel_id,
        date=date,
    )

def excursion_pickup(excursion_id: int, hotel_id: int):
    return get_client().excursion_pickup(excursion_id, hotel_id)


def excursion_pickup_once(excursion_id: int, hotel_id: int) -> dict | None:
    """
    Возвращает одну точку сбора для пары (excursion, hotel) или None.
    """
    url = urljoin(_base(), f"excursions/{excursion_id}/pickup/")
    try:
        data = requests.get(
            url,
            params={"hotel_id": hotel_id},
            timeout=settings.CSI_HTTP_TIMEOUT
        )
        if data.status_code == 404:
            return None
        data.raise_for_status()
        return data.json()
    except requests.RequestException:
        log.exception("CSI excursion_pickup_once failed: %s", url)
        return None

def pricing_quote(excursion_id: int, adults: int, children: int, infants: int,
                  region: str | None = None, company_id: int | None = None, lang: str = "ru"):
    """
    Черновой расчёт на нашей стороне.
    Если в старом API есть котировки — можно делать HTTP-запрос туда,
    а пока считаем локально по данным экскурсии (когда подключим).
    """
    # Мини-заглушка: всё нули, чтобы фронт не падал (реальную формулу подключим позже).
    return {
        "gross": 0.0,
        "net": 0.0,
        "commission": 0.0,
        "currency": "EUR",
        "details": {"excursion_id": excursion_id, "adults": adults, "children": children, "infants": infants, "region": region, "company_id": company_id, "lang": lang},
    }

```


---

## `backend/sales/tests.py`

```py
from django.test import TestCase

# Create your tests here.

```


---

## `backend/templates/sales/tourists_import.html`

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>Импорт туристов</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; max-width:980px; }
    .row { margin:12px 0; }
    table { border-collapse: collapse; width:100%; margin-top:10px; }
    th, td { border:1px solid #e5e7eb; padding:8px; font-size:14px; }
    th { background:#f9fafb; text-align:left; }
    .ok { color:#065f46; } .warn { color:#92400e; } .err { color:#991b1b; }
    .messages { margin: 12px 0; }
  </style>
</head>
<body>
  <h1>Импорт туристов (Excel/CSV)</h1>

  <div class="messages">
    {% if messages %}
      {% for m in messages %}
        <div class="{{ m.tags }}">{{ m }}</div>
      {% endfor %}
    {% endif %}
  </div>

  <div class="card">
    <form method="post" enctype="multipart/form-data">
      {% csrf_token %}
      <div class="row">
        {{ form.file.label_tag }}<br>
        {{ form.file }}
        <div style="font-size:12px;color:#6b7280">{{ form.file.help_text }}</div>
      </div>
      <div class="row">
        <label>{{ form.dry_run }} {{ form.dry_run.label }}</label>
      </div>
      <div class="row">
        <button type="submit">Загрузить</button>
      </div>
    </form>
  </div>

  {% if report %}
    <h2>Отчёт</h2>
    <div class="card">
      <p>Лист: <b>{{ report.sheet }}</b></p>
      <p>Строк всего: {{ report.total_rows }}</p>
      <p>Семей создано: {{ report.created_families }},
         обновлено: {{ report.updated_families }},
         туристов создано: {{ report.created_travelers }}</p>

      <h3>Сопоставление колонок</h3>
      <table>
        <thead><tr><th>Поле</th><th>Колонка в файле</th></tr></thead>
        <tbody>
          {% for k,v in report.column_mapping.items %}
            <tr><td>{{ k }}</td><td>{{ v }}</td></tr>
          {% endfor %}
        </tbody>
      </table>

      {% if report.issues and report.issues|length > 0 %}
        <h3>Замечания</h3>
        <table>
          <thead><tr><th>#</th><th>Сообщение</th><th>Данные</th></tr></thead>
          <tbody>
            {% for it in report.issues %}
              <tr>
                <td>{{ it.rownum }}</td>
                <td>{{ it.message }}</td>
                <td><pre style="white-space:pre-wrap">{{ it.payload|default:"" }}</pre></td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      {% endif %}
    </div>
  {% endif %}
</body>
</html>

```
